<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>simba.mixins.statistics_mixin &mdash; SimBA 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/simba_theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />

  
    <link rel="shortcut icon" href="../../../_static/readthedocs_logo.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SimBA
              <img src="../../../_static/readthedocs_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API REFERENCE:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NOTEBOOKS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks.html">Notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">USER GUIDE / TUTORIALS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">WALKTHROUGHS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../walkthroughs.html">Walkthroughs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">LABELLING TUTORIALS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../labelling.html">Labelling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials_rst/FAQ.html">Friendly Asked Questions (FAQ)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DOCS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/workflow.html">SimBA basic workflow</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ABOUT:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html#who-writes-this-stuff">Who writes this stuff??</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../links.html">Links</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SimBA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">simba.mixins.statistics_mixin</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for simba.mixins.statistics_mixin</h1><div class="highlight"><pre>
<span></span><span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Simon Nilsson&quot;</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">permutations</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="p">(</span><span class="n">adjusted_mutual_info_score</span><span class="p">,</span> <span class="n">adjusted_rand_score</span><span class="p">,</span>
                             <span class="n">fowlkes_mallows_score</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">LocalOutlierFactor</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="p">(</span><span class="n">bool_</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int8</span><span class="p">,</span> <span class="n">jit</span><span class="p">,</span> <span class="n">njit</span><span class="p">,</span> <span class="n">objmode</span><span class="p">,</span> <span class="n">optional</span><span class="p">,</span>
                   <span class="n">prange</span><span class="p">,</span> <span class="n">typed</span><span class="p">,</span> <span class="n">types</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="kn">from</span> <span class="nn">scipy.stats.distributions</span> <span class="kn">import</span> <span class="n">chi2</span>
<span class="kn">from</span> <span class="nn">sklearn.covariance</span> <span class="kn">import</span> <span class="n">EllipticEnvelope</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">IsolationForest</span>

<span class="kn">from</span> <span class="nn">simba.mixins.feature_extraction_mixin</span> <span class="kn">import</span> <span class="n">FeatureExtractionMixin</span>
<span class="kn">from</span> <span class="nn">simba.utils.checks</span> <span class="kn">import</span> <span class="p">(</span><span class="n">check_float</span><span class="p">,</span> <span class="n">check_int</span><span class="p">,</span> <span class="n">check_str</span><span class="p">,</span>
                                <span class="n">check_valid_array</span><span class="p">,</span> <span class="n">check_valid_dataframe</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">simba.utils.data</span> <span class="kn">import</span> <span class="n">bucket_data</span><span class="p">,</span> <span class="n">fast_mean_rank</span><span class="p">,</span> <span class="n">fast_minimum_rank</span>
<span class="kn">from</span> <span class="nn">simba.utils.enums</span> <span class="kn">import</span> <span class="n">Formats</span><span class="p">,</span> <span class="n">Options</span>
<span class="kn">from</span> <span class="nn">simba.utils.errors</span> <span class="kn">import</span> <span class="n">CountError</span><span class="p">,</span> <span class="n">InvalidInputError</span>


<div class="viewcode-block" id="Statistics"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics">[docs]</a><span class="k">class</span> <span class="nc">Statistics</span><span class="p">(</span><span class="n">FeatureExtractionMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Primarily frequentist statistics methods used for feature extraction or drift assessment.</span>

<span class="sd">    .. note::</span>

<span class="sd">       Most methods implemented using `numba parallelization &lt;https://numba.pydata.org/&gt;`_ for improved run-times. See</span>
<span class="sd">       `line graph &lt;https://github.com/sgoldenlab/simba/blob/master/docs/_static/img/statistics_runtimes.png&gt;`_ below for expected run-times for a few methods included in this class.</span>

<span class="sd">       Most method has numba typed `signatures &lt;https://numba.pydata.org/numba-doc/latest/reference/types.html&gt;`_ to decrease</span>
<span class="sd">       compilation time through reduced type inference. Make sure to pass the correct dtypes as indicated by signature decorators. If dtype is not specified at</span>
<span class="sd">       array creation, it will typically be ``float64`` or ``int64``. As most methods here use ``float32`` for the input data argument,</span>
<span class="sd">       make sure to downcast.</span>

<span class="sd">       This class contains a few probability distribution comparison methods. These are being moved to ``simba.sandbox.distances`` (05.24).</span>

<span class="sd">    .. image:: _static/img/statistics_runtimes.png</span>
<span class="sd">       :width: 1200</span>
<span class="sd">       :align: center</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">FeatureExtractionMixin</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_hist_1d</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bin_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="nb">range</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted helper to compute 1D histograms with counts or rations (if normalize is True)</span>

<span class="sd">        .. note::</span>
<span class="sd">           For non-heuristic rules for bin counts and bin ranges, see ``simba.data.freedman_diaconis`` or simba.data.bucket_data``.</span>

<span class="sd">        :parameter np.ndarray data: 1d array containing feature values.</span>
<span class="sd">        :parameter int bin_count: The number of bins.</span>
<span class="sd">        :parameter: np.ndarray range: 1d array with two values representing minimum and maximum value to bin.</span>
<span class="sd">        :parameter: Optional[bool] normalize: If True, then the counts are returned as a ratio of all values. If False, then the raw counts. Pass normalize as True if the datasets are unequal counts. Default: True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">bin_count</span><span class="p">,</span> <span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">total_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">total_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hist</span> <span class="o">/</span> <span class="n">total_sum</span>
        <span class="k">return</span> <span class="n">hist</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<div class="viewcode-block" id="Statistics.rolling_independent_sample_t"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_independent_sample_t">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64, float64)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_independent_sample_t</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_window</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute independent-sample t-statistics for sequentially binned values in a time-series.</span>
<span class="sd">        E.g., compute t-test statistics when comparing ``Feature N`` in the current 1s</span>
<span class="sd">        time-window, versus ``Feature N`` in the previous 1s time-window.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter int group_size_s: The size of the buckets in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>

<span class="sd">        .. image:: _static/img/independent_t_tests.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. attention::</span>
<span class="sd">           Each window is compared to the prior window. Output for the windows without a prior window (the first window) is ``-1``.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data_1, data_2 = np.random.normal(loc=10, scale=2, size=10), np.random.normal(loc=20, scale=2, size=10)</span>
<span class="sd">        &gt;&gt;&gt; data = np.hstack([data_1, data_2])</span>
<span class="sd">        &gt;&gt;&gt; Statistics().rolling_independent_sample_t(data, time_window=1, fps=10)</span>
<span class="sd">        &gt;&gt;&gt; [[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -6.88741389, -6.88741389, -6.88741389, -6.88741389, -6.88741389, -6.88741389, -6.88741389, -6.88741389, -6.88741389, -6.88741389])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_window</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span>
                <span class="p">((</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">window_size</span>
            <span class="p">)</span>
            <span class="n">mean_1</span><span class="p">,</span> <span class="n">mean_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">stdev_1</span><span class="p">,</span> <span class="n">stdev_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">pooled_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev_2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_1</span> <span class="o">-</span> <span class="n">mean_2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                <span class="n">pooled_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.independent_samples_t"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.independent_samples_t">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">[:,</span> <span class="p">:]),</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">independent_samples_t</span><span class="p">(</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">critical_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute independent-samples t-test statistic and boolean significance between two distributions.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Critical values are stored in simba.assets.lookups.critical_values_**.pickle</span>


<span class="sd">        The t-statistic for independent samples t-test is calculated using the following formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">           t = \frac{\bar{x}_1 - \bar{x}_2}{s_p \sqrt{\frac{1}{n_1} + \frac{1}{n_2}}}</span>

<span class="sd">        where:</span>
<span class="sd">            - \\(\bar{x}_1\\) and \\(\bar{x}_2\\) are the means of sample_1 and sample_2 respectively,</span>
<span class="sd">            - \\(s_p\\) is the pooled standard deviation,</span>
<span class="sd">            - \\(n_1\\) and \\(n_2\\) are the sample sizes of sample_1 and sample_2 respectively.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray critical_values: 2d array where the first column represents degrees of freedom and second column represents critical values.</span>
<span class="sd">        :returns (float Union[None, bool]) t_statistic, p_value: Representing t-statistic and associated probability value. p_value is ``None`` if critical_values is None. Else True or False with True representing significant.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 2, 3, 1, 3, 2, 1, 10, 8, 4, 10])</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([2, 5, 10, 4, 8, 10, 7, 10, 7, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; Statistics().independent_samples_t(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; (-2.5266046804590183, None)</span>
<span class="sd">        &gt;&gt;&gt; critical_values = pickle.load(open(&quot;simba/assets/lookups/critical_values_05.pickle&quot;,&quot;rb&quot;))[&#39;independent_t_test&#39;][&#39;one_tail&#39;].values</span>
<span class="sd">        &gt;&gt;&gt; Statistics().independent_samples_t(sample_1=sample_1, sample_2=sample_2, critical_values=critical_values)</span>
<span class="sd">        &gt;&gt;&gt; (-2.5266046804590183, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">std_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">std_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">pooled_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">std_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">std_2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">t_statistic</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">pooled_std</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">critical_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sample_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">critical_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">dof</span><span class="p">,</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">critical_value</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t_statistic</span><span class="p">):</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">t_statistic</span><span class="p">,</span> <span class="n">significance_bool</span></div>

<div class="viewcode-block" id="Statistics.cohens_d"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.cohens_d">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64[:])&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cohens_d</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Cohen&#39;s d between two distributions.</span>

<span class="sd">        Cohen&#39;s d is a measure of effect size that quantifies the difference between the means of two distributions in terms of their standard deviation. It is calculated as the difference between the means of the two distributions divided by the pooled standard deviation.</span>

<span class="sd">        Higher values indicate a larger effect size, with 0.2 considered a small effect, 0.5 a medium effect, and 0.8 or above a large effect. Negative values indicate that the mean of sample 2 is larger than the mean of sample 1.</span>


<span class="sd">        .. math::</span>
<span class="sd">           d = \\frac{{\\bar{x}_1 - \\bar{x}_2}}{{\\sqrt{{\\frac{{s_1^2 + s_2^2}}{2}}}}}</span>

<span class="sd">        where:</span>
<span class="sd">            - \\(\\bar{x}_1\\) and \\(\\bar{x}_2\\) are the means of sample_1 and sample_2 respectively,</span>
<span class="sd">            - \\(s_1\\) and \\(s_2\\) are the standard deviations of sample_1 and sample_2 respectively.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns float: Cohens D statistic.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = [2, 4, 7, 3, 7, 35, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = [4, 8, 14, 6, 14, 70, 16, 18]</span>
<span class="sd">        &gt;&gt;&gt; Statistics().cohens_d(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; -0.5952099775170546</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_cohens_d"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_cohens_d">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64[:], float64)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_cohens_d</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of rolling Cohen&#39;s D statistic comparing the current time-window of</span>
<span class="sd">        size N to the preceding window of size N.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter np.ndarray[ints] time_window: Time windows to compute ANOVAs for in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>
<span class="sd">        :returns np.ndarray: Array of size data.shape[0] x window_sizes.shape[1] with Cohens D.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1, sample_2 = np.random.normal(loc=10, scale=1, size=4), np.random.normal(loc=11, scale=2, size=4)</span>
<span class="sd">        &gt;&gt;&gt; sample = np.hstack((sample_1, sample_2))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().rolling_cohens_d(data=sample, window_sizes=np.array([1]), fps=4)</span>
<span class="sd">        &gt;&gt;&gt; [[0.],[0.],[0.],[0.],[0.14718302],[0.14718302],[0.14718302],[0.14718302]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.rolling_two_sample_ks"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_two_sample_ks">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64, float64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_two_sample_ks</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_window</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute Kolmogorov two-sample statistics for sequentially binned values in a time-series.</span>
<span class="sd">        E.g., compute KS statistics when comparing ``Feature N`` in the current 1s time-window, versus ``Feature N`` in the previous 1s time-window.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter float time_window: The size of the buckets in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>
<span class="sd">        :return np.ndarray: Array of size data.shape[0] with KS statistics</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(low=0, high=100, size=(200)).astype(&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; results = Statistics().rolling_two_sample_ks(data=data, time_window=1, fps=30)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">window_size</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_window</span> <span class="o">*</span> <span class="n">fps</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span>
                <span class="p">((</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">window_size</span>
            <span class="p">)</span>
            <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">combined_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">)))</span>
            <span class="n">ecdf_sample_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">combined_samples</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span>
            <span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span>
            <span class="n">ecdf_sample_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span>
                <span class="n">sample_2</span><span class="p">,</span> <span class="n">combined_samples</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span>
            <span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
            <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ecdf_sample_1</span> <span class="o">-</span> <span class="n">ecdf_sample_2</span><span class="p">))</span>
            <span class="n">results</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">ks</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.two_sample_ks"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.two_sample_ks">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">[:,</span> <span class="p">:]),</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">two_sample_ks</span><span class="p">(</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">critical_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">float64</span><span class="p">[:,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute the two-sample Kolmogorov-Smirnov (KS) test statistic and, optionally, test for statistical significance.</span>

<span class="sd">        The two-sample KS test is a non-parametric test that compares the cumulative distribution functions (ECDFs) of two independent samples to assess whether they come from the same distribution.</span>

<span class="sd">        KS statistic (D) is calculated as the maximum absolute difference between the empirical cumulative distribution functions (ECDFs) of the two samples.</span>

<span class="sd">        .. math::</span>
<span class="sd">           D = \\max(| ECDF_1(x) - ECDF_2(x) |)</span>

<span class="sd">        If `critical_values` are provided, the function checks the significance of the KS statistic against the critical values.</span>

<span class="sd">        :param np.ndarray data: The first sample array for the KS test.</span>
<span class="sd">        :param np.ndarray data: The second sample array for the KS test.</span>
<span class="sd">        :param Optional[float64[:, :]] critical_values: An array of critical values for the KS test. If provided, the function will also check the significance of the KS statistic against the critical values. Default: None.</span>
<span class="sd">        :returns (float Union[bool, None]): Returns a tuple containing the KS statistic and a boolean indicating whether the test is statistically significant.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 2, 3, 1, 3, 2, 1, 10, 8, 4, 10]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([10, 5, 10, 4, 8, 10, 7, 10, 7, 10, 10]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; critical_values = pickle.load(open(&quot;simba/assets/lookups/critical_values_5.pickle&quot;, &quot;rb&quot;))[&#39;two_sample_KS&#39;][&#39;one_tail&#39;].values</span>
<span class="sd">        &gt;&gt;&gt; two_sample_ks(sample_1=sample_1, sample_2=sample_2, critical_values=critical_values)</span>
<span class="sd">        &gt;&gt;&gt; (0.7272727272727273, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">combined_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">)))</span>
        <span class="n">ecdf_sample_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">combined_samples</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">sample_1</span>
        <span class="p">)</span>
        <span class="n">ecdf_sample_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">sample_2</span><span class="p">,</span> <span class="n">combined_samples</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">sample_2</span>
        <span class="p">)</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ecdf_sample_1</span> <span class="o">-</span> <span class="n">ecdf_sample_2</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">critical_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">combined_sample_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
            <span class="n">critical_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">combined_sample_size</span><span class="p">,</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">critical_value</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ks</span><span class="p">):</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">significance_bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.one_way_anova"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.one_way_anova">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">one_way_anova</span><span class="p">(</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">critical_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of one-way ANOVA F statistics and associated p-value for two distributions.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns (float float): Representing ANOVA F statistic and associated probability value.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 2, 3, 1, 3, 2, 1, 10, 8, 4, 10])</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([8, 5, 5, 8, 8, 9, 10, 1, 7, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; Statistics().one_way_anova(sample_1=sample_2, sample_2=sample_1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">ss_between</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">n1</span> <span class="o">*</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">))))</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="o">+</span> <span class="n">n2</span> <span class="o">*</span> <span class="p">(</span><span class="n">m2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">))))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">ss_within</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">df_between</span><span class="p">,</span> <span class="n">df_within</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">ms_between</span><span class="p">,</span> <span class="n">ms_within</span> <span class="o">=</span> <span class="n">ss_between</span> <span class="o">/</span> <span class="n">df_between</span><span class="p">,</span> <span class="n">ss_within</span> <span class="o">/</span> <span class="n">df_within</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">ms_between</span> <span class="o">/</span> <span class="n">ms_within</span>
        <span class="k">if</span> <span class="n">critical_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">critical_values</span> <span class="o">=</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">df_between</span><span class="p">])]</span>
            <span class="n">critical_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">df_within</span><span class="p">,</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="n">critical_value</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">significance_bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_one_way_anova"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_one_way_anova">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], float64)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_one_way_anova</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of rolling one-way ANOVA F-statistic comparing the current time-window of</span>
<span class="sd">        size N to the preceding window of size N.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter np.ndarray[ints] time_windows: Time windows to compute ANOVAs for in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>

<span class="sd">        .. image:: _static/img/rolling_anova.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample = np.random.normal(loc=10, scale=1, size=10).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().rolling_one_way_anova(data=sample, time_windows=np.array([1.0]), fps=2)</span>
<span class="sd">        &gt;&gt;&gt; [[0.00000000e+00][0.00000000e+00][2.26221263e-06][2.26221263e-06][5.39119950e-03][5.39119950e-03][1.46725486e-03][1.46725486e-03][1.16392111e-02][1.16392111e-02]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
                <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
                <span class="n">ss_between</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">n1</span> <span class="o">*</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">))))</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="o">+</span> <span class="n">n2</span> <span class="o">*</span> <span class="p">(</span><span class="n">m2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">))))</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">ss_within</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">df_between</span><span class="p">,</span> <span class="n">df_within</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span> <span class="o">-</span> <span class="mi">2</span>
                <span class="n">ms_between</span><span class="p">,</span> <span class="n">ms_within</span> <span class="o">=</span> <span class="n">ss_between</span> <span class="o">/</span> <span class="n">df_between</span><span class="p">,</span> <span class="n">ss_within</span> <span class="o">/</span> <span class="n">df_within</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">ms_between</span> <span class="o">/</span> <span class="n">ms_within</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.kullback_leibler_divergence"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.kullback_leibler_divergence">[docs]</a>    <span class="k">def</span> <span class="nf">kullback_leibler_divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Kullback-Leibler divergence between two distributions.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Empty bins (0 observations in bin) in is replaced with passed ``fill_value``.</span>

<span class="sd">           Its range is from 0 to positive infinity. When the KL divergence is zero, it indicates that the two distributions are identical. As the KL divergence increases, it signifies an increasing difference between the distributions.</span>

<span class="sd">        .. math::</span>
<span class="sd">           \text{KL}(P || Q) = \sum{P(x) \log{\left(\frac{P(x)}{Q(x)}\right)}}</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter Optional[int] fill_value: Optional pseudo-value to use to fill empty buckets in ``sample_2`` histogram</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        :returns float: Kullback-Leibler divergence between ``sample_1`` and ``sample_2``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">kullback_leibler_divergence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">kullback_leibler_divergence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fill value&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
        <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_1_hist</span><span class="p">[</span><span class="n">sample_1_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">sample_2_hist</span><span class="p">[</span><span class="n">sample_2_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">sample_1_hist</span>
        <span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="n">sample_2_hist</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_kullback_leibler_divergence"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_kullback_leibler_divergence">[docs]</a>    <span class="k">def</span> <span class="nf">rolling_kullback_leibler_divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute rolling Kullback-Leibler divergence comparing the current time-window of</span>
<span class="sd">        size N to the preceding window of size N.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Empty bins (0 observations in bin) in is replaced with ``fill_value``.</span>

<span class="sd">        :parameter ndarray sample_1: 1d array representing feature values.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        :parameter np.ndarray[floats] time_windows: Time windows to compute JS for in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>
<span class="sd">        :returns np.ndarray: Size data.shape[0] x window_sizes.shape with Kullback-Leibler divergence. Columns represents different tiem windows.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1, sample_2 = np.random.normal(loc=10, scale=700, size=5), np.random.normal(loc=50, scale=700, size=5)</span>
<span class="sd">        &gt;&gt;&gt; data = np.hstack((sample_1, sample_2))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().rolling_kullback_leibler_divergence(data=data, time_windows=np.array([1]), fps=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">time_windows</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fps&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
                <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_1_hist</span><span class="p">[</span><span class="n">sample_1_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="n">sample_2_hist</span><span class="p">[</span><span class="n">sample_2_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">sample_1_hist</span>
                <span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
                <span class="n">kl</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="n">sample_2_hist</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kl</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.jensen_shannon_divergence"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.jensen_shannon_divergence">[docs]</a>    <span class="k">def</span> <span class="nf">jensen_shannon_divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Jensen-Shannon divergence between two distributions. Useful for (i) measure drift in datasets, and (ii) featurization of distribution shifts across</span>
<span class="sd">        sequential time-bins.</span>

<span class="sd">        .. note::</span>
<span class="sd">           JSD = 0: Indicates that the two distributions are identical.</span>
<span class="sd">           0 &lt; JSD &lt; 1: Indicates a degree of dissimilarity between the distributions, with values closer to 1 indicating greater dissimilarity.</span>
<span class="sd">           JSD = 1: Indicates that the two distributions are maximally dissimilar.</span>

<span class="sd">        .. math::</span>
<span class="sd">           JSD = \frac{{KL(P_1 || M) + KL(P_2 || M)}}{2}</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators.</span>
<span class="sd">        :returns float: Jensen-Shannon divergence between ``sample_1`` and ``sample_2``</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1, sample_2 = np.array([1, 2, 3, 4, 5, 10, 1, 2, 3]), np.array([1, 5, 10, 9, 10, 1, 10, 6, 7])</span>
<span class="sd">        &gt;&gt;&gt; Statistics().jensen_shannon_divergence(sample_1=sample_1, sample_2=sample_2, bucket_method=&#39;fd&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 0.30806541358219786</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">jensen_shannon_divergence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">jensen_shannon_divergence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
        <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">mean_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">kl_sample_1</span><span class="p">,</span> <span class="n">kl_sample_2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span>
            <span class="n">pk</span><span class="o">=</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="n">mean_hist</span>
        <span class="p">),</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">sample_2_hist</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="n">mean_hist</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">kl_sample_1</span> <span class="o">+</span> <span class="n">kl_sample_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="Statistics.rolling_jensen_shannon_divergence"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_jensen_shannon_divergence">[docs]</a>    <span class="k">def</span> <span class="nf">rolling_jensen_shannon_divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute rolling Jensen-Shannon divergence comparing the current time-window of size N to the preceding window of size N.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter np.ndarray[ints] time_windows: Time windows to compute JS for in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">time_windows</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fps&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
                <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">sample_1_hist</span>
                <span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
                <span class="n">mean_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">kl_sample_1</span><span class="p">,</span> <span class="n">kl_sample_2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span>
                    <span class="n">pk</span><span class="o">=</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="n">mean_hist</span>
                <span class="p">),</span> <span class="n">stats</span><span class="o">.</span><span class="n">entropy</span><span class="p">(</span><span class="n">pk</span><span class="o">=</span><span class="n">sample_2_hist</span><span class="p">,</span> <span class="n">qk</span><span class="o">=</span><span class="n">mean_hist</span><span class="p">)</span>
                <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">kl_sample_1</span> <span class="o">+</span> <span class="n">kl_sample_2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">js</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.wasserstein_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.wasserstein_distance">[docs]</a>    <span class="k">def</span> <span class="nf">wasserstein_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Wasserstein distance between two distributions.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Uses ``stats.wasserstein_distance``. I have tried to move ``stats.wasserstein_distance`` to jitted method extensively,</span>
<span class="sd">           but this doesn&#39;t give significant runtime improvement. Rate-limiter appears to be the _hist_1d.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        :returns float: Wasserstein distance between ``sample_1`` and ``sample_2``</span>

<span class="sd">        :example:</span>

<span class="sd">        &gt;&gt;&gt; sample_1 = np.random.normal(loc=10, scale=2, size=10)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.random.normal(loc=10, scale=3, size=10)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().wasserstein_distance(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; 0.020833333333333332</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">jensen_shannon_divergence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">jensen_shannon_divergence</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
        <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">sample_1_hist</span>
        <span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">wasserstein_distance</span><span class="p">(</span>
            <span class="n">u_values</span><span class="o">=</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">v_values</span><span class="o">=</span><span class="n">sample_2_hist</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_wasserstein_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_wasserstein_distance">[docs]</a>    <span class="k">def</span> <span class="nf">rolling_wasserstein_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute rolling Wasserstein distance comparing the current time-window of size N to the preceding window of size N.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter np.ndarray[ints] time_windows: Time windows to compute JS for in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        :returns np.ndarray: Size data.shape[0] x window_sizes.shape with Wasserstein distance. Columns represent different time windows.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().rolling_wasserstein_distance(data=data, time_windows=np.array([1, 2]), fps=30)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">time_windows</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fps&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
                <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">sample_1_hist</span>
                <span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">wasserstein_distance</span><span class="p">(</span>
                    <span class="n">u_values</span><span class="o">=</span><span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">v_values</span><span class="o">=</span><span class="n">sample_2_hist</span>
                <span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.total_variation_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.total_variation_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">total_variation_distance</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total variation distance between two probability distributions.</span>

<span class="sd">        :param np.ndarray x: A 1-D array representing the first sample.</span>
<span class="sd">        :param np.ndarray y: A 1-D array representing the second sample.</span>
<span class="sd">        :param Optional[str] bucket_method: The method used to determine the number of bins for histogram computation. Supported methods are &#39;fd&#39; (Freedman-Diaconis), &#39;doane&#39;, &#39;auto&#39;, &#39;scott&#39;, &#39;stone&#39;, &#39;rice&#39;, &#39;sturges&#39;, and &#39;sqrt&#39;. Defaults to &#39;auto&#39;.</span>
<span class="sd">        :return float: The total variation distance between the two distributions.</span>

<span class="sd">        .. math::</span>

<span class="sd">           TV(P, Q) = 0.5 \sum_i |P_i - Q_i|</span>

<span class="sd">        where :math:`P_i` and :math:`Q_i` are the probabilities assigned by the distributions :math:`P` and :math:`Q`</span>
<span class="sd">        to the same event :math:`i`, respectively.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; total_variation_distance(x=np.array([1, 5, 10, 20, 50]), y=np.array([1, 5, 10, 100, 110]))</span>
<span class="sd">        &gt;&gt;&gt; 0.3999999761581421</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">total_variation_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">total_variation_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">total_variation_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
        <span class="n">s1_h</span> <span class="o">=</span> <span class="n">Statistics</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">s2_h</span> <span class="o">=</span> <span class="n">Statistics</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s1_h</span> <span class="o">-</span> <span class="n">s2_h</span><span class="p">))</span></div>

<div class="viewcode-block" id="Statistics.population_stability_index"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.population_stability_index">[docs]</a>    <span class="k">def</span> <span class="nf">population_stability_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Population Stability Index (PSI) comparing two distributions.</span>

<span class="sd">        The Population Stability Index (PSI) is a measure of the difference in distribution</span>
<span class="sd">        patterns between two groups of data. A low PSI value indicates a minimal or negligible change in the distribution patterns between the two samples.</span>
<span class="sd">        A high PSI value suggests a significant difference in the distribution patterns between the two samples.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Empty bins (0 observations in bin) in is replaced with ``fill_value``. The PSI value ranges from 0 to positive infinity.</span>

<span class="sd">        The Population Stability Index (PSI) is calculated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">           PSI = \\sum \\left(\\frac{{p_2 - p_1}}{{ln(p_2 / p_1)}}\\right)</span>

<span class="sd">        where:</span>
<span class="sd">            - \( p_1 \) and \( p_2 \) are the proportions of observations in the bins for sample 1 and sample 2 respectively.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter Optional[int] fill_value: Empty bins (0 observations in bin) in is replaced with ``fill_value``. Default 1.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        :returns float: PSI distance between ``sample_1`` and ``sample_2``</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1, sample_2 = np.random.randint(0, 100, (100,)), np.random.randint(0, 10, (100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().population_stability_index(sample_1=sample_1, sample_2=sample_2, fill_value=1, bucket_method=&#39;auto&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 3.9657026867553817</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
        <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
            <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
            <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
        <span class="p">)</span>
        <span class="n">sample_1_hist</span><span class="p">[</span><span class="n">sample_1_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">sample_2_hist</span><span class="p">[</span><span class="n">sample_2_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_1_hist</span><span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
        <span class="n">samples_diff</span> <span class="o">=</span> <span class="n">sample_2_hist</span> <span class="o">-</span> <span class="n">sample_1_hist</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">sample_1_hist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">samples_diff</span> <span class="o">*</span> <span class="n">log</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_population_stability_index"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_population_stability_index">[docs]</a>    <span class="k">def</span> <span class="nf">rolling_population_stability_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute rolling Population Stability Index (PSI) comparing the current time-window of</span>
<span class="sd">        size N to the preceding window of size N.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Empty bins (0 observations in bin) in is replaced with ``fill_value``.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter int fill_value: Empty bins (0 observations in bin) in is replaced with ``fill_value``.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators</span>
<span class="sd">        :returns np.ndarray: PSI data of size len(data) x len(time_windows).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
                <span class="n">sample_1_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span>
                    <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                    <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
                <span class="p">)</span>
                <span class="n">sample_1_hist</span><span class="p">[</span><span class="n">sample_1_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="n">sample_2_hist</span><span class="p">[</span><span class="n">sample_2_hist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="n">sample_1_hist</span><span class="p">,</span> <span class="n">sample_2_hist</span> <span class="o">=</span> <span class="n">sample_1_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_1_hist</span><span class="p">),</span> <span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2_hist</span><span class="p">)</span>
                <span class="n">samples_diff</span> <span class="o">=</span> <span class="n">sample_2_hist</span> <span class="o">-</span> <span class="n">sample_1_hist</span>
                <span class="n">log</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sample_2_hist</span> <span class="o">/</span> <span class="n">sample_1_hist</span><span class="p">)</span>
                <span class="n">psi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">samples_diff</span> <span class="o">*</span> <span class="n">log</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">psi</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.kruskal_wallis"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.kruskal_wallis">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64[:])&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">kruskal_wallis</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Kruskal-Wallis H statistic between two distributions.</span>

<span class="sd">        The Kruskal-Wallis test is a non-parametric method for testing whether samples originate from the same distribution.</span>
<span class="sd">        It ranks all the values from the combined samples, then calculates the H statistic based on the ranks.</span>


<span class="sd">        .. math::</span>

<span class="sd">           H = \\frac{{12}}{{n(n + 1)}} \\left(\\frac{{(\\sum R_{\text{sample1}})^2}}{{n_1}} + \\frac{{(\\sum R_{\text{sample2}})^2}}{{n_2}}\\right) - 3(n + 1)</span>

<span class="sd">        where:</span>
<span class="sd">            - \( n \) is the total number of observations,</span>
<span class="sd">            - \( n_1 \) and \( n_2 \) are the number of observations in sample 1 and sample 2 respectively,</span>
<span class="sd">            - \( R_{\text{sample1}} \) and \( R_{\text{sample2}} \) are the sums of ranks for sample 1 and sample 2 respectively.</span>


<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns float: Kruskal-Wallis H statistic.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 1, 3, 4, 5]).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([6, 7, 8, 9, 10]).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().kruskal_wallis(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; 39.4</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># sample_1 = np.concatenate((np.zeros((sample_1.shape[0], 1)), sample_1.reshape(-1, 1)), axis=1)</span>
        <span class="c1"># sample_2 = np.concatenate((np.ones((sample_2.shape[0], 1)), sample_2.reshape(-1, 1)), axis=1)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">))</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">ranks</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">sample_1_summed_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">sample_2_summed_rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sample_1_summed_rank</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">sample_2_summed_rank</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">h3</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">h1</span> <span class="o">*</span> <span class="n">h2</span> <span class="o">-</span> <span class="n">h3</span></div>

<div class="viewcode-block" id="Statistics.pct_in_top_n"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.pct_in_top_n">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">pct_in_top_n</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the percentage of elements in the top &#39;n&#39; frequencies in the input array.</span>

<span class="sd">        This function calculates the percentage of elements that belong to the &#39;n&#39; most</span>
<span class="sd">        frequent categories in the input array &#39;x&#39;.</span>

<span class="sd">        :param np.ndarray x: Input array.</span>
<span class="sd">        :param float n: Number of top frequencies.</span>
<span class="sd">        :return float: Percentage of elements in the top &#39;n&#39; frequencies.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 10, (100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.pct_in_top_n(x=x, n=5)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">pct_in_top_n</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">pct_in_top_n</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cnts</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Statistics.mann_whitney"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.mann_whitney">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64[:])&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">mann_whitney</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Mann-Whitney U between two distributions.</span>

<span class="sd">        The Mann-Whitney U test is used to assess whether the distributions of two groups</span>
<span class="sd">        are the same or different based on their ranks. It is commonly used as an alternative</span>
<span class="sd">        to the t-test when the assumptions of normality and equal variances are violated.</span>

<span class="sd">        .. math::</span>
<span class="sd">           U = \\min(U_1, U_2)</span>

<span class="sd">        Where:</span>
<span class="sd">              - U is the Mann-Whitney U statistic,</span>
<span class="sd">              - U_1 is the sum of ranks for sample 1,</span>
<span class="sd">              - U_2 is the sum of ranks for sample 2.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns float: The Mann-Whitney U statistic.</span>

<span class="sd">        :references:</span>
<span class="sd">        `Modified from James Webber gist on GitHub &lt;https://gist.github.com/jamestwebber/38ab26d281f97feb8196b3d93edeeb7b&gt;`__.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 1, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([6, 7, 8, 9, 10])</span>
<span class="sd">        &gt;&gt;&gt; results = Statistics().mann_whitney(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sample_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ranked</span> <span class="o">=</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">)))</span>
        <span class="n">u1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">+</span> <span class="p">(</span><span class="n">n1</span> <span class="o">*</span> <span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ranked</span><span class="p">[:</span><span class="n">n1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">-</span> <span class="n">u1</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.levenes"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.levenes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">levenes</span><span class="p">(</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">critical_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Levene&#39;s W statistic, a test for the equality of variances between two samples.</span>

<span class="sd">        Levene&#39;s test is a statistical test used to determine whether two or more groups have equal variances. It is often</span>
<span class="sd">        used as an alternative to the Bartlett test when the assumption of normality is violated. The function computes the</span>
<span class="sd">        Levene&#39;s W statistic, which measures the degree of difference in variances between the two samples.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray critical_values: 2D array with where first column represent dfn first row dfd with values represent critical values. Can be found in ``simba.assets.critical_values_05.pickle``</span>
<span class="sd">        :returns tuple[float, Union[bool, None]]: Levene&#39;s W statistic and a boolean indicating whether the test is statistically significant (if critical values is not None).</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array(list(range(0, 50)))</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array(list(range(25, 100)))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().levenes(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; 12.63909108903254</span>
<span class="sd">        &gt;&gt;&gt; critical_values = pickle.load(open(&quot;simba/assets/lookups/critical_values_5.pickle&quot;,&quot;rb&quot;))[&#39;f&#39;][&#39;one_tail&#39;].values</span>
<span class="sd">        &gt;&gt;&gt; Statistics().levenes(sample_1=sample_1, sample_2=sample_2, critical_values=critical_values)</span>
<span class="sd">        &gt;&gt;&gt; (12.63909108903254, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Ni_x</span><span class="p">,</span> <span class="n">Ni_y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">Yci_x</span><span class="p">,</span> <span class="n">Yci_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">Ntot</span> <span class="o">=</span> <span class="n">Ni_x</span> <span class="o">+</span> <span class="n">Ni_y</span>
        <span class="n">Zij_x</span><span class="p">,</span> <span class="n">Zij_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">Yci_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">sample_2</span> <span class="o">-</span> <span class="n">Yci_y</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">Zbari_x</span><span class="p">,</span> <span class="n">Zbari_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Zij_x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Zij_y</span><span class="p">)</span>
        <span class="n">Zbar</span> <span class="o">=</span> <span class="p">((</span><span class="n">Zbari_x</span> <span class="o">*</span> <span class="n">Ni_x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Zbari_y</span> <span class="o">*</span> <span class="n">Ni_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">Ntot</span>
        <span class="n">numer</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ntot</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Ni_x</span><span class="p">,</span> <span class="n">Ni_y</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Zbari_x</span><span class="p">,</span> <span class="n">Zbari_y</span><span class="p">])</span> <span class="o">-</span> <span class="n">Zbar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">dvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Zij_x</span> <span class="o">-</span> <span class="n">Zbari_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Zij_y</span> <span class="o">-</span> <span class="n">Zbari_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dvar</span>
        <span class="n">l_statistic</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>

        <span class="k">if</span> <span class="n">critical_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dfn</span><span class="p">,</span> <span class="n">dfd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">Ni_x</span> <span class="o">+</span> <span class="n">Ni_y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">critical_values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">dfd</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">critical_values</span> <span class="o">=</span> <span class="n">critical_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">])]</span>
            <span class="n">critical_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">dfd</span><span class="p">,</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">l_statistic</span> <span class="o">&gt;=</span> <span class="n">critical_value</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">l_statistic</span><span class="p">,</span> <span class="n">significance_bool</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_levenes"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_levenes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64[:], float64)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_levenes</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of rolling Levene&#39;s W comparing the current time-window of size N to the preceding window of size N.</span>

<span class="sd">        .. note::</span>
<span class="sd">           First time bin (where has no preceding time bin) will have fill value ``0``</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns np.ndarray: Levene&#39;s W data of size len(data) x len(time_windows).</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 50, (100)).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().rolling_levenes(data=data, time_windows=np.array([1]).astype(np.float64), fps=5.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">Ni_x</span><span class="p">,</span> <span class="n">Ni_y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
                <span class="n">Yci_x</span><span class="p">,</span> <span class="n">Yci_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
                <span class="n">Ntot</span> <span class="o">=</span> <span class="n">Ni_x</span> <span class="o">+</span> <span class="n">Ni_y</span>
                <span class="n">Zij_x</span><span class="p">,</span> <span class="n">Zij_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">Yci_x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">sample_2</span> <span class="o">-</span> <span class="n">Yci_y</span>
                <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">Zbari_x</span><span class="p">,</span> <span class="n">Zbari_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Zij_x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Zij_y</span><span class="p">)</span>
                <span class="n">Zbar</span> <span class="o">=</span> <span class="p">((</span><span class="n">Zbari_x</span> <span class="o">*</span> <span class="n">Ni_x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Zbari_y</span> <span class="o">*</span> <span class="n">Ni_y</span><span class="p">))</span> <span class="o">/</span> <span class="n">Ntot</span>
                <span class="n">numer</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ntot</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Ni_x</span><span class="p">,</span> <span class="n">Ni_y</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Zbari_x</span><span class="p">,</span> <span class="n">Zbari_y</span><span class="p">])</span> <span class="o">-</span> <span class="n">Zbar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">dvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Zij_x</span> <span class="o">-</span> <span class="n">Zbari_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">Zij_y</span> <span class="o">-</span> <span class="n">Zbari_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">dvar</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">numer</span> <span class="o">/</span> <span class="n">denom</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.brunner_munzel"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.brunner_munzel">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">brunner_munzel</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Brunner-Munzel W between two distributions.</span>

<span class="sd">        The Brunner-Munzel W statistic compares the central tendency and the spread of two independent samples. It is useful</span>
<span class="sd">        for comparing the distribution of a continuous variable between two groups, especially when the assumptions of</span>
<span class="sd">        parametric tests like the t-test are violated.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `scipy.stats.brunnermunzel &lt;https://github.com/scipy/scipy/blob/7dcd8c59933524986923cde8e9126f5fc2e6b30b/scipy/stats/_stats_py.py#L9387&gt;`_</span>

<span class="sd">        .. math::</span>

<span class="sd">           W = -\\frac{{n_x \\cdot n_y \\cdot (\\bar{R}_y - \\bar{R}_x)}}{{(n_x + n_y) \\cdot \\sqrt{{n_x \\cdot S_x + n_y \\cdot S_y}}}}</span>

<span class="sd">        where:</span>
<span class="sd">            - \( n_x \) and \( n_y \) are the sizes of sample_1 and sample_2 respectively,</span>
<span class="sd">            - \( \bar{R}_x \) and \( \bar{R}_y \) are the mean ranks of sample_1 and sample_2 respectively,</span>
<span class="sd">            - \( S_x \) and \( S_y \) are the dispersion statistics of sample_1 and sample_2 respectively.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns float: Brunner-Munzel W.</span>


<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1, sample_2 = np.random.normal(loc=10, scale=2, size=10), np.random.normal(loc=20, scale=2, size=10)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().brunner_munzel(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; 0.5751408161437165</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">rankc</span> <span class="o">=</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">)))</span>
        <span class="n">rankcx</span><span class="p">,</span> <span class="n">rankcy</span> <span class="o">=</span> <span class="n">rankc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="p">],</span> <span class="n">rankc</span><span class="p">[</span><span class="n">nx</span> <span class="p">:</span> <span class="n">nx</span> <span class="o">+</span> <span class="n">ny</span><span class="p">]</span>
        <span class="n">rankcx_mean</span><span class="p">,</span> <span class="n">rankcy_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rankcx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rankcy</span><span class="p">)</span>
        <span class="n">rankx</span><span class="p">,</span> <span class="n">ranky</span> <span class="o">=</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">rankx_mean</span><span class="p">,</span> <span class="n">ranky_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rankx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ranky</span><span class="p">)</span>
        <span class="n">Sx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">rankcx</span> <span class="o">-</span> <span class="n">rankx</span> <span class="o">-</span> <span class="n">rankcx_mean</span> <span class="o">+</span> <span class="n">rankx_mean</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span> <span class="o">/</span> <span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">Sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">rankcy</span> <span class="o">-</span> <span class="n">ranky</span> <span class="o">-</span> <span class="n">rankcy_mean</span> <span class="o">+</span> <span class="n">ranky_mean</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span> <span class="o">/</span> <span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">wbfn</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">ny</span> <span class="o">*</span> <span class="p">(</span><span class="n">rankcy_mean</span> <span class="o">-</span> <span class="n">rankcx_mean</span><span class="p">)</span>
        <span class="n">wbfn</span> <span class="o">/=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">+</span> <span class="n">ny</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nx</span> <span class="o">*</span> <span class="n">Sx</span> <span class="o">+</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">Sy</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">wbfn</span></div>

    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], float64)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_barletts_test</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">n_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span>
                <span class="n">n_2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
                <span class="n">N</span> <span class="o">=</span> <span class="n">n_1</span> <span class="o">+</span> <span class="n">n_2</span>
                <span class="n">mean_variance_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">n_1</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">mean_variance_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">n_2</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">)</span>
                <span class="n">numerator</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mean_variance_1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mean_variance_2</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>

        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="Statistics.pearsons_r"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.pearsons_r">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32[:])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pearsons_r</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Pearson correlation coefficient (Pearson&#39;s r) between two numeric samples.</span>

<span class="sd">        Pearson&#39;s r is a measure of the linear correlation between two sets of data points. It quantifies the strength and</span>
<span class="sd">        direction of the linear relationship between the two variables. The coefficient varies between -1 and 1, with</span>
<span class="sd">        -1 indicating a perfect negative linear relationship, 1 indicating a perfect positive linear relationship, and 0</span>
<span class="sd">        indicating no linear relationship.</span>

<span class="sd">        Pearson&#39;s r is calculated using the formula:</span>

<span class="sd">        # .. math::</span>
<span class="sd">        #</span>
<span class="sd">        #    r = \frac{\sum{(x_i - \bar{x})(y_i - \bar{y})}}{\sqrt{\sum{(x_i - \bar{x})^2}\sum{(y_i - \bar{y})^2}}}</span>
<span class="sd">        #</span>
<span class="sd">        # where:</span>
<span class="sd">        #    - \( x_i \) and \( y_i \) are individual data points in sample_1 and sample_2, respectively.</span>
<span class="sd">        #    - \( \bar{x} \) and \( \bar{y} \) are the means of sample_1 and sample_2, respectively.</span>

<span class="sd">        :param np.ndarray sample_1: First numeric sample.</span>
<span class="sd">        :param np.ndarray sample_2: Second numeric sample.</span>
<span class="sd">        :return float: Pearson&#39;s correlation coefficient between the two samples.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([7, 2, 9, 4, 5, 6, 7, 8, 9]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().pearsons_r(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; 0.47</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">sample_2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">))</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
        <span class="k">return</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Statistics.spearman_rank_correlation"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.spearman_rank_correlation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32[:])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">spearman_rank_correlation</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Spearman&#39;s rank correlation coefficient between two samples.</span>

<span class="sd">        Spearman&#39;s rank correlation coefficient assesses how well the relationship between two variables can be described using a monotonic function.</span>
<span class="sd">        It computes the strength and direction of the monotonic relationship between ranked variables.</span>

<span class="sd">        # .. math::</span>
<span class="sd">        #    ρ = 1 - \\frac{{6 ∑(d_i^2)}}{{n(n^2 - 1)}}</span>
<span class="sd">        #</span>
<span class="sd">        # where:</span>
<span class="sd">        # - \( d_i \) is the difference between the ranks of corresponding elements in sample_1 and sample_2.</span>
<span class="sd">        # - \( n \) is the number of observations.</span>

<span class="sd">        :param np.ndarray sample_1: First 1D array containing feature values.</span>
<span class="sd">        :param np.ndarray sample_2: Second 1D array containing feature values.</span>
<span class="sd">        :return float: Spearman&#39;s rank correlation coefficient.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([7, 2, 9, 4, 5, 6, 7, 8, 9]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().spearman_rank_correlation(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; 0.0003979206085205078</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rank_x</span><span class="p">,</span> <span class="n">rank_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">d_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">rank_x</span> <span class="o">-</span> <span class="n">rank_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">d_squared</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Statistics.sliding_pearsons_r"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_pearsons_r">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32[:], float64[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_pearsons_r</span><span class="p">(</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two 1D arrays of size N, create sliding window of size time_windows[i] * fps and return Pearson&#39;s R</span>
<span class="sd">        between the values in the two 1D arrays in each window. Address &quot;what is the correlation between Feature 1 and</span>
<span class="sd">        Feature 2 in the current X.X seconds of the video&quot;.</span>

<span class="sd">        .. image:: _static/img/sliding_pearsons.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :parameter ndarray sample_1: First 1D array with feature values.</span>
<span class="sd">        :parameter ndarray sample_1: Second 1D array with feature values.</span>
<span class="sd">        :parameter float time_windows: The length of the sliding window in seconds.</span>
<span class="sd">        :parameter int fps: The fps of the recorded video.</span>
<span class="sd">        :returns np.ndarray: 2d array of Pearsons R of size len(sample_1) x len(time_windows). Note, if sliding window is 10 frames, the first 9 entries will be filled with 0.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.random.randint(0, 50, (10)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.random.randint(0, 50, (10)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().sliding_pearsons_r(sample_1=sample_1, sample_2=sample_2, time_windows=np.array([0.5]), fps=10)</span>
<span class="sd">        &gt;&gt;&gt; [[-1.][-1.][-1.][-1.][0.227][-0.319][-0.196][0.474][-0.061][0.713]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sample_1</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">],</span> <span class="n">sample_2</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
                <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
                <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">s1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">s2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">))</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">s1</span> <span class="o">-</span> <span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">s2</span> <span class="o">-</span> <span class="n">m2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">denominator</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.chi_square"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.chi_square">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;(float32[:], float32[:], float64[:,:], types.unicode_type)&quot;</span><span class="p">,</span>
            <span class="s1">&#39;(float32[:], float32[:], float64[:,:], types.misc.Omitted(&quot;goodness_of_fit&quot;))&#39;</span><span class="p">,</span>
            <span class="s2">&quot;(float32[:], float32[:], types.misc.Omitted(None), types.unicode_type)&quot;</span><span class="p">,</span>
            <span class="s1">&#39;(float32[:], float32[:], types.misc.Omitted(None), types.misc.Omitted(&quot;goodness_of_fit&quot;))&#39;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">chi_square</span><span class="p">(</span>
        <span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">critical_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;goodness_of_fit&quot;</span><span class="p">,</span> <span class="s2">&quot;independence&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;goodness_of_fit&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of chi square between two categorical distributions.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray critical_values: 2D array with where indexes represent degrees of freedom and values</span>
<span class="sd">                                            represent critical values. Can be found in ``simba.assets.critical_values_05.pickle``</span>

<span class="sd">        .. note::</span>
<span class="sd">           Requires sample_1 and sample_2 has to be numeric. if working with strings, convert to</span>
<span class="sd">           numeric category values before using chi_square.</span>

<span class="sd">        .. warning:</span>
<span class="sd">           Non-overlapping values (i.e., categories exist in sample_1 that does not exist in sample2) or small values may cause inflated chi square values.</span>
<span class="sd">           If small contingency table small values, consider TODO Fisher&#39;s exact test</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; critical_values = pickle.load(open(&quot;simba/assets/lookups/critical_values_5.pickle&quot;, &quot;rb&quot;))[&#39;chi_square&#39;][&#39;one_tail&#39;].values</span>
<span class="sd">        &gt;&gt;&gt; Statistics.chi_square(sample_1=sample_2, sample_2=sample_1, critical_values=critical_values, type=&#39;goodness_of_fit&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (8.333, False)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">chi_square</span><span class="p">,</span> <span class="n">significance_bool</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">unique_categories</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">)))</span>
        <span class="n">sample_1_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_categories</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">sample_2_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_categories</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_categories</span><span class="p">)):</span>
            <span class="n">sample_1_counts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sample_2_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">sample_1</span> <span class="o">==</span> <span class="n">unique_categories</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2</span> <span class="o">==</span> <span class="n">unique_categories</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_categories</span><span class="p">)):</span>
            <span class="n">count_1</span><span class="p">,</span> <span class="n">count_2</span> <span class="o">=</span> <span class="n">sample_1_counts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sample_2_counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">count_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">chi_square</span> <span class="o">+=</span> <span class="p">((</span><span class="n">count_1</span> <span class="o">-</span> <span class="n">count_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">count_2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chi_square</span> <span class="o">+=</span> <span class="p">((</span><span class="n">count_1</span> <span class="o">-</span> <span class="n">count_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">count_2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">critical_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s2">&quot;goodness_of_fit&quot;</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">unique_categories</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_1_counts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_2_counts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">critical_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">critical_values</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">chi_square</span> <span class="o">&gt;=</span> <span class="n">critical_value</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">significance_bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">chi_square</span><span class="p">,</span> <span class="n">significance_bool</span></div>

<div class="viewcode-block" id="Statistics.sliding_independent_samples_t"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_independent_samples_t">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32, float32, float32[:,:], float32)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_independent_samples_t</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time_window</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">slide_time</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">critical_values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of sliding independent sample t-test. Compares the feature values in current time-window</span>
<span class="sd">        to prior time-windows to find the length in time to the most recent time-window where a significantly different</span>
<span class="sd">        feature value distribution is detected.</span>

<span class="sd">        .. image:: _static/img/sliding_statistics.png</span>
<span class="sd">           :width: 1500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :parameter ndarray data: 1D array with feature values.</span>
<span class="sd">        :parameter float time_window: The sizes of the two feature value windows being compared in seconds.</span>
<span class="sd">        :parameter float slide_time: The slide size of the second window.</span>
<span class="sd">        :parameter ndarray critical_values: 2D array with where indexes represent degrees of freedom and values</span>
<span class="sd">                                            represent critical T values. Can be found in ``simba.assets.critical_values_05.pickle``.</span>
<span class="sd">        :parameter int fps: The fps of the recorded video.</span>
<span class="sd">        :returns np.ndarray: 1D array of size len(data) with values representing time to most recent significantly different feature distribution.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 50, (10)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; critical_values = pickle.load(open(&quot;simba/assets/lookups/critical_values_05.pickle&quot;, &quot;rb&quot;))[&#39;independent_t_test&#39;][&#39;one_tail&#39;].values.astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; results = Statistics().sliding_independent_samples_t(data=data, time_window=0.5, fps=5.0, critical_values=critical_values, slide_time=0.30)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">window_size</span><span class="p">,</span> <span class="n">slide_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_window</span> <span class="o">*</span> <span class="n">fps</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">slide_time</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">sample_1_left</span><span class="p">,</span> <span class="n">sample_1_right</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span>
            <span class="n">sample_2_left</span><span class="p">,</span> <span class="n">sample_2_right</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sample_1_left</span> <span class="o">-</span> <span class="n">slide_size</span><span class="p">,</span>
                <span class="n">sample_1_right</span> <span class="o">-</span> <span class="n">slide_size</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">sample_1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">sample_1_left</span><span class="p">:</span><span class="n">sample_1_right</span><span class="p">]</span>
            <span class="n">dof</span><span class="p">,</span> <span class="n">steps_taken</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">sample_2_left</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">sample_2_left</span><span class="p">:</span><span class="n">sample_2_right</span><span class="p">]</span>
                <span class="n">t_statistic</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_2</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">critical_val</span> <span class="o">=</span> <span class="n">critical_values</span><span class="p">[</span><span class="n">dof</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">t_statistic</span> <span class="o">&gt;=</span> <span class="n">critical_val</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sample_2_left</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">sample_2_right</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="n">steps_taken</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">sample_2_left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">steps_taken</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">steps_taken</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">steps_taken</span> <span class="o">*</span> <span class="n">slide_time</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.rolling_mann_whitney"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_mann_whitney">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], float32)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">rolling_mann_whitney</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of rolling Mann-Whitney U comparing the current time-window of</span>
<span class="sd">        size N to the preceding window of size N.</span>

<span class="sd">        .. note::</span>
<span class="sd">           First time bin (where has no preceding time bin) will have fill value ``0``</span>

<span class="sd">           `Modified from James Webber gist &lt;https://gist.github.com/jamestwebber/38ab26d281f97feb8196b3d93edeeb7b&gt;`__.</span>

<span class="sd">        :parameter ndarray sample_1: First 1d array representing feature values.</span>
<span class="sd">        :parameter ndarray sample_2: Second 1d array representing feature values.</span>
<span class="sd">        :returns np.ndarray: Mann-Whitney U data of size len(data) x len(time_windows).</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 4, (200)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; results = Statistics().rolling_mann_whitney(data=data, time_windows=np.array([1.0]), fps=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
                <span class="n">window_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_size</span> <span class="o">*</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">window_end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_start</span> <span class="o">+</span> <span class="n">window_size</span><span class="p">)</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">data_split</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">data_split</span><span class="p">[</span>
                    <span class="n">j</span>
                <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sample_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ranked</span> <span class="o">=</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">)))</span>
                <span class="n">u1</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">+</span> <span class="p">(</span><span class="n">n1</span> <span class="o">*</span> <span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ranked</span><span class="p">[:</span><span class="n">n1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">u2</span> <span class="o">=</span> <span class="n">n1</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">-</span> <span class="n">u1</span>
                <span class="n">u</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">window_start</span><span class="p">:</span><span class="n">window_end</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>

        <span class="k">return</span> <span class="n">results</span></div>

    <span class="k">def</span> <span class="nf">chow_test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="Statistics.concordance_ratio"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.concordance_ratio">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(int64[:, :]), bool_&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">concordance_ratio</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">invert</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the concordance ratio of a 2D numpy array.</span>

<span class="sd">        :param np.ndarray x: A 2D numpy array with ordinals represented as integers.</span>
<span class="sd">        :param bool invert: If True, the concordance ratio is inverted, and disconcordance ratio is returned</span>
<span class="sd">        :return float: The concordance ratio, representing the count of rows with only one unique value divided by the total number of rows in the array.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 2, (5000, 4))</span>
<span class="sd">        &gt;&gt;&gt; results = Statistics.concordance_ratio(x=x, invert=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conc_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">unique_cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unique_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">conc_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
            <span class="n">conc_count</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">conc_count</span>
        <span class="k">return</span> <span class="n">conc_count</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Statistics.sliding_spearman_rank_correlation"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_spearman_rank_correlation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32[:], float64[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_spearman_rank_correlation</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given two 1D arrays of size N, create sliding window of size time_windows[i] * fps and return Spearman&#39;s rank correlation</span>
<span class="sd">        between the values in the two 1D arrays in each window. Address &quot;what is the correlation between Feature 1 and</span>
<span class="sd">        Feature 2 in the current X.X seconds of the video.</span>

<span class="sd">        .. image:: _static/img/sliding_spearman.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :parameter ndarray sample_1: First 1D array with feature values.</span>
<span class="sd">        :parameter ndarray sample_1: Second 1D array with feature values.</span>
<span class="sd">        :parameter float time_windows: The length of the sliding window in seconds.</span>
<span class="sd">        :parameter int fps: The fps of the recorded video.</span>
<span class="sd">        :returns np.ndarray: 2d array of Soearman&#39;s ranks of size len(sample_1) x len(time_windows). Note, if sliding window is 10 frames, the first 9 entries will be filled with 0. The 10th value represents the correlation in the first 10 frames.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([9,10,13,22,15,18,15,19,32,11]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([11, 12, 15, 19, 21, 26, 19, 20, 22, 19]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().sliding_spearman_rank_correlation(sample_1=sample_1, sample_2=sample_2, time_windows=np.array([0.5]), fps=10)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">sample_1</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">],</span> <span class="n">sample_2</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
                <span class="n">rank_x</span><span class="p">,</span> <span class="n">rank_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">s1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span>
                <span class="n">d_squared</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">rank_x</span> <span class="o">-</span> <span class="n">rank_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">d_squared</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">results</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.sliding_autocorrelation"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_autocorrelation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64, float64, float64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_autocorrelation</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">time_window</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted computation of sliding autocorrelations, which measures the correlation of a feature with itself using lagged windows.</span>

<span class="sd">        :param np.ndarray data: 1D array containing feature values.</span>
<span class="sd">        :param float max_lag: Maximum lag in seconds for the autocorrelation window.</span>
<span class="sd">        :param float time_window: Length of the sliding time window in seconds.</span>
<span class="sd">        :param float fps: Frames per second, used to convert time-related parameters into frames.</span>
<span class="sd">        :return np.ndarray: 1D array containing the sliding autocorrelation values.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([0,1,2,3,4, 5,6,7,8,1,10,11,12,13,14]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().sliding_autocorrelation(data=data, max_lag=0.5, time_window=1.0, fps=10)</span>
<span class="sd">        &gt;&gt;&gt; [ 0., 0., 0.,  0.,  0., 0., 0.,  0. ,  0., -3.686, -2.029, -1.323, -1.753, -3.807, -4.634]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">max_frm_lag</span><span class="p">,</span> <span class="n">time_window_frms</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_lag</span> <span class="o">*</span> <span class="n">fps</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_window</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_window_frms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">time_window_frms</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">w_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span> <span class="p">:</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">corrcfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">max_frm_lag</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">corrcfs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_frm_lag</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">w_data</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">],</span> <span class="n">w_data</span><span class="p">[</span><span class="n">shift</span><span class="p">:])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                    <span class="n">corrcfs</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corrcfs</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">w_data</span><span class="p">[:</span><span class="o">-</span><span class="n">shift</span><span class="p">],</span> <span class="n">w_data</span><span class="p">[</span><span class="n">shift</span><span class="p">:])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">mat_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">corrcfs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">corrcfs</span><span class="p">)</span>
            <span class="n">mat_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">const</span>
            <span class="n">mat_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">corrcfs</span>
            <span class="n">det_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span>
                <span class="n">mat_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_frm_lag</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">det_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.sliding_dominant_frequencies"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_dominant_frequencies">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sliding_dominant_frequencies</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                     <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                     <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                     <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                     <span class="n">window_function</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;Hann&quot;</span><span class="p">,</span> <span class="s2">&quot;Hamming&quot;</span><span class="p">,</span> <span class="s2">&quot;Blackman&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the K dominant frequencies within a feature vector using sliding windows&quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">time_window_cnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">time_window_cnt</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">window_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">window_function</span> <span class="o">==</span> <span class="s2">&quot;Hann&quot;</span><span class="p">:</span>
                    <span class="n">window_data</span> <span class="o">=</span> <span class="n">window_data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">window_function</span> <span class="o">==</span> <span class="s2">&quot;Hamming&quot;</span><span class="p">:</span>
                    <span class="n">window_data</span> <span class="o">=</span> <span class="n">window_data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">window_function</span> <span class="o">==</span> <span class="s2">&quot;Blackman&quot;</span><span class="p">:</span>
                    <span class="n">window_data</span> <span class="o">=</span> <span class="n">window_data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window_data</span><span class="p">))</span>
                <span class="n">fft_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">window_data</span><span class="p">)</span>
                <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">window_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fps</span><span class="p">)</span>
                <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fft_result</span><span class="p">)</span>
                <span class="n">top_k_frequency</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)[</span><span class="o">-</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">time_window_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">top_k_frequency</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.kendall_tau"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.kendall_tau">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32[:])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">kendall_tau</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Kendall Tau (rank correlation coefficient). Non-parametric method for computing correlation</span>
<span class="sd">        between two time-series features. Returns tau and associated z-score.</span>

<span class="sd">        Kendall Tau is a measure of the correspondence between two rankings. It compares the number of concordant</span>
<span class="sd">        pairs (pairs of elements that are in the same order in both rankings) to the number of discordant pairs</span>
<span class="sd">        (pairs of elements that are in different orders in the rankings).</span>

<span class="sd">        Kendall Tau is calculated using the following formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\tau = \\frac{{\\sum C - \\sum D}}{{\\sum C + \\sum D}}</span>

<span class="sd">        where :math:`C` is the count of concordant pairs and :math:`D` is the count of discordant pairs.</span>


<span class="sd">        :parameter ndarray sample_1: First 1D array with feature values.</span>
<span class="sd">        :parameter ndarray sample_1: Second 1D array with feature values.</span>
<span class="sd">        :returns Tuple[float, float]: Kendall Tau and associated z-score.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([4, 2, 3, 4, 5, 7]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([1, 2, 3, 4, 5, 7]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().kendall_tau(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; (0.7333333333333333, 2.0665401605809928)</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] `Stephanie Glen, &quot;Kendall’s Tau (Kendall Rank Correlation Coefficient)&quot;  &lt;https://www.statisticshowto.com/kendalls-tau/&gt;`__.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">rnks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span>
        <span class="n">s1_rnk</span><span class="p">,</span> <span class="n">s2_rnk</span> <span class="o">=</span> <span class="n">sample_1</span><span class="p">[</span><span class="n">rnks</span><span class="p">],</span> <span class="n">sample_2</span><span class="p">[</span><span class="n">rnks</span><span class="p">]</span>
        <span class="n">cncrdnt_cnts</span><span class="p">,</span> <span class="n">dscrdnt_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="p">(</span><span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">cncrdnt_cnts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">s2_rnk</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">s1_rnk</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">dscrdnt_cnts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">s2_rnk</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">s1_rnk</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cncrdnt_cnts</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dscrdnt_cnts</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cncrdnt_cnts</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dscrdnt_cnts</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">z</span></div>

<div class="viewcode-block" id="Statistics.sliding_kendall_tau"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_kendall_tau">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float32[:], float64[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_kendall_tau</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute sliding Kendall&#39;s Tau correlation coefficient.</span>

<span class="sd">        Calculates Kendall&#39;s Tau correlation coefficient between two samples over sliding time windows. Kendall&#39;s Tau is a measure of correlation between two ranked datasets.</span>

<span class="sd">        The computation is based on the formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\tau = \\frac{{\\text{{concordant pairs}} - \\text{{discordant pairs}}}}{{\\text{{concordant pairs}} + \\text{{discordant pairs}}}}</span>

<span class="sd">        where concordant pairs are pairs of elements with the same order in both samples, and discordant pairs are pairs with different orders.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] `Stephanie Glen, &quot;Kendall’s Tau (Kendall Rank Correlation Coefficient)&quot;  &lt;https://www.statisticshowto.com/kendalls-tau/&gt;`__.</span>


<span class="sd">        :param np.ndarray sample_1: First sample for comparison.</span>
<span class="sd">        :param np.ndarray sample_2: Second sample for comparison.</span>
<span class="sd">        :param np.ndarray time_windows: Rolling time windows in seconds.</span>
<span class="sd">        :param float fps: Frames per second (FPS) of the recorded video.</span>
<span class="sd">        :return: Array of Kendall&#39;s Tau correlation coefficients corresponding to each time window.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">time_window_cnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">time_window_cnt</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">sliced_sample_1</span><span class="p">,</span> <span class="n">sliced_sample_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_1</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">],</span> <span class="n">sample_2</span><span class="p">[</span><span class="n">left</span><span class="p">:</span><span class="n">right</span><span class="p">])</span>
                <span class="n">rnks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sliced_sample_1</span><span class="p">)</span>
                <span class="n">s1_rnk</span><span class="p">,</span> <span class="n">s2_rnk</span> <span class="o">=</span> <span class="n">sliced_sample_1</span><span class="p">[</span><span class="n">rnks</span><span class="p">],</span> <span class="n">sliced_sample_2</span><span class="p">[</span><span class="n">rnks</span><span class="p">]</span>
                <span class="n">cncrdnt_cnts</span><span class="p">,</span> <span class="n">dscrdnt_cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">s1_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2_rnk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">cncrdnt_cnts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">s2_rnk</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">s1_rnk</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">dscrdnt_cnts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">s2_rnk</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">s1_rnk</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cncrdnt_cnts</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dscrdnt_cnts</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cncrdnt_cnts</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dscrdnt_cnts</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="n">time_window_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">right</span><span class="p">][</span><span class="n">time_window_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.find_collinear_features"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.find_collinear_features">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">find_collinear_features</span><span class="p">(</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pearson&quot;</span><span class="p">,</span> <span class="s2">&quot;spearman&quot;</span><span class="p">,</span> <span class="s2">&quot;kendall&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify collinear features in the dataframe based on the specified correlation method and threshold.</span>

<span class="sd">        :param pd.DataFrame df: Input DataFrame containing features.</span>
<span class="sd">        :param float threshold: Threshold value to determine collinearity.</span>
<span class="sd">        :param Optional[Literal[&#39;pearson&#39;, &#39;spearman&#39;, &#39;kendall&#39;]] method: Method for calculating correlation. Defaults to &#39;pearson&#39;.</span>
<span class="sd">        :return: Set of feature names identified as collinear. Returns one feature for every feature pair with correlation value above specified threshold.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = pd.DataFrame(np.random.randint(0, 100, (100, 100)))</span>
<span class="sd">        &gt;&gt;&gt; names = Statistics.find_collinear_features(df=x, threshold=0.2, method=&#39;pearson&#39;, verbose=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_dataframe</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">find_collinear_features</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">valid_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_axis_0</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">find_collinear_features</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">find_collinear_features</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;pearson&quot;</span><span class="p">,</span> <span class="s2">&quot;spearman&quot;</span><span class="p">,</span> <span class="s2">&quot;kendall&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">feature_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">feature_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feature_pairs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Analyzing feature pair collinearity </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_pairs</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_names</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">feature_names</span><span class="p">):</span>
                <span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">df</span><span class="p">[</span>
                    <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Statistics</span><span class="o">.</span><span class="n">pearsons_r</span><span class="p">(</span><span class="n">sample_1</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="o">=</span><span class="n">sample_2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;spearman&quot;</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Statistics</span><span class="o">.</span><span class="n">spearman_rank_correlation</span><span class="p">(</span>
                        <span class="n">sample_1</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="o">=</span><span class="n">sample_2</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">Statistics</span><span class="o">.</span><span class="n">kendall_tau</span><span class="p">(</span><span class="n">sample_1</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">sample_2</span><span class="o">=</span><span class="n">sample_2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">feature_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Collinear analysis complete.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">feature_names</span></div>

<div class="viewcode-block" id="Statistics.local_outlier_factor"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.local_outlier_factor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">local_outlier_factor</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">contamination</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-10</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">groupby_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the local outlier factor of each observation.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The final LOF scores are negated. Thus, higher values indicate more atypical (outlier) data points. Values</span>
<span class="sd">           Method calls ``sklearn.neighbors.LocalOutlierFactor`` directly. Attempted to use own jit compiled implementation,</span>
<span class="sd">           but runtime was 3x-ish slower than ``sklearn.neighbors.LocalOutlierFactor``.</span>

<span class="sd">           If groupby_idx is not None, then the index 1 of ``data`` array for which to group the data and compute LOF within each segment/cluster.</span>
<span class="sd">           E.g., can be field holding cluster identifier. Thus, outliers are computed within each segment/cluster, ensuring that other segments cannot affect</span>
<span class="sd">           outlier scores within each analyzing each cluster.</span>

<span class="sd">           If groupby_idx is provided, then all observations with cluster/segment variable ``-1`` will be treated as unclustered and assigned the max outlier score found withiin the clustered observations.</span>

<span class="sd">        .. image:: _static/img/local_outlier_factor.png</span>
<span class="sd">           :width: 800</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param ndarray data: 2D array with feature values where rows represent frames and columns represent features.</span>
<span class="sd">        :param Union[int, float] k: Number of neighbors to evaluate for each observation. If the value is a float, then interpreted as the ratio of data.shape[0]. If the value is an integer, then it represent the number of neighbours to evaluate.</span>
<span class="sd">        :param Optional[float] contamination: Small pseudonumber to avoid DivisionByZero error.</span>
<span class="sd">        :param Optional[bool] normalize: Whether to normalize the distances between 0 and 1. Defaults to False.</span>
<span class="sd">        :param Optional[int] groupby_idx: If int, then the index 1 of ``data`` for which to group the data and compute LOF on each segment. E.g., can be field holding a cluster identifier.</span>
<span class="sd">        :returns np.ndarray: Array of size data.shape[0] with local outlier scores.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data, lbls = make_blobs(n_samples=2000, n_features=2, centers=10, random_state=42)</span>
<span class="sd">        &gt;&gt;&gt; data = np.hstack((data, lbls.reshape(-1, 1)))</span>
<span class="sd">        &gt;&gt;&gt; lof = Statistics.local_outlier_factor(data=data, groupby_idx=2, k=100, normalize=True)</span>
<span class="sd">        &gt;&gt;&gt; results = np.hstack((data[:, 0:2], lof.reshape(lof.shape[0], 1)))</span>
<span class="sd">        &gt;&gt;&gt; PlottingMixin.continuous_scatter(data=results, palette=&#39;seismic&#39;, bg_clr=&#39;lightgrey&#39;,size=30)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_lof</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">contamination</span><span class="p">):</span>
            <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">local_outlier_factor</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> k&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">lof_model</span> <span class="o">=</span> <span class="n">LocalOutlierFactor</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">contamination</span><span class="o">=</span><span class="n">contamination</span><span class="p">)</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">lof_model</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">lof_model</span><span class="o">.</span><span class="n">negative_outlier_factor_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span>

        <span class="k">if</span> <span class="n">groupby_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_int</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">local_outlier_factor</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> groupby_idx&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">groupby_idx</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">max_value</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_valid_array</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">local_outlier_factor</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> local_outlier_factor&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_valid_array</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">local_outlier_factor</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">local_outlier_factor</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> contamination&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">contamination</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">groupby_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_lof</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">contamination</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">data_w_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">data</span><span class="p">))</span>
            <span class="n">unique_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">groupby_idx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">-</span><span class="mf">1.0</span> <span class="ow">in</span> <span class="n">unique_c</span><span class="p">:</span>
                <span class="n">unique_c</span> <span class="o">=</span> <span class="n">unique_c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">unique_c</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">unclustered_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">groupby_idx</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="n">data_w_idx</span><span class="p">[</span><span class="n">unclustered_idx</span><span class="p">]</span>
                <span class="n">data_w_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_w_idx</span><span class="p">,</span> <span class="n">unclustered_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_c</span><span class="p">:</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="n">data_w_idx</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data_w_idx</span><span class="p">[:,</span> <span class="n">groupby_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_w_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">s_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">s_data</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">groupby_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">lof</span> <span class="o">=</span> <span class="n">get_lof</span><span class="p">(</span><span class="n">s_data</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">contamination</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">lof</span><span class="p">)))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unclustered</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_lof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">unclustered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">unclustered</span><span class="p">,</span> <span class="n">max_lof</span><span class="p">))[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">unclustered</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Statistics.elliptic_envelope"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.elliptic_envelope">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">elliptic_envelope</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">contamination</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-1</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">groupby_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Mahalanobis distances of each observation in the input array using Elliptic Envelope method.</span>

<span class="sd">        .. image:: _static/img/EllipticEnvelope.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/elliptic_envelope.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param data: Input data array of shape (n_samples, n_features).</span>
<span class="sd">        :param Optional[float] contamination: The proportion of outliers to be assumed in the data. Defaults to 0.1.</span>
<span class="sd">        :param Optional[bool] normalize: Whether to normalize the Mahalanobis distances between 0 and 1. Defaults to True.</span>
<span class="sd">        :return np.ndarray: The Mahalanobis distances of each observation in array. Larger values indicate outliers.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data, lbls = make_blobs(n_samples=2000, n_features=2, centers=1, random_state=42)</span>
<span class="sd">        &gt;&gt;&gt; envelope_score = elliptic_envelope(data=data, normalize=True)</span>
<span class="sd">        &gt;&gt;&gt; results = np.hstack((data[:, 0:2], envelope_score.reshape(lof.shape[0], 1)))</span>
<span class="sd">        &gt;&gt;&gt; results = pd.DataFrame(results, columns=[&#39;X&#39;, &#39;Y&#39;, &#39;ENVELOPE SCORE&#39;])</span>
<span class="sd">        &gt;&gt;&gt; PlottingMixin.continuous_scatter(data=results, palette=&#39;seismic&#39;, bg_clr=&#39;lightgrey&#39;, columns=[&#39;X&#39;, &#39;Y&#39;, &#39;ENVELOPE SCORE&#39;],size=30)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_envelope</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">contamination</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">mdl</span> <span class="o">=</span> <span class="n">EllipticEnvelope</span><span class="p">(</span><span class="n">contamination</span><span class="o">=</span><span class="n">contamination</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">mdl</span><span class="o">.</span><span class="n">score_samples</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">y</span>

        <span class="k">if</span> <span class="n">groupby_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_int</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">elliptic_envelope</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> groupby_idx&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">groupby_idx</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">max_value</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_valid_array</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">elliptic_envelope</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> local_outlier_factor&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_valid_array</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">elliptic_envelope</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">elliptic_envelope</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> contamination&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">contamination</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">groupby_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_envelope</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">contamination</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">data_w_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">data</span><span class="p">))</span>
            <span class="n">unique_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">groupby_idx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">-</span><span class="mf">1.0</span> <span class="ow">in</span> <span class="n">unique_c</span><span class="p">:</span>
                <span class="n">unique_c</span> <span class="o">=</span> <span class="n">unique_c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">unique_c</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">unclustered_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">groupby_idx</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="n">data_w_idx</span><span class="p">[</span><span class="n">unclustered_idx</span><span class="p">]</span>
                <span class="n">data_w_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_w_idx</span><span class="p">,</span> <span class="n">unclustered_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_c</span><span class="p">:</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="n">data_w_idx</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data_w_idx</span><span class="p">[:,</span> <span class="n">groupby_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_w_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">s_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">s_data</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">groupby_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">lof</span> <span class="o">=</span> <span class="n">get_envelope</span><span class="p">(</span><span class="n">s_data</span><span class="p">,</span> <span class="n">contamination</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">lof</span><span class="p">)))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unclustered</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_env_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">unclustered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">unclustered</span><span class="p">,</span> <span class="n">max_env_score</span><span class="p">))[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">unclustered</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Statistics.isolation_forest"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.isolation_forest">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">isolation_forest</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">estimators</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">groupby_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An implementation of the Isolation Forest algorithm for outlier detection.</span>

<span class="sd">        .. image:: _static/img/isolation_forest.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. note::</span>
<span class="sd">           The isolation forest scores are negated. Thus, higher values indicate more atypical (outlier) data points.</span>

<span class="sd">        :param np.ndarray x: 2-D array with feature values.</span>
<span class="sd">        :param Union[int, float] estimators: Number of splits. If the value is a float, then interpreted as the ratio of x shape.</span>
<span class="sd">        :param Optional[int] groupby_idx: If int, then the index 1 of ``data`` for which to group the data and compute LOF on each segment. E.g., can be field holding a cluster identifier.</span>
<span class="sd">        :param Optional[bool] normalize: Whether to normalize the outlier score between 0 and 1. Defaults to False.</span>
<span class="sd">        :return:</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x, lbls = make_blobs(n_samples=10000, n_features=2, centers=10, random_state=42)</span>
<span class="sd">        &gt;&gt;&gt; x = np.hstack((x, lbls.reshape(-1, 1)))</span>
<span class="sd">        &gt;&gt;&gt; scores = isolation_forest(x=x, estimators=10, normalize=True)</span>
<span class="sd">        &gt;&gt;&gt; results = np.hstack((x[:, 0:2], scores.reshape(scores.shape[0], 1)))</span>
<span class="sd">        &gt;&gt;&gt; results = pd.DataFrame(results, columns=[&#39;X&#39;, &#39;Y&#39;, &#39;ISOLATION SCORE&#39;])</span>
<span class="sd">        &gt;&gt;&gt; PlottingMixin.continuous_scatter(data=results, palette=&#39;seismic&#39;, bg_clr=&#39;lightgrey&#39;, columns=[&#39;X&#39;, &#39;Y&#39;, &#39;ISOLATION SCORE&#39;],size=30)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">get_if_scores</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">estimators</span><span class="p">:</span> <span class="n">estimators</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">estimators</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">check_float</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">isolation_forest</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> estimators&quot;</span><span class="p">,</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">estimators</span><span class="p">,</span>
                    <span class="n">min_value</span><span class="o">=</span><span class="mf">10e-6</span><span class="p">,</span>
                    <span class="n">max_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">estimators</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">estimators</span>
                <span class="k">if</span> <span class="n">estimators</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">estimators</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">check_int</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">isolation_forest</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> estimators&quot;</span><span class="p">,</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">estimators</span><span class="p">,</span>
                    <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">mdl</span> <span class="o">=</span> <span class="n">IsolationForest</span><span class="p">(</span>
                <span class="n">n_estimators</span><span class="o">=</span><span class="n">estimators</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">behaviour</span><span class="o">=</span><span class="s2">&quot;new&quot;</span><span class="p">,</span>
                <span class="n">contamination</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mdl</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">score_samples</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">if</span> <span class="n">groupby_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">isolation_forest</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_if_scores</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">estimators</span><span class="o">=</span><span class="n">estimators</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">isolation_forest</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">min_axis_1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">data_w_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">))</span>
            <span class="n">unique_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">groupby_idx</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">-</span><span class="mf">1.0</span> <span class="ow">in</span> <span class="n">unique_c</span><span class="p">:</span>
                <span class="n">unique_c</span> <span class="o">=</span> <span class="n">unique_c</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">unique_c</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">unclustered_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">groupby_idx</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="n">data_w_idx</span><span class="p">[</span><span class="n">unclustered_idx</span><span class="p">]</span>
                <span class="n">data_w_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data_w_idx</span><span class="p">,</span> <span class="n">unclustered_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_c</span><span class="p">:</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="n">data_w_idx</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data_w_idx</span><span class="p">[:,</span> <span class="n">groupby_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
                <span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_w_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">s_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">s_data</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">groupby_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">i_f</span> <span class="o">=</span> <span class="n">get_if_scores</span><span class="p">(</span><span class="n">s_data</span><span class="p">,</span> <span class="n">estimators</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">s_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">i_f</span><span class="p">)))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unclustered</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_if</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">unclustered</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">unclustered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">unclustered</span><span class="p">,</span> <span class="n">max_if</span><span class="p">))[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">unclustered</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_hbos_compute</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">histograms</span><span class="p">:</span> <span class="n">typed</span><span class="o">.</span><span class="n">Dict</span><span class="p">,</span> <span class="n">histogram_edges</span><span class="p">:</span> <span class="n">typed</span><span class="o">.</span><span class="n">Dict</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted helper to compute Histogram-based Outlier Score (HBOS) called by ``simba.mixins.statistics_mixin.Statistics.hbos``.</span>

<span class="sd">        :parameter np.ndarray data: 2d array with frames represented by rows and columns representing feature values.</span>
<span class="sd">        :parameter typed.Dict histograms: Numba typed.Dict with integer keys (representing order of feature) and 1d arrays as values representing observation bin counts.</span>
<span class="sd">        :parameter: typed.Dict histogram_edges: Numba typed.Dict with integer keys (representing order of feature) and 1d arrays as values representing bin edges.</span>
<span class="sd">        :return np.ndarray: Array of size data.shape[0] representing outlier scores, with higher values representing greater outliers.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">histogram_edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">bin_max</span><span class="p">,</span> <span class="n">bin_min</span> <span class="o">=</span> <span class="n">histogram_edges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">histogram_edges</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="n">bin_max</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">bin_min</span><span class="p">):</span>
                        <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">k</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">):</span>
                    <span class="n">bin_idx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">score</span> <span class="o">+=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">histograms</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="Statistics.hbos"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.hbos">[docs]</a>    <span class="k">def</span> <span class="nf">hbos</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Histogram-based Outlier Scores (HBOS). HBOS quantifies the abnormality of data points based on the densities of their feature values</span>
<span class="sd">        within their respective buckets over all feature values.</span>

<span class="sd">        :parameter np.ndarray data: 2d array with frames represented by rows and columns representing feature values.</span>
<span class="sd">        :parameter Literal bucket_method: Estimator determining optimal bucket count and bucket width. Default: The maximum of the Sturges and Freedman-Diaconis estimators.</span>
<span class="sd">        :return np.ndarray: Array of size data.shape[0] representing outlier scores, with higher values representing greater outliers.</span>

<span class="sd">        .. image:: _static/img/hbos.png</span>
<span class="sd">           :width: 1200</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.random.random_integers(low=1, high=2, size=(10, 50)).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.random.random_integers(low=7, high=20, size=(2, 50)).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; data = np.vstack([sample_1, sample_2])</span>
<span class="sd">        &gt;&gt;&gt; Statistics().hbos(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">min_vals</span><span class="p">,</span> <span class="n">max_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">min_vals</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_vals</span> <span class="o">-</span> <span class="n">min_vals</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span>
        <span class="n">histogram_edges</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="n">Dict</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">key_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">float64</span><span class="p">[:]</span>
        <span class="p">)</span>
        <span class="n">histograms</span> <span class="o">=</span> <span class="n">typed</span><span class="o">.</span><span class="n">Dict</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">key_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int64</span><span class="p">[:])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span>
            <span class="p">)</span>
            <span class="n">histograms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span>
                <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">histogram_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hbos_compute</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">histograms</span><span class="o">=</span><span class="n">histograms</span><span class="p">,</span> <span class="n">histogram_edges</span><span class="o">=</span><span class="n">histogram_edges</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.rolling_shapiro_wilks"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.rolling_shapiro_wilks">[docs]</a>    <span class="k">def</span> <span class="nf">rolling_shapiro_wilks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_window</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Shapiro-Wilks normality statistics for sequentially binned values in a time-series. E.g., compute</span>
<span class="sd">        the normality statistics of ``Feature N`` in each window of ``time_window`` seconds.</span>

<span class="sd">        :parameter ndarray data: 1D array of size len(frames) representing feature values.</span>
<span class="sd">        :parameter int time_window: The size of the buckets in seconds.</span>
<span class="sd">        :parameter int fps: Frame-rate of recorded video.</span>
<span class="sd">        :return np.ndarray: Array of size data.shape[0] with Shapiro-Wilks normality statistics</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(low=0, high=100, size=(200)).astype(&#39;float32&#39;)</span>
<span class="sd">        &gt;&gt;&gt; results = self.rolling_shapiro_wilks(data=data, time_window=1, fps=30)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">time_window</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">time_window</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">window_size</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_window</span> <span class="o">*</span> <span class="n">fps</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_size</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span>
                <span class="p">((</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">window_size</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">shapiro</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.sliding_z_scores"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_z_scores">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64,)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_z_scores</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sliding Z-scores for a given data array over specified time windows.</span>

<span class="sd">        This function computes sliding Z-scores for a 1D data array over different time windows. The sliding Z-score</span>
<span class="sd">        is a measure of how many standard deviations a data point is from the mean of the surrounding data within</span>
<span class="sd">        the specified time window. This can be useful for detecting anomalies or variations in time-series data.</span>

<span class="sd">        :parameter ndarray data: 1D NumPy array containing the time-series data.</span>
<span class="sd">        :parameter ndarray time_windows: 1D NumPy array specifying the time windows in seconds over which to calculate the Z-scores.</span>
<span class="sd">        :parameter int time_windows: Frames per second, used to convert time windows from seconds to the corresponding number of data points.</span>
<span class="sd">        :returns np.ndarray: A 2D NumPy array containing the calculated Z-scores. Each row corresponds to the Z-scores calculated for a specific time window. The time windows are represented by the columns.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (1000,)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; z_scores = Statistics().sliding_z_scores(data=data, time_windows=np.array([1.0, 2.5]), fps=10)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">sample_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">left</span> <span class="p">:</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">m</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample_data</span><span class="p">)</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">sample_data</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="n">s</span>
                <span class="n">results</span><span class="p">[</span><span class="n">left</span> <span class="p">:</span> <span class="n">right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.phi_coefficient"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.phi_coefficient">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(int64[:, :],)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">phi_coefficient</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the phi coefficient for a Nx2 array of binary data.</span>

<span class="sd">        The phi coefficient (a.k.a Matthews Correlation Coefficient (MCC)), is a measure of association for binary data in a 2x2 contingency table. It quantifies the</span>
<span class="sd">        degree of association or correlation between two binary variables (e.g., binary classification targets).</span>

<span class="sd">        The formula for the phi coefficient is defined as:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\phi = \\frac{{(BC - AD)}}{{\sqrt{{(C\_1 + C\_2)(R\_1 + R\_2)(C\_1 + R\_1)(C\_2 + R\_2)}}}}</span>

<span class="sd">        where:</span>
<span class="sd">            - BC: Hit rate (reponse and truth is both 1)</span>
<span class="sd">            - AD: Correct rejections (response and truth are both 0)</span>
<span class="sd">            - C1, C2: Counts of occurrences where the response is 1 and 0, respectively.</span>
<span class="sd">            - R1, R2: Counts of occurrences where the truth is 1 and 0, respectively.</span>

<span class="sd">        :param np.ndarray data: A NumPy array containing binary data organized in two columns. Each row represents a pair of binary values for two variables. Columns represent two features or two binary classification results.</span>
<span class="sd">        :param float: The calculated phi coefficient, a value between 0 and 1. A value of 0 indicates no association between the variables, while 1 indicates a perfect association.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([[0, 1], [1, 0], [1, 0], [1, 1]]).astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().phi_coefficient(data=data)</span>
<span class="sd">        &gt;&gt;&gt; 0.8164965809277261</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 2, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; result = Statistics.phi_coefficient(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cnt_0_0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">cnt_0_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">cnt_1_0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">cnt_1_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="n">BC</span><span class="p">,</span> <span class="n">AD</span> <span class="o">=</span> <span class="n">cnt_1_1</span> <span class="o">*</span> <span class="n">cnt_0_0</span><span class="p">,</span> <span class="n">cnt_1_0</span> <span class="o">*</span> <span class="n">cnt_0_1</span>
        <span class="n">nominator</span> <span class="o">=</span> <span class="n">BC</span> <span class="o">-</span> <span class="n">AD</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_1_1</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">cnt_0_0</span> <span class="o">+</span> <span class="n">cnt_0_1</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_0_0</span><span class="p">)</span>
            <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_1</span> <span class="o">*</span> <span class="n">cnt_0_1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">nominator</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="p">(</span><span class="n">BC</span> <span class="o">-</span> <span class="n">AD</span><span class="p">)</span>
                <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_1_1</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="n">cnt_0_0</span> <span class="o">+</span> <span class="n">cnt_0_1</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_0_0</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_1</span> <span class="o">*</span> <span class="n">cnt_0_1</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.eta_squared"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.eta_squared">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">eta_squared</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate eta-squared, a measure of between-subjects effect size.</span>

<span class="sd">        Eta-squared (\(\eta^2\)) is calculated as the ratio of the sum of squares between groups to the total sum of squares. Range from 0 to 1, where larger values indicate</span>
<span class="sd">        a stronger effect size.</span>

<span class="sd">        .. math::</span>
<span class="sd">           \eta^2 = \frac{SS_{between}}{SS_{between} + SS_{within}}</span>

<span class="sd">        where:</span>
<span class="sd">        - \( SS_{between} \) is the sum of squares between groups.</span>
<span class="sd">        - \( SS_{within} \) is the sum of squares within groups.</span>

<span class="sd">        :param np.ndarray x: 1D array containing the dependent variable data.</span>
<span class="sd">        :param np.ndarray y: 1d array containing the grouping variable (categorical) data of same size as ``x``.</span>
<span class="sd">        :return float: The eta-squared value representing the proportion of variance in the dependent variable that is attributable to the grouping variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">eta_squared</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">eta_squared</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>
        <span class="n">sum_square_within</span><span class="p">,</span> <span class="n">sum_square_between</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">lbl</span><span class="p">)]</span>
            <span class="n">sum_square_within</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">sum_square_between</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">sum_square_between</span> <span class="o">+</span> <span class="n">sum_square_within</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sum_square_between</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_square_between</span> <span class="o">+</span> <span class="n">sum_square_within</span><span class="p">))</span> <span class="o">**</span> <span class="mf">.5</span></div>

<div class="viewcode-block" id="Statistics.sliding_eta_squared"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_eta_squared">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_eta_squared</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sliding window eta-squared, a measure of effect size for between-subjects designs,</span>
<span class="sd">        over multiple window sizes.</span>

<span class="sd">        :param np.ndarray x: The array containing the dependent variable data.</span>
<span class="sd">        :param np.ndarray y: The array containing the grouping variable (categorical) data.</span>
<span class="sd">        :param np.ndarray window_sizes: 1D array of window sizes in seconds.</span>
<span class="sd">        :param int sample_rate: The sampling rate of the data in frames per second.</span>
<span class="sd">        :return np.ndarray: Array of size  x.shape[0] x window_sizes.shape[0] with sliding eta squared values.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 10, (10000,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 2, (10000,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.sliding_eta_squared(x=x, y=y, window_sizes=np.array([1.0, 2.0]), sample_rate=10)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">sample_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">sample_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">sum_square_within</span><span class="p">,</span> <span class="n">sum_square_between</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample_y</span><span class="p">):</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">sample_x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">sample_y</span> <span class="o">==</span> <span class="n">lbl</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
                    <span class="n">sum_square_within</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">g</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">sum_square_between</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample_x</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">sum_square_between</span> <span class="o">+</span> <span class="n">sum_square_within</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_square_between</span> <span class="o">/</span> <span class="p">(</span><span class="n">sum_square_between</span> <span class="o">+</span> <span class="n">sum_square_within</span><span class="p">))</span> <span class="o">**</span> <span class="mf">.5</span>
        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="Statistics.sliding_phi_coefficient"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_phi_coefficient">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(int32[:, :], float64[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_phi_coefficient</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sliding phi coefficients for a 2x2 contingency table derived from binary data.</span>

<span class="sd">        Computes sliding phi coefficients for a 2x2 contingency table derived from binary data over different</span>
<span class="sd">        time windows. The phi coefficient is a measure of association between two binary variables, and sliding phi</span>
<span class="sd">        coefficients can reveal changes in association over time.</span>

<span class="sd">        :param np.ndarray data: A 2D NumPy array containing binary data organized in two columns. Each row represents a pair of binary values for two variables.</span>
<span class="sd">        :param np.ndarray window_sizes: 1D NumPy array specifying the time windows (in seconds) over which to calculate the sliding phi coefficients.</span>
<span class="sd">        :param int sample_rate: The sampling rate or time interval (in samples per second, e.g., fps) at which data points were collected.</span>
<span class="sd">        :returns np.ndarray: A 2D NumPy array containing the calculated sliding phi coefficients. Each row corresponds to the phi coefficients calculated for a specific time point, the columns correspond to time-windows.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 2, (200, 2))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().sliding_phi_coefficient(data=data, window_sizes=np.array([1.0, 4.0]), sample_rate=10)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">cnt_0_0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">cnt_0_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">cnt_1_0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">cnt_1_1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="n">BC</span><span class="p">,</span> <span class="n">AD</span> <span class="o">=</span> <span class="n">cnt_1_1</span> <span class="o">*</span> <span class="n">cnt_0_0</span><span class="p">,</span> <span class="n">cnt_1_0</span> <span class="o">*</span> <span class="n">cnt_0_1</span>
                <span class="n">nominator</span> <span class="o">=</span> <span class="n">BC</span> <span class="o">-</span> <span class="n">AD</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_1_1</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="n">cnt_0_0</span> <span class="o">+</span> <span class="n">cnt_0_1</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_0_0</span><span class="p">)</span>
                    <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_1</span> <span class="o">*</span> <span class="n">cnt_0_1</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">nominator</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">BC</span> <span class="o">-</span> <span class="n">AD</span><span class="p">)</span>
                        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_1_1</span><span class="p">)</span>
                            <span class="o">*</span> <span class="p">(</span><span class="n">cnt_0_0</span> <span class="o">+</span> <span class="n">cnt_0_1</span><span class="p">)</span>
                            <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_0</span> <span class="o">+</span> <span class="n">cnt_0_0</span><span class="p">)</span>
                            <span class="o">*</span> <span class="p">(</span><span class="n">cnt_1_1</span> <span class="o">*</span> <span class="n">cnt_0_1</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.relative_risk"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.relative_risk">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">relative_risk</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the relative risk between two binary arrays.</span>

<span class="sd">        Relative risk (RR) is the ratio of the probability of an event occurring in one group/feature/cluster/variable (x)</span>
<span class="sd">        to the probability of the event occurring in another group/feature/cluster/variable (y).</span>

<span class="sd">        :param np.ndarray x: The first 1D binary array.</span>
<span class="sd">        :param np.ndarray y: The second 1D binary array.</span>
<span class="sd">        :return float: The relative risk between arrays x and y.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; Statistics.relative_risk(x=np.array([0, 1, 1]), y=np.array([0, 1, 0]))</span>
<span class="sd">        &gt;&gt;&gt; 2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">relative_risk</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">relative_risk</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Statistics.sliding_relative_risk"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_relative_risk">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_relative_risk</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sliding relative risk values between two binary arrays using different window sizes.</span>

<span class="sd">        :param np.ndarray x: The first 1D binary array.</span>
<span class="sd">        :param np.ndarray y: The second 1D binary array.</span>
<span class="sd">        :param np.ndarray window_sizes:</span>
<span class="sd">        :param int sample_rate:</span>
<span class="sd">        :return np.ndarray: Array of size  x.shape[0] x window_sizes.shape[0] with sliding eta squared values.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; Statistics.sliding_relative_risk(x=np.array([0, 1, 1, 0]), y=np.array([0, 1, 0, 0]), window_sizes=np.array([1.0]), sample_rate=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">sample_x</span><span class="p">,</span> <span class="n">sample_y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.cohens_h"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.cohens_h">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;int64[:], int64[:],&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cohens_h</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute Cohen&#39;s h effect size for two samples of binary [0, 1] values. Cohen&#39;s h is a measure of effect size</span>
<span class="sd">        for comparing two independent samples based on the differences in proportions of the two samples.</span>

<span class="sd">        .. note:</span>
<span class="sd">           Modified from `DABEST &lt;https://github.com/ACCLAB/DABEST-python/blob/fa7df50d20ab1c9cc687c66dd8bddf55d9a9dce3/dabest/_stats_tools/effsize.py#L216&gt;`_</span>
<span class="sd">           `Cohen&#39;s h wiki &lt;https://en.wikipedia.org/wiki/Cohen%27s_h&gt;`_</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\text{Cohen&#39;s h} = 2 \\arcsin\\left(\\sqrt{\\frac{\\sum\\text{sample\_1}}{N\_1}}\\right) - 2 \\arcsin\\left(\\sqrt{\\frac{\\sum\\text{sample\_2}}{N\_2}}\\right)</span>

<span class="sd">        Where N_1 and N_2 are the sample sizes of sample_1 and sample_2, respectively.</span>

<span class="sd">        :param np.ndarray sample_1: 1D array with binary [0, 1] values (e.g., first classifier inference values).</span>
<span class="sd">        :param np.ndarray sample_2: 1D array with binary [0, 1] values (e.g., second classifier inference values).</span>
<span class="sd">        :return float: Cohen&#39;s h effect size.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.array([1, 0, 0, 1])</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.array([1, 1, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; Statistics().cohens_h(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &gt;&gt;&gt; -0.5235987755982985</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sample_1_proportion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sample_2_proportion</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi_sample_1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sample_1_proportion</span><span class="p">))</span>
        <span class="n">phi_sample_2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sample_2_proportion</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">phi_sample_1</span> <span class="o">-</span> <span class="n">phi_sample_2</span></div>

<div class="viewcode-block" id="Statistics.sliding_skew"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_skew">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64,)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_skew</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the skewness of a 1D array within sliding time windows.</span>

<span class="sd">        :param np.ndarray data: 1D array of input data.</span>
<span class="sd">        :param np.ndarray data: 1D array of time window durations in seconds.</span>
<span class="sd">        :param np.ndarray data: Sampling rate of the data in samples per second.</span>
<span class="sd">        :return np.ndarray: 2D array of skewness`1 values with rows corresponding to data points and columns corresponding to time windows.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (10,))</span>
<span class="sd">        &gt;&gt;&gt; skewness = Statistics().sliding_skew(data=data.astype(np.float32), time_windows=np.array([1.0, 2.0]), sample_rate=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">window_size</span> <span class="p">:</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.sliding_kurtosis"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_kurtosis">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64,)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_kurtosis</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the kurtosis of a 1D array within sliding time windows.</span>

<span class="sd">        :param np.ndarray data: Input data array.</span>
<span class="sd">        :param np.ndarray time_windows: 1D array of time window durations in seconds.</span>
<span class="sd">        :param np.ndarray sample_rate: Sampling rate of the data in samples per second.</span>
<span class="sd">        :return np.ndarray: 2D array of skewness`1 values with rows corresponding to data points and columns corresponding to time windows.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (10,))</span>
<span class="sd">        &gt;&gt;&gt; kurtosis = Statistics().sliding_kurtosis(data=data.astype(np.float32), time_windows=np.array([1.0, 2.0]), sample_rate=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">window_size</span> <span class="p">:</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">mean</span><span class="p">,</span> <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(((</span><span class="n">data</span> <span class="o">-</span> <span class="n">mean</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.kmeans_1d"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.kmeans_1d">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">kmeans_1d</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">calc_medians</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">DictType</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform k-means clustering on a 1-dimensional dataset.</span>

<span class="sd">        .. note:</span>
<span class="sd">           - If calc_medians is True, the function returns cluster medians in addition to centroids and labels.</span>

<span class="sd">        :parameter np.ndarray data: 1d array containing feature values.</span>
<span class="sd">        :parameter int k: Number of clusters.</span>
<span class="sd">        :parameter int max_iters: Maximum number of iterations for the k-means algorithm.</span>
<span class="sd">        :parameter bool calc_medians: Flag indicating whether to calculate cluster medians.</span>
<span class="sd">        :returns Tuple: Tuple of three elements. Final centroids of the clusters. Labels assigned to each data point based on clusters. Cluster medians (if calc_medians is True), otherwise None.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data_1d = np.array([1, 2, 3, 55, 65, 40, 43, 40]).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; centroids, labels, medians = Statistics().kmeans_1d(data_1d, 2, 1000, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">medians</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">min_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">centroids</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">dist_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">dist_sum</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                        <span class="n">min_dist</span> <span class="o">=</span> <span class="n">dist_sum</span>
                        <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>

            <span class="n">new_centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">cluster</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">new_centroids</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">+=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">cluster</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_centroids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">centroids</span><span class="p">,</span> <span class="n">new_centroids</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">centroids</span> <span class="o">=</span> <span class="n">new_centroids</span>

        <span class="k">if</span> <span class="n">calc_medians</span><span class="p">:</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">medians</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">medians</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span>

        <span class="k">return</span> <span class="n">centroids</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">medians</span></div>

<div class="viewcode-block" id="Statistics.hamming_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.hamming_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">float32</span><span class="p">[:]),</span>
            <span class="p">(</span>
                <span class="n">int8</span><span class="p">[:],</span>
                <span class="n">int8</span><span class="p">[:],</span>
                <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="p">(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">bool_</span><span class="p">,</span> <span class="n">float32</span><span class="p">[:]),</span>
            <span class="p">(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">bool_</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">hamming_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span><span class="n">w</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the Hamming similarity between two vectors.</span>

<span class="sd">        The Hamming similarity measures the similarity between two binary vectors by counting the number of positions at which the corresponding elements are different.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If w is not provided, equal weights are assumed. Adapted from `pynndescent &lt;https://pynndescent.readthedocs.io/en/latest/&gt;`_.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\text{Hamming distance}(x, y) = \\frac{{\\sum_{i=1}^{n} w_i}}{{n}}</span>

<span class="sd">        where:</span>
<span class="sd">           - \( n \) is the length of the vectors,</span>
<span class="sd">           - \( w_i \) is the weight associated with the \( i \)th element of the vectors.</span>

<span class="sd">        :parameter np.ndarray x: First binary vector.</span>
<span class="sd">        :parameter np.ndarray x: Second binary vector.</span>
<span class="sd">        :parameter Optional[np.ndarray] w: Optional weights for each element. Can be classification probabilities. If not provided, equal weights are assumed.</span>
<span class="sd">        :parameter Optional[bool] sort: If True, sorts x and y prior to hamming distance calculation. Default, False.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x, y = np.random.randint(0, 2, (10,)).astype(np.int8), np.random.randint(0, 2, (10,)).astype(np.int8)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().hamming_distance(x=x, y=y)</span>
<span class="sd">        &gt;&gt;&gt; 0.91</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pass</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">results</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Statistics.yule_coef"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.yule_coef">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:]),</span> <span class="p">(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">))]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">yule_coef</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">float64</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted calculate of the yule coefficient between two binary vectors (e.g., to classified behaviors). 0 represent independence, 2 represents</span>
<span class="sd">        complete interdependence.</span>

<span class="sd">        .. math::</span>
<span class="sd">           Yule Coefficient = \\frac{{2 \cdot t_f \cdot f_t}}{{t_t \cdot f_f + t_f \cdot f_t}}</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `pynndescent &lt;https://pynndescent.readthedocs.io/en/latest/&gt;`_.</span>

<span class="sd">        :parameter np.ndarray x: First binary vector.</span>
<span class="sd">        :parameter np.ndarray x: Second binary vector.</span>
<span class="sd">        :parameter Optional[np.ndarray] w: Optional weights for each element. Can be classification probabilities. If not provided, equal weights are assumed.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 2, (50,)).astype(np.int8)</span>
<span class="sd">        &gt;&gt;&gt; y = x ^ 1</span>
<span class="sd">        &gt;&gt;&gt; Statistics().yule_coef(x=x, y=y)</span>
<span class="sd">        &gt;&gt;&gt; 2</span>
<span class="sd">        &gt;&gt;&gt; random_indices = np.random.choice(len(x), size=len(x)//2, replace=False)</span>
<span class="sd">        &gt;&gt;&gt; y = np.copy(x)</span>
<span class="sd">        &gt;&gt;&gt; y[random_indices] = 1 - y[random_indices]</span>
<span class="sd">        &gt;&gt;&gt; Statistics().yule_coef(x=x, y=y)</span>
<span class="sd">        &gt;&gt;&gt; 0.99</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">f_f</span><span class="p">,</span> <span class="n">t_t</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">f_t</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">t_t</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">f_f</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">f_t</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">t_f</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">t_f</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">f_t</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">t_f</span> <span class="o">*</span> <span class="n">f_t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">t_t</span> <span class="o">*</span> <span class="n">f_f</span> <span class="o">+</span> <span class="n">t_f</span> <span class="o">*</span> <span class="n">f_t</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.sokal_sneath"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sokal_sneath">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span> <span class="p">(</span><span class="n">int8</span><span class="p">[:],</span> <span class="n">int8</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:])]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">sokal_sneath</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">float64</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted calculate of the sokal sneath coefficient between two binary vectors (e.g., to classified behaviors). 0 represent independence, 1 represents complete interdependence.</span>

<span class="sd">        .. math::</span>
<span class="sd">           Sokal-Sneath = \\frac{{f_t + t_f}}{{2 \cdot (t_{{cnt}} + f_{{cnt}}) + f_t + t_f}}</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `pynndescent &lt;https://pynndescent.readthedocs.io/en/latest/&gt;`_.</span>

<span class="sd">        :parameter np.ndarray x: First binary vector.</span>
<span class="sd">        :parameter np.ndarray x: Second binary vector.</span>
<span class="sd">        :parameter Optional[np.ndarray] w: Optional weights for each element. Can be classification probabilities. If not provided, equal weights are assumed.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([0, 1, 0, 0, 1]).astype(np.int8)</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([1, 0, 1, 1, 0]).astype(np.int8)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().sokal_sneath(x, y)</span>
<span class="sd">        &gt;&gt;&gt; 0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">t_cnt</span><span class="p">,</span> <span class="n">f_cnt</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">f_t</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">t_cnt</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">f_cnt</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">f_t</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">t_f</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">f_t</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">f_t</span> <span class="o">+</span> <span class="n">t_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_cnt</span> <span class="o">+</span> <span class="n">f_cnt</span><span class="p">)</span> <span class="o">+</span> <span class="n">f_t</span> <span class="o">+</span> <span class="n">t_f</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.bray_curtis_dissimilarity"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.bray_curtis_dissimilarity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">([(</span><span class="n">float32</span><span class="p">[:,</span> <span class="p">:],</span> <span class="n">float32</span><span class="p">[:,</span> <span class="p">:]),</span> <span class="p">(</span><span class="n">float32</span><span class="p">[:,</span> <span class="p">:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">None</span><span class="p">))])</span>
    <span class="k">def</span> <span class="nf">bray_curtis_dissimilarity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the Bray-Curtis dissimilarity matrix between samples based on feature values.</span>

<span class="sd">        The Bray-Curtis dissimilarity measures the dissimilarity between two samples based on their feature values.</span>
<span class="sd">        It is useful for finding similar frames based on behavior.</span>

<span class="sd">        Useful for finding similar frames based on behavior.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `pynndescent &lt;https://pynndescent.readthedocs.io/en/latest/&gt;`_.</span>

<span class="sd">        :parameter np.ndarray x: 2d array with likely normalized feature values.</span>
<span class="sd">        :parameter Optional[np.ndarray] w: Optional 2d array with weights of same size as x. Default None and all observations will have the same weight.</span>
<span class="sd">        :returns np.ndarray: 2d array with same size as x representing dissimilarity values. 0 and the observations are identical and at 1 the observations are completly disimilar.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([[1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics().bray_curtis_dissimilarity(x=x)</span>
<span class="sd">        &gt;&gt;&gt; [[0, 1., 1., 0.], [1., 0., 0., 1.], [1., 0., 0., 1.], [0., 1., 1., 0.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">num</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">den</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">s2</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">den</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">float32</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">((</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float32</span><span class="p">[:]))</span>
    <span class="k">def</span> <span class="nf">_hellinger_helper</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Jitted helper for computing Hellinger distances from ``hellinger_distance``&quot;&quot;&quot;</span>
        <span class="n">result</span><span class="p">,</span> <span class="n">norm_x</span><span class="p">,</span> <span class="n">norm_y</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">norm_x</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">norm_y</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">norm_x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">norm_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">norm_x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">norm_y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">result</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm_x</span> <span class="o">*</span> <span class="n">norm_y</span><span class="p">))</span>

<div class="viewcode-block" id="Statistics.hellinger_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.hellinger_distance">[docs]</a>    <span class="k">def</span> <span class="nf">hellinger_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">bucket_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;fd&quot;</span><span class="p">,</span> <span class="s2">&quot;doane&quot;</span><span class="p">,</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;scott&quot;</span><span class="p">,</span> <span class="s2">&quot;stone&quot;</span><span class="p">,</span> <span class="s2">&quot;rice&quot;</span><span class="p">,</span> <span class="s2">&quot;sturges&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Hellinger distance between two vector distributions.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The Hellinger distance is bounded and ranges from 0 to √2. Distance of √2 indicates that the two distributions are maximally dissimilar</span>

<span class="sd">        .. math::</span>

<span class="sd">           H(P, Q) = \frac{1}{\sqrt{2}} \sqrt{ \sum_{i=1}^{n} (\sqrt{P(i)} - \sqrt{Q(i)})^2 }</span>

<span class="sd">        where \( n \) is the number of bins in the histogram representation of the distributions.</span>

<span class="sd">        :param np.ndarray x: First 1D array representing a probability distribution.</span>
<span class="sd">        :param np.ndarray y: Second 1D array representing a probability distribution.</span>
<span class="sd">        :param Optional[Literal[&#39;fd&#39;, &#39;doane&#39;, &#39;auto&#39;, &#39;scott&#39;, &#39;stone&#39;, &#39;rice&#39;, &#39;sturges&#39;, &#39;sqrt&#39;]] bucket_method: Method for computing histogram bins. Default is &#39;auto&#39;.</span>
<span class="sd">        :returns float: Hellinger distance between the two input probability distributions.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 9000, (500000,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 9000, (500000,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics().hellinger_distance(x=x, y=y, bucket_method=&#39;auto&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">hellinger_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">hellinger_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">hellinger_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">BUCKET_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">bin_width</span><span class="p">,</span> <span class="n">bin_count</span> <span class="o">=</span> <span class="n">bucket_data</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">bucket_method</span><span class="p">)</span>
        <span class="n">s1_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]))</span>
        <span class="n">s2_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist_1d</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">bin_count</span><span class="o">=</span><span class="n">bin_count</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_width</span> <span class="o">*</span> <span class="n">bin_count</span><span class="p">)]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hellinger_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">s1_h</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="n">s2_h</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span></div>

<div class="viewcode-block" id="Statistics.youden_j"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.youden_j">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">youden_j</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Youden&#39;s J statistic from two binary arrays.</span>

<span class="sd">        Youden&#39;s J statistic is a measure of the overall performance of a binary classification test, taking into account both sensitivity (true positive rate) and specificity (true negative rate).</span>

<span class="sd">        :param sample_1: The first binary array.</span>
<span class="sd">        :param sample_2: The second binary array.</span>
<span class="sd">        :return float: Youden&#39;s J statistic.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_1</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">youden_j</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> sample_1&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">sample_2</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">youden_j</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> sample_2&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)],</span> <span class="n">accepted_values</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample_2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample_2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">sample_1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sensitivity</span> <span class="o">=</span> <span class="n">tp</span> <span class="o">/</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span>
            <span class="n">specificity</span> <span class="o">=</span> <span class="n">tn</span> <span class="o">/</span> <span class="p">(</span><span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sensitivity</span> <span class="o">+</span> <span class="n">specificity</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Statistics.jaccard_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.jaccard_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jaccard_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Jaccard distance between two 1D NumPy arrays.</span>

<span class="sd">        The Jaccard distance is a measure of dissimilarity between two sets. It is defined as the size of the</span>
<span class="sd">        intersection of the sets divided by the size of the union of the sets.</span>

<span class="sd">        :param np.ndarray x: The first 1D NumPy array.</span>
<span class="sd">        :param np.ndarray y: The second 1D NumPy array.</span>
<span class="sd">        :return float: The Jaccard distance between arrays x and y.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 5, (100))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 7, (100))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.jaccard_distance(x=x, y=y)</span>
<span class="sd">        &gt;&gt;&gt; 0.2857143</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">jaccard_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">jaccard_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">])</span>
        <span class="n">u_x</span><span class="p">,</span> <span class="n">u_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">u_x</span><span class="p">,</span> <span class="n">u_y</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">u_x</span><span class="p">,</span> <span class="n">u_y</span><span class="p">))))))</span></div>

<div class="viewcode-block" id="Statistics.manhattan_distance_cdist"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.manhattan_distance_cdist">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">manhattan_distance_cdist</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the pairwise Manhattan distance matrix between points in a 2D array.</span>

<span class="sd">        Can be preferred over Euclidean distance in scenarios where the movement is restricted</span>
<span class="sd">        to grid-based paths and/or the data is high dimensional.</span>

<span class="sd">        .. math::</span>
<span class="sd">           D_{\text{Manhattan}} = |x_2 - x_1| + |y_2 - y_1|</span>

<span class="sd">        :param data: 2D array where each row represents a featurized observation (e.g., frame)</span>
<span class="sd">        :return np.ndarray: Pairwise Manhattan distance matrix where element (i, j) represents the distance between points i and j.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 50, (10000, 2))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.manhattan_distance_cdist(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">manhattan_distance_cdist</span><span class="si">}</span><span class="s1"> data&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">differences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.mahalanobis_distance_cdist"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.mahalanobis_distance_cdist">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="s1">&#39;(float32[:,:],)&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">mahalanobis_distance_cdist</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Mahalanobis distance between every pair of observations in a 2D array using numba.</span>

<span class="sd">        The Mahalanobis distance is a measure of the distance between a point and a distribution. It accounts for correlations between variables and the scales of the variables, making it suitable for datasets where features are not independent and have different variances.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Significantly reduced runtime versus Mahalanobis scipy.cdist only with larger feature sets ( &gt; 10-50).</span>

<span class="sd">        However, Mahalanobis distance may not be suitable in certain scenarios, such as:</span>
<span class="sd">        - When the dataset is small and the covariance matrix is not accurately estimated.</span>
<span class="sd">        - When the dataset contains outliers that significantly affect the estimation of the covariance matrix.</span>
<span class="sd">        - When the assumptions of multivariate normality are violated.</span>

<span class="sd">        :param np.ndarray data: 2D array with feature observations. Frames on axis 0 and feature values on axis 1</span>
<span class="sd">        :return np.ndarray: Pairwise Mahalanobis distance matrix where element (i, j) represents the Mahalanobis distance between  observations i and j.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 50, (1000, 200)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; x = Statistics.mahalanobis_distance_cdist(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">covariance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">inv_covariance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">covariance_matrix</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">inv_covariance_matrix</span><span class="p">),</span> <span class="n">diff</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">distances</span></div>

<div class="viewcode-block" id="Statistics.cohens_kappa"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.cohens_kappa">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(int64[:], int64[:])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cohens_kappa</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute Cohen&#39;s Kappa coefficient for two binary samples.</span>

<span class="sd">        Cohen&#39;s Kappa coefficient measures the agreement between two sets of binary ratings, taking into account agreement occurring by chance.</span>
<span class="sd">        It ranges from -1 to 1, where 1 indicates perfect agreement, 0 indicates agreement by chance, and -1 indicates complete disagreement.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\kappa = 1 - \\frac{\sum{w_{ij} \\cdot D_{ij}}}{\\sum{w_{ij} \\cdot E_{ij}}}</span>

<span class="sd">        where:</span>
<span class="sd">            - \( \kappa \) is Cohen&#39;s Kappa coefficient,</span>
<span class="sd">            - \( w_{ij} \) are the weights,</span>
<span class="sd">            - \( D_{ij} \) are the observed frequencies,</span>
<span class="sd">            - \( E_{ij} \) are the expected frequencies.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.random.randint(0, 2, size=(10000,))</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.random.randint(0, 2, size=(10000,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.cohens_kappa(sample_1=sample_1, sample_2=sample_2))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sample_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">sample_1</span><span class="p">)</span>
        <span class="n">sample_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">sample_2</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sample_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sample_2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">tp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">tn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="n">tp</span><span class="p">,</span> <span class="n">fp</span><span class="p">],</span> <span class="p">[</span><span class="n">fn</span><span class="p">,</span> <span class="n">tn</span><span class="p">]))</span>
        <span class="n">sum0</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sum1</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">sum0</span><span class="p">,</span> <span class="n">sum1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sum0</span><span class="p">)</span>
        <span class="n">w_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">w_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">w_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_mat</span> <span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w_mat</span> <span class="o">*</span> <span class="n">expected</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.d_prime"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.d_prime">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">d_prime</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lower_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span>
        <span class="n">upper_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9999</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes d-prime from two Boolean 1d arrays, e.g., between classifications and ground truth.</span>

<span class="sd">        D-prime (d&#39;) is a measure of signal detection performance, indicating the ability to discriminate between signal and noise.</span>
<span class="sd">        It is computed as the difference between the inverse cumulative distribution function (CDF) of the hit rate and the false alarm rate.</span>

<span class="sd">        :param np.ndarray x: Boolean 1D array of response values, where 1 represents presence, and 0 representing absence.</span>
<span class="sd">        :param np.ndarray y: Boolean 1D array of ground truth, where 1 represents presence, and 0 representing absence.</span>
<span class="sd">        :param Optional[float] lower_limit: Lower limit to bound hit and false alarm rates. Defaults to 0.0001.</span>
<span class="sd">        :param Optional[float] upper_limit: Upper limit to bound hit and false alarm rates. Defaults to 0.9999.</span>
<span class="sd">        :return float: The calculated d&#39; (d-prime) value.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 2, (1000,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 2, (1000,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.d_prime(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">d_prime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">d_prime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">({</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]}))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;The two arrays has to be equal lengths but got: </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">d_prime</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
            <span class="n">additional</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">i</span><span class="p">))))</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">additional</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;D-prime requires binary input data but found </span><span class="si">{</span><span class="n">additional</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">d_prime</span><span class="p">()</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">hit_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)])</span> <span class="o">/</span> <span class="n">target_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">false_alarm_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)])</span> <span class="o">/</span> <span class="n">target_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hit_rate</span> <span class="o">&lt;</span> <span class="n">lower_limit</span><span class="p">:</span>
            <span class="n">hit_rate</span> <span class="o">=</span> <span class="n">lower_limit</span>
        <span class="k">elif</span> <span class="n">hit_rate</span> <span class="o">&gt;</span> <span class="n">upper_limit</span><span class="p">:</span>
            <span class="n">hit_rate</span> <span class="o">=</span> <span class="n">upper_limit</span>
        <span class="k">if</span> <span class="n">false_alarm_rate</span> <span class="o">&lt;</span> <span class="n">lower_limit</span><span class="p">:</span>
            <span class="n">false_alarm_rate</span> <span class="o">=</span> <span class="n">lower_limit</span>
        <span class="k">elif</span> <span class="n">false_alarm_rate</span> <span class="o">&gt;</span> <span class="n">upper_limit</span><span class="p">:</span>
            <span class="n">false_alarm_rate</span> <span class="o">=</span> <span class="n">upper_limit</span>
        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">hit_rate</span><span class="p">)</span> <span class="o">-</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">false_alarm_rate</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.mcnemar"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.mcnemar">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">mcnemar</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">ground_truth</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">continuity_corrected</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        McNemar&#39;s test to compare the difference in predictive accuracy of two models.</span>

<span class="sd">        E.g., can be used to compute if the accuracy of two classifiers are significantly different when transforming the same data.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `mlextend &lt;https://github.com/rasbt/mlxtend/blob/master/mlxtend/evaluate/mcnemar.py&gt;`__.</span>

<span class="sd">        :param np.ndarray x: 1-dimensional Boolean array with predictions of the first model.</span>
<span class="sd">        :param np.ndarray y: 1-dimensional Boolean array with predictions of the second model.</span>
<span class="sd">        :param np.ndarray ground_truth: 1-dimensional Boolean array with ground truth labels.</span>
<span class="sd">        :param Optional[bool] continuity_corrected : Whether to apply continuity correction. Default is True.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 2, (100000, ))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 2, (100000, ))</span>
<span class="sd">        &gt;&gt;&gt; ground_truth = np.random.randint(0, 2, (100000, ))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.mcnemar(x=x, y=y, ground_truth=ground_truth)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">mcnemar</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">mcnemar</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">ground_truth</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">mcnemar</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">({</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ground_truth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]}))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CountError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;The three arrays has to be equal lengths but got: </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">ground_truth</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">mcnemar</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ground_truth</span><span class="p">]:</span>
            <span class="n">additional</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">i</span><span class="p">))))</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">additional</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Mcnemar requires binary input data but found </span><span class="si">{</span><span class="n">additional</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">mcnemar</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ground_truth</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">data</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">continuity_corrected</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span></div>

<div class="viewcode-block" id="Statistics.cochrans_q"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.cochrans_q">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cochrans_q</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Cochrans Q for 2-dimensional boolean array.</span>

<span class="sd">        Cochran&#39;s Q statistic is used to test for significant differences between more than two proportions.</span>
<span class="sd">        It can be used to evaluate if the performance of multiple (&gt;=2) classifiers on the same data is the same or significantly different.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If two classifiers, consider ``simba.mixins.statistics.Statistics.mcnemar``.</span>

<span class="sd">           Useful background: https://psych.unl.edu/psycrs/handcomp/hccochran.PDF</span>

<span class="sd">        :param np.ndarray data: Two dimensional array of boolean values where axis 1 represents classifiers or features and rows represent frames.</span>
<span class="sd">        :return Tuple[float, float]: Cochran&#39;s Q statistic signidicance value.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 2, (100000, 4))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.cochrans_q(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">cochrans_q</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,)</span>
        <span class="p">)</span>
        <span class="n">additional</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">))))</span> <span class="o">-</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">})</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">additional</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Cochrans Q requires binary input data but found </span><span class="si">{</span><span class="n">additional</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">cochrans_q</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">col_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">row_sum_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">row_sum_square_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">col_sums</span><span class="p">)))</span>
        <span class="n">nominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">k</span> <span class="o">*</span> <span class="n">g2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">col_sums</span><span class="p">)))</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">row_sum_sum</span><span class="p">)</span> <span class="o">-</span> <span class="n">row_sum_square_sum</span>
        <span class="k">if</span> <span class="n">nominator</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">nominator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">q</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="o">.</span><span class="n">sf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.hartley_fmax"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.hartley_fmax">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">hartley_fmax</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Hartley&#39;s Fmax statistic to test for equality of variances between two features or groups.</span>

<span class="sd">        Hartley&#39;s Fmax statistic is used to test whether two samples have equal variances.</span>
<span class="sd">        It is calculated as the ratio of the largest sample variance to the smallest sample variance.</span>
<span class="sd">        Values close to one represent closer to equal variance.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \text{Hartley&#39;s Fmax} = \frac{\max(\text{Var}(x), \text{Var}(y))}{\min(\text{Var}(x), \text{Var}(y))}</span>

<span class="sd">        where:</span>
<span class="sd">            - Var(x) is the variance of sample x,</span>
<span class="sd">            - Var(y) is the variance of sample y.</span>

<span class="sd">        :param np.ndarray x: 1D array representing numeric data of the first group/feature.</span>
<span class="sd">        :param np.ndarray x: 1D array representing numeric data of the second group/feature.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.random((100,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.random((100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.hartley_fmax(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">hartley_fmax</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">hartley_fmax</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">max_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        <span class="n">min_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_var</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">min_var</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">return</span> <span class="n">max_var</span> <span class="o">/</span> <span class="n">min_var</span></div>

<div class="viewcode-block" id="Statistics.grubbs_test"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.grubbs_test">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">grubbs_test</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">left_tail</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Grubbs&#39; test to detect outliers if the minimum or maximum value in a feature series is an outlier.</span>

<span class="sd">        Grubbs&#39; test is a statistical test used to detect outliers in a univariate data set.</span>
<span class="sd">        It calculates the Grubbs&#39; test statistic as the absolute difference between the</span>
<span class="sd">        extreme value (either the minimum or maximum) and the sample mean, divided by the sample standard deviation.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \text{Grubbs&#39; Test Statistic} = \frac{|\bar{x} - x_{\text{min/max}}|}{s}</span>

<span class="sd">        where:</span>
<span class="sd">            - \( \bar{x} \) is the sample mean,</span>
<span class="sd">            - \( x_{\text{min/max}} \) is the minimum or maximum value of the sample (depending on the tail being tested),</span>
<span class="sd">            - \( s \) is the sample standard deviation.</span>

<span class="sd">        :param np.ndarray x: 1D array representing numeric data.</span>
<span class="sd">        :param Optional[bool] left_tail: If True, the test calculates the Grubbs&#39; test statistic for the left tail (minimum value). If False (default), it calculates the statistic for the right tail (maximum value).</span>
<span class="sd">        :return float: The computed Grubbs&#39; test statistic.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.random((100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.grubbs_test(x=x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">grubbs_test</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_tail</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.wilcoxon"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.wilcoxon">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">wilcoxon</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the Wilcoxon signed-rank test for paired samples.</span>

<span class="sd">        Wilcoxon signed-rank test is a non-parametric statistical hypothesis test used</span>
<span class="sd">        to compare two related samples, matched samples, or repeated measurements on a single sample</span>
<span class="sd">        to assess whether their population mean ranks differ.</span>

<span class="sd">        :param np.ndarray x: 1D array representing the observations for the first sample.</span>
<span class="sd">        :param np.ndarray y: 1D array representing the observations for the second sample.</span>
<span class="sd">        :return: A tuple containing the test statistic (z-score) and the effect size (r).</span>
<span class="sd">        - The test statistic (z-score) measures the deviation of the observed ranks sum from the expected sum.</span>
<span class="sd">        - The effect size (r) measures the strength of association between the variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">diff_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="n">rank_w_ties</span> <span class="o">=</span> <span class="n">fast_mean_rank</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">diff_abs</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">signed_rank_w_ties</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">rank_w_ties</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">t_plus</span><span class="p">,</span> <span class="n">t_minus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">signed_rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">t_minus</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">signed_rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">t_plus</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">u_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="n">std_correction</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">signed_rank_w_ties</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">same_rank_n</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">signed_rank_w_ties</span> <span class="o">==</span> <span class="n">signed_rank_w_ties</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">same_rank_n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">std_correction</span> <span class="o">+=</span> <span class="p">((</span><span class="n">same_rank_n</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">same_rank_n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">std_correction</span><span class="p">)</span> <span class="o">/</span> <span class="mi">24</span><span class="p">)</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">((</span><span class="n">t_plus</span><span class="p">,</span> <span class="n">t_minus</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">W</span> <span class="o">-</span> <span class="n">u_w</span><span class="p">)</span> <span class="o">/</span> <span class="n">std</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">z</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">,</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Statistics.cov_matrix"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.cov_matrix">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="s2">&quot;(float32[:,:], )&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">cov_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted helper to compute the covariance matrix of the input data. Helper for computing cronbach alpha,</span>
<span class="sd">        multivariate analysis, and distance computations.</span>

<span class="sd">        :param np.ndarray data: 2-dimensional numpy array representing the input data with shape (n, m), where n is the number of observations and m is the number of features.</span>
<span class="sd">        :return: Covariance matrix of the input data with shape (m, m). The (i, j)-th element of the matrix represents the covariance between the i-th and j-th features in the data.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0,2, (200, 40)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; covariance_matrix = Statistics.cov_matrix(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="n">mean_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
                <span class="n">mean_j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="n">n</span>
                <span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_j</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">cov</span></div>

<div class="viewcode-block" id="Statistics.mad_median_rule"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.mad_median_rule">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64,)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">mad_median_rule</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect outliers using the MAD-Median Rule. Returns 1d array of size data.shape[0] with 1 representing outlier and 0 representing inlier.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 600, (9000000,)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics.mad_median_rule(data=data, k=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">median</span><span class="p">))</span>
        <span class="n">threshold</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">mad</span>
        <span class="n">outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">median</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span>
        <span class="k">return</span> <span class="n">outliers</span> <span class="o">*</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Statistics.sliding_mad_median_rule"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_mad_median_rule">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64, float64[:], float64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_mad_median_rule</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of outliers in a sliding time-window using the MAD-Median Rule.</span>

<span class="sd">        The MAD-Median Rule is a robust method for outlier detection. It calculates the median absolute deviation (MAD)</span>
<span class="sd">        and uses it to identify outliers based on a threshold defined as k times the MAD.</span>

<span class="sd">        :param np.ndarray data: 1D numerical array representing feature.</span>
<span class="sd">        :param int k: The outlier threshold defined as k * median absolute deviation in each time window.</span>
<span class="sd">        :param np.ndarray time_windows: 1D array of time window sizes in seconds.</span>
<span class="sd">        :param float fps: The frequency of the signal.</span>
<span class="sd">        :return np.ndarray: Array of size (data.shape[0], time_windows.shape[0]) with counts if outliers detected.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 50, (50000,)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; Statistics.sliding_mad_median_rule(data=data, k=2, time_windows=np.array([20.0]), fps=1.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">time_window</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_windows</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fps</span> <span class="o">*</span> <span class="n">time_window</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">w_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">w</span> <span class="p">:</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">w_data</span><span class="p">)</span>
                <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_data</span> <span class="o">-</span> <span class="n">median</span><span class="p">))</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">mad</span>
                <span class="n">outliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w_data</span> <span class="o">-</span> <span class="n">median</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">outliers</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.dunn_index"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.dunn_index">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dunn_index</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Dunn index to evaluate the quality of clustered labels.</span>

<span class="sd">        This function calculates the Dunn Index, which is a measure of clustering quality.</span>
<span class="sd">        The index considers the ratio of the minimum inter-cluster distance to the maximum</span>
<span class="sd">        intra-cluster distance. The Dunn INdex range from zero to infinity and larger values indicate better clustering.</span>
<span class="sd">        The Dunn Index uses Euclidean distances.</span>

<span class="sd">        The Dunn Index is calculated using the following steps:</span>

<span class="sd">        1. **Inter-cluster distance**: Compute the distances between each pair of clusters and find the minimum distance.</span>
<span class="sd">        2. **Intra-cluster distance**: Determine the distances within each cluster and find the maximum distance.</span>

<span class="sd">        The Dunn Index is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">        D = \frac{\min_{i \neq j} \{ \delta(C_i, C_j) \}}{\max_k \{ \Delta(C_k) \}}</span>

<span class="sd">        where :math:`\delta(C_i, C_j)` is the distance between clusters :math:`C_i` and :math:`C_j`, and</span>
<span class="sd">        :math:`\Delta(C_k)` is the diameter of cluster :math:`C_k`.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `jqmviegas &lt;https://github.com/jqmviegas/jqm_cvi/&gt;`_</span>

<span class="sd">           Wiki `https://en.wikipedia.org/wiki/Dunn_index &lt;https://en.wikipedia.org/wiki/Dunn_index&gt;`_</span>

<span class="sd">           If Dunn Index can not be calculated, `-1` is returned.</span>

<span class="sd">        :param np.ndarray x: 2D array representing the data points. Shape (n_samples, n_features).</span>
<span class="sd">        :param np.ndarray y: 1D array representing cluster labels for each data point. Shape (n_samples,).</span>
<span class="sd">        :return float: The Dunn index value</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 100, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 3, (100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.dunn_index(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">dunn_index</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">dunn_index</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)],</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">dunn_index</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">sample</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mf">10e-6</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">sample_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="p">[</span><span class="n">sample_idx</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">nan</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">nan</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">FeatureExtractionMixin</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">array_1</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">array_2</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">big_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ks</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y</span> <span class="o">==</span> <span class="n">k</span><span class="p">))][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y</span> <span class="o">==</span> <span class="n">l</span><span class="p">))]</span>
            <span class="n">deltas</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">values</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y</span> <span class="o">==</span> <span class="n">ks</span><span class="p">[</span><span class="n">m</span><span class="p">]))][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">y</span> <span class="o">==</span> <span class="n">ks</span><span class="p">[</span><span class="n">m</span><span class="p">]))]</span>
            <span class="n">big_deltas</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">big_deltas</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">v</span></div>


<div class="viewcode-block" id="Statistics.davis_bouldin"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.davis_bouldin">[docs]</a>    <span class="k">def</span> <span class="nf">davis_bouldin</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Davis-Bouldin index for evaluating clustering performance.</span>

<span class="sd">        Davis-Bouldin index measures the clustering quality based on the within-cluster</span>
<span class="sd">        similarity and between-cluster dissimilarity. Lower values indicate better clustering.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `scikit-learn &lt;https://github.com/scikit-learn/scikit-learn/blob/f07e0138bfee41cd2c0a5d0251dc3fe03e6e1084/sklearn/metrics/cluster/_unsupervised.py#L390&gt;`_</span>

<span class="sd">        .. math::</span>
<span class="sd">           DB = \frac{1}{N} \sum_{i=1}^{N} \max_{j \neq i} \left( \frac{\sigma_i + \sigma_j}{d_{ij}} \right)</span>

<span class="sd">        where:</span>
<span class="sd">        - :math:`N` is the number of clusters,</span>
<span class="sd">        - :math:`\sigma_i` is the average distance between each point in cluster :math:`i` and the centroid of cluster :math:`i`,</span>
<span class="sd">        - :math:`d_{ij}` is the distance between the centroids of clusters :math:`i` and :math:`j`.</span>

<span class="sd">        :param np.ndarray x: 2D array representing the data points. Shape (n_samples, n_features/n_dimension).</span>
<span class="sd">        :param np.ndarray y: 2D array representing cluster labels for each data point. Shape (n_samples,).</span>
<span class="sd">        :return float: Davis-Bouldin score.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 100, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 3, (100,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.davis_bouldin(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">davis_bouldin</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">davis_bouldin</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)],</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">n_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">intra_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_labels</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_labels</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">cluster_k</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">])]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">cluster_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cluster_mean</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">cluster_mean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cluster_k</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">centroids</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_mean</span>
            <span class="n">intra_dists</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span>
                <span class="n">FeatureExtractionMixin</span><span class="o">.</span><span class="n">framewise_euclidean_distance</span><span class="p">(</span>
                    <span class="n">location_1</span><span class="o">=</span><span class="n">cluster_k</span><span class="p">,</span>
                    <span class="n">location_2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">cluster_k</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">cluster_mean</span><span class="p">),</span>
                    <span class="n">px_per_mm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">centroid_distances</span> <span class="o">=</span> <span class="n">FeatureExtractionMixin</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span>
            <span class="n">array_1</span><span class="o">=</span><span class="n">centroids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">array_2</span><span class="o">=</span><span class="n">centroids</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">intra_dists</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">centroid_distances</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">centroid_distances</span><span class="p">[</span><span class="n">centroid_distances</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">combined_intra_dists</span> <span class="o">=</span> <span class="n">intra_dists</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">intra_dists</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">combined_intra_dists</span> <span class="o">/</span> <span class="n">centroid_distances</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Statistics.calinski_harabasz"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.calinski_harabasz">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:,:], int64[:])&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">calinski_harabasz</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Calinski-Harabasz score to evaluate clustering quality.</span>

<span class="sd">        The Calinski-Harabasz score is a measure of cluster separation and compactness.</span>
<span class="sd">        It is calculated as the ratio of the between-cluster dispersion to the</span>
<span class="sd">        within-cluster dispersion. A higher score indicates better clustering.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `scikit-learn &lt;https://github.com/scikit-learn/scikit-learn/blob/8721245511de2f225ff5f9aa5f5fadce663cd4a3/sklearn/metrics/cluster/_unsupervised.py#L326&gt;`_</span>

<span class="sd">            The Calinski-Harabasz score (CH) is calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            CH = \frac{B}{W} \times \frac{N - k}{k - 1}</span>

<span class="sd">        where:</span>
<span class="sd">        - B is the sum of squared distances between cluster centroids,</span>
<span class="sd">        - W is the sum of squared distances from each point to its assigned cluster centroid,</span>
<span class="sd">        - N is the total number of data points,</span>
<span class="sd">        - k is the number of clusters.</span>

<span class="sd">        :param x: 2D array representing the data points. Shape (n_samples, n_features/n_dimension).</span>
<span class="sd">        :param y: 2D array representing cluster labels for each data point. Shape (n_samples,).</span>
<span class="sd">        :return float: Calinski-Harabasz score.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.random((100, 2)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 100, (100,)).astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; Statistics.calinski_harabasz(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">extra_dispersion</span><span class="p">,</span> <span class="n">intra_dispersion</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
        <span class="n">global_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">global_mean</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_labels</span><span class="p">):</span>
            <span class="n">cluster_k</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="p">:]</span>
            <span class="n">mean_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">cluster_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cluster_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">mean_k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cluster_k</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
            <span class="n">extra_dispersion</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mean_k</span> <span class="o">-</span> <span class="n">global_mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">intra_dispersion</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">cluster_k</span> <span class="o">-</span> <span class="n">mean_k</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">denominator</span> <span class="o">=</span> <span class="n">intra_dispersion</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_labels</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">extra_dispersion</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_labels</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span></div>

<div class="viewcode-block" id="Statistics.adjusted_rand"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.adjusted_rand">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">adjusted_rand</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Adjusted Rand Index (ARI) between two clusterings.</span>

<span class="sd">        The Adjusted Rand Index (ARI) is a measure of the similarity between two clusterings. It considers all pairs of samples and counts pairs that are assigned to the same or different clusters in both the true and predicted clusterings.</span>

<span class="sd">        The ARI is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">           ARI = \\frac{TP + TN}{TP + FP + FN + TN}</span>

<span class="sd">        where:</span>
<span class="sd">            - TP (True Positive) is the number of pairs of elements that are in the same cluster in both x and y,</span>
<span class="sd">            - FP (False Positive) is the number of pairs of elements that are in the same cluster in y but not in x,</span>
<span class="sd">            - FN (False Negative) is the number of pairs of elements that are in the same cluster in x but not in y,</span>
<span class="sd">            - TN (True Negative) is the number of pairs of elements that are in different clusters in both x and y.</span>

<span class="sd">        The ARI value ranges from -1 to 1. A value of 1 indicates perfect clustering agreement, 0 indicates random clustering, and negative values indicate disagreement between the clusterings.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `scikit-learn &lt;https://github.com/scikit-learn/scikit-learn/blob/8721245511de2f225ff5f9aa5f5fadce663cd4a3/sklearn/metrics/cluster/_supervised.py#L353&gt;`_</span>


<span class="sd">        :param np.ndarray x: 1D array representing the labels of the first model.</span>
<span class="sd">        :param np.ndarray y: 1D array representing the labels of the second model.</span>
<span class="sd">        :return float: A value of 1 indicates perfect clustering agreement, a value of 0 indicates random clustering, and negative values indicate disagreement between the clusterings.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([0, 0, 0, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; y = np.array([1, 1, 1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; Statistics.adjusted_rand(x=x, y=y)</span>
<span class="sd">        &gt;&gt;&gt; 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">adjusted_rand</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="n">min_axis_0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">adjusted_rand</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_true</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">labels_pred</span><span class="o">=</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.fowlkes_mallows"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.fowlkes_mallows">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">fowlkes_mallows</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Fowlkes-Mallows Index (FMI) between two clusterings.</span>

<span class="sd">        The Fowlkes-Mallows index (FMI) is a measure of similarity between two clusterings. It compares the similarity of the clusters obtained by two different clustering algorithms or procedures.</span>

<span class="sd">        The index is defined as the geometric mean of the pairwise precision and recall:</span>

<span class="sd">        .. math::</span>
<span class="sd">           FMI = \\sqrt{\\frac{TP}{TP + FP} \\times \\frac{TP}{TP + FN}}</span>

<span class="sd">        where:</span>
<span class="sd">        - TP (True Positive) is the number of pairs of elements that are in the same cluster in both x and y,</span>
<span class="sd">        - FP (False Positive) is the number of pairs of elements that are in the same cluster in y but not in x,</span>
<span class="sd">        - FN (False Negative) is the number of pairs of elements that are in the same cluster in x but not in y.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `scikit-learn &lt;https://github.com/scikit-learn/scikit-learn/blob/8721245511de2f225ff5f9aa5f5fadce663cd4a3/sklearn/metrics/cluster/_supervised.py#L1184&gt;`_</span>


<span class="sd">        :param np.ndarray x: 1D array representing the labels of the first model.</span>
<span class="sd">        :param np.ndarray y: 1D array representing the labels of the second model.</span>
<span class="sd">        :return float: Score between 0 and 1. 1 indicates perfect clustering agreement, 0 indicates random clustering.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">fowlkes_mallows</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="n">min_axis_0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">fowlkes_mallows</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fowlkes_mallows_score</span><span class="p">(</span><span class="n">labels_true</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">labels_pred</span><span class="o">=</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.adjusted_mutual_info"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.adjusted_mutual_info">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">adjusted_mutual_info</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Adjusted Mutual Information (AMI) between two clusterings as a measure of similarity.</span>

<span class="sd">        Calculates the Adjusted Mutual Information (AMI) between two sets of cluster labels.</span>
<span class="sd">        AMI measures the agreement between two clustering results, accounting for chance agreement.</span>
<span class="sd">        The value of AMI ranges from 0 (indicating no agreement) to 1 (perfect agreement).</span>

<span class="sd">        .. math::</span>

<span class="sd">           \text{AMI}(x, y) = \frac{\text{MI}(x, y) - E(\text{MI}(x, y))}{\max(H(x), H(y)) - E(\text{MI}(x, y))}</span>

<span class="sd">        where:</span>
<span class="sd">            - \text{MI}(x, y) \text{ is the mutual information between } x \text{ and } y.</span>
<span class="sd">            - E(\text{MI}(x, y)) \text{ is the expected mutual information.}</span>
<span class="sd">            - H(x) \text{ and } H(y) \text{ are the entropies of } x \text{ and } y, \text{ respectively.}</span>

<span class="sd">        :param np.ndarray x: 1D array representing the labels of the first model.</span>
<span class="sd">        :param np.ndarray y: 1D array representing the labels of the second model.</span>
<span class="sd">        :return float: Score between 0 and 1, where 1 indicates perfect clustering agreement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">adjusted_mutual_info</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="n">min_axis_0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">Statistics</span><span class="o">.</span><span class="n">adjusted_mutual_info</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
            <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">adjusted_mutual_info_score</span><span class="p">(</span><span class="n">labels_true</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">labels_pred</span><span class="o">=</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.czebyshev_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.czebyshev_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">czebyshev_distance</span><span class="p">(</span><span class="n">sample_1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Czebyshev distance between two N-dimensional samples.</span>

<span class="sd">        The Czebyshev distance is defined as the maximum absolute difference</span>
<span class="sd">        between the corresponding elements of the two arrays.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Normalize arrays sample_1 and sample_2 before passing it to ensure accurate results.</span>

<span class="sd">        .. math::</span>
<span class="sd">            D_\infty(p, q) = \max_i \left| p_i - q_i \right|</span>

<span class="sd">        :param np.ndarray sample_1: The first sample, an N-dimensional NumPy array.</span>
<span class="sd">        :param np.ndarray sample_2: The second sample, an N-dimensional NumPy array.</span>
<span class="sd">        :return float: The Czebyshev distance between the two samples.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.random.randint(0, 10, (10000,100))</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.random.randint(0, 10, (10000,100))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.czebyshev_distance(sample_1=sample_1, sample_2=sample_2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">sample_1</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sample_1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sample_2</span><span class="p">[</span><span class="n">idx</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Statistics.sliding_czebyshev_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sliding_czebyshev_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">([</span><span class="s2">&quot;(float32[:, :], float64[:], int64)&quot;</span><span class="p">,</span> <span class="p">])</span>
    <span class="k">def</span> <span class="nf">sliding_czebyshev_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the sliding Chebyshev distance for a given signal with different window sizes.</span>

<span class="sd">        This function computes the sliding Chebyshev distance for a signal `x` using</span>
<span class="sd">        different window sizes specified by `window_sizes`. The Chebyshev distance measures</span>
<span class="sd">        the maximum absolute difference between the corresponding elements of two signals.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Normalize array x before passing it to ensure accurate results.</span>

<span class="sd">        :param np.ndarray x: Input signal, a 2D array with shape (n_samples, n_features).</span>
<span class="sd">        :param np.ndarray window_sizes: Array containing window sizes for sliding computation.</span>
<span class="sd">        :param float sample_rate: Sampling rate of the signal.</span>
<span class="sd">        :return np.ndarray: 2D array of Chebyshev distances for each window size and position.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; sample_1 = np.random.randint(0, 10, (200,5)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sample_2 = np.random.randint(0, 10, (10000,100))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.sliding_czebyshev_distance(x=sample_1, window_sizes=np.array([1.0, 2.0]), sample_rate=10.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">sample</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">,</span> <span class="p">:],</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]))))</span>
                <span class="n">result</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Statistics.sokal_michener"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.sokal_michener">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">([</span><span class="s2">&quot;(int64[:], int64[:], float64[:])&quot;</span><span class="p">,</span> <span class="s2">&quot;(int64[:], int64[:], types.misc.Omitted(None))&quot;</span><span class="p">,</span>
           <span class="s2">&quot;(int64[:, :], int64[:, :], float64[:])&quot;</span><span class="p">,</span> <span class="s2">&quot;(int64[:, :], int64[:, :], types.misc.Omitted(None))&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">sokal_michener</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the Sokal-Michener dissimilarity between two binary vectors or matrices.</span>

<span class="sd">        Higher values indicate more dissimilar vectors or matrices, while lower values indicate more similar vectors or matrices.</span>

<span class="sd">        The Sokal-Michener dissimilarity is a measure of dissimilarity between two sets</span>
<span class="sd">        based on the presence or absence of similar attributes. This implementation supports weighted dissimilarity.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `umap &lt;https://github.com/lmcinnes/umap/blob/e7f2fb9e5e772edd5c8f38612365ec6a35a54373/umap/distances.py#L468&gt;`_.</span>

<span class="sd">        .. math::</span>
<span class="sd">           D(x, y) = \frac{2 \cdot \sum_{i} w_i \cdot \mathbb{1}(x_i \neq y_i)}{N + \sum_{i} w_i \cdot \mathbb{1}(x_i \neq y_i)}</span>

<span class="sd">        where:</span>
<span class="sd">        - :math:`x` and :math:`y` are the binary vectors or matrices.</span>
<span class="sd">        - :math:`w_i` is the weight for the i-th element.</span>
<span class="sd">        - :math:`\mathbb{1}(x_i \neq y_i)` is an indicator function that is 1 if :math:`x_i \neq y_i` and 0 otherwise.</span>
<span class="sd">        - :math:`N` is the total number of elements in :math:`x` or :math:`y`.</span>

<span class="sd">        :param np.ndarray x: First binary vector or matrix.</span>
<span class="sd">        :param np.ndarray y: Second binary vector or matrix.</span>
<span class="sd">        :param Optional[np.ndarray] w: Optional weight vector. If None, all weights are considered as 1.</span>
<span class="sd">        :return float: Sokal-Michener dissimilarity between `x` and `y`.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 2, (200,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 2, (200,))</span>
<span class="sd">        &gt;&gt;&gt; sokal_michener = Statistics.sokal_michener(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">unequal_cnt</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">x_i</span><span class="p">,</span> <span class="n">y_i</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_i</span> <span class="o">!=</span> <span class="n">y_i</span><span class="p">:</span>
                <span class="n">unequal_cnt</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">return</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">unequal_cnt</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">unequal_cnt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.kumar_hassebrook_similarity"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.kumar_hassebrook_similarity">[docs]</a>    <span class="k">def</span> <span class="nf">kumar_hassebrook_similarity</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Kumar-Hassebrook similarity is a measure used to quantify the similarity between two vectors.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Kumar-Hassebrook similarity score of 1 indicates identical vectors and 0 indicating no similarity</span>

<span class="sd">        :param np.ndarray x: 1D array representing the first feature values.</span>
<span class="sd">        :param np.ndarray y: 1D array representing the second feature values.</span>
<span class="sd">        :return: Kumar-Hassebrook similarity between vectors x and y.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x, y = np.random.randint(0, 500, (1000,)), np.random.randint(0, 500, (1000,))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.kumar_hassebrook_similarity(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">kumar_hassebrook_similarity</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">kumar_hassebrook_similarity</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">dot_product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">norm_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">norm_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dot_product</span> <span class="o">/</span> <span class="p">(</span><span class="n">norm_x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">norm_y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">dot_product</span><span class="p">)</span></div>

<div class="viewcode-block" id="Statistics.wave_hedges_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.wave_hedges_distance">[docs]</a>    <span class="k">def</span> <span class="nf">wave_hedges_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Computes the Wave-Hedges distance between two 1-dimensional arrays `x` and `y`. The Wave-Hedges distance is a measure of dissimilarity between arrays.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Wave-Hedges distance score of 0 indicate identical arrays. There is no upper bound.</span>


<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 500, (1000,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 500, (1000,))</span>
<span class="sd">        &gt;&gt;&gt; wave_hedges_distance(x=x, y=y)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">wave_hedges_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">wave_hedges_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">x_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">xy_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">x_y</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xy_max</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">x_y</span> <span class="o">/</span> <span class="n">xy_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>

<div class="viewcode-block" id="Statistics.gower_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.gower_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">gower_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Gower-like distance vector between corresponding rows of two numerical matrices.</span>
<span class="sd">        Gower distance is a measure of dissimilarity between two vectors (or rows in this case).</span>

<span class="sd">        .. note::</span>
<span class="sd">           This function assumes x and y have the same shape and only considers numerical attributes.</span>
<span class="sd">            Each observation in x is compared to the corresponding observation in y based on normalized</span>
<span class="sd">            absolute differences across numerical columns.</span>

<span class="sd">        :param np.ndarray x: First numerical matrix with shape (m, n).</span>
<span class="sd">        :param np.ndarray y: Second numerical matrix with shape (m, n).</span>
<span class="sd">        :return np.ndarray: Gower-like distance vector with shape (m,).</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x, y = np.random.randint(0, 500, (1000, 6000)), np.random.randint(0, 500, (1000, 6000))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.gower_distance(x=x, y=y)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">gower_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">gower_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">field_ranges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">field_ranges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dist</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">/</span> <span class="n">field_ranges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="Statistics.normalized_google_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.statistics_mixin.Statistics.normalized_google_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">normalized_google_distance</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute Normalized Google Distance (NGD) between two vectors or matrices.</span>

<span class="sd">        .. note::</span>
<span class="sd">           This function assumes x and y have the same shape. It computes NGD based on the sum of elements and the minimum values between corresponding elements of x and y.</span>

<span class="sd">        :param np.ndarray x: First numerical matrix with shape (m, n).</span>
<span class="sd">        :param np.ndarray y: Second array or matrix with shape (m, n).</span>
<span class="sd">        :return float:  Normalized Google Distance between x and y.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x, y = np.random.randint(0, 500, (1000,200)), np.random.randint(0, 500, (1000,200))</span>
<span class="sd">        &gt;&gt;&gt; Statistics.normalized_google_distance(x=y, y=x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">normalized_google_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> x&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">Statistics</span><span class="o">.</span><span class="n">normalized_google_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1"> y&#39;</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span> <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">sum_x</span><span class="p">,</span> <span class="n">sum_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">sum_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum_x</span> <span class="o">+</span> <span class="n">sum_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">sum_x</span><span class="p">,</span> <span class="n">sum_y</span><span class="p">])</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">sum_x</span><span class="p">,</span> <span class="n">sum_y</span><span class="p">])</span> <span class="o">-</span> <span class="n">sum_min</span>
        <span class="k">if</span> <span class="n">D</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">N</span> <span class="o">/</span> <span class="n">D</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, sronilsson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
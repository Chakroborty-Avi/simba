<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>simba.mixins.geometry_mixin &mdash; SimBA 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/simba_theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />

  
    <link rel="shortcut icon" href="../../../_static/readthedocs_logo.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SimBA
              <img src="../../../_static/readthedocs_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API REFERENCE:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NOTEBOOKS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks.html">Notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">USER GUIDE / TUTORIALS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">WALKTHROUGHS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../walkthroughs.html">Walkthroughs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">LABELLING TUTORIALS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../labelling.html">Labelling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials_rst/FAQ.html">Friendly Asked Questions (FAQ)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DOCS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/workflow.html">SimBA basic workflow</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ABOUT:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html#who-writes-this-stuff">Who writes this stuff??</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../links.html">Links</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SimBA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">simba.mixins.geometry_mixin</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for simba.mixins.geometry_mixin</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">platform</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">imutils</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="p">(</span><span class="n">GeometryCollection</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">,</span>
                              <span class="n">MultiPoint</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">linemerge</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">triangulate</span><span class="p">,</span> <span class="n">unary_union</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="kn">from</span> <span class="nn">simba.mixins.feature_extraction_mixin</span> <span class="kn">import</span> <span class="n">FeatureExtractionMixin</span>
<span class="kn">from</span> <span class="nn">simba.mixins.image_mixin</span> <span class="kn">import</span> <span class="n">ImageMixin</span>
<span class="kn">from</span> <span class="nn">simba.utils.checks</span> <span class="kn">import</span> <span class="p">(</span><span class="n">check_float</span><span class="p">,</span>
                                <span class="n">check_if_2d_array_has_min_unique_values</span><span class="p">,</span>
                                <span class="n">check_if_dir_exists</span><span class="p">,</span> <span class="n">check_if_valid_img</span><span class="p">,</span>
                                <span class="n">check_if_valid_input</span><span class="p">,</span> <span class="n">check_if_valid_rgb_tuple</span><span class="p">,</span>
                                <span class="n">check_instance</span><span class="p">,</span> <span class="n">check_int</span><span class="p">,</span>
                                <span class="n">check_iterable_length</span><span class="p">,</span> <span class="n">check_str</span><span class="p">,</span>
                                <span class="n">check_that_column_exist</span><span class="p">,</span> <span class="n">check_valid_array</span><span class="p">,</span>
                                <span class="n">check_valid_boolean</span><span class="p">,</span> <span class="n">check_valid_lst</span><span class="p">,</span>
                                <span class="n">check_valid_tuple</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">simba.utils.data</span> <span class="kn">import</span> <span class="n">create_color_palette</span><span class="p">,</span> <span class="n">create_color_palettes</span>
<span class="kn">from</span> <span class="nn">simba.utils.enums</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Defaults</span><span class="p">,</span> <span class="n">Formats</span><span class="p">,</span> <span class="n">GeometryEnum</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span>
                               <span class="n">TextOptions</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">simba.utils.errors</span> <span class="kn">import</span> <span class="n">CountError</span><span class="p">,</span> <span class="n">InvalidInputError</span>
<span class="kn">from</span> <span class="nn">simba.utils.read_write</span> <span class="kn">import</span> <span class="p">(</span><span class="n">SimbaTimer</span><span class="p">,</span> <span class="n">find_core_cnt</span><span class="p">,</span>
                                    <span class="n">find_max_vertices_coordinates</span><span class="p">,</span> <span class="n">read_df</span><span class="p">,</span>
                                    <span class="n">read_frm_of_video</span><span class="p">,</span> <span class="n">stdout_success</span><span class="p">)</span>


<div class="viewcode-block" id="GeometryMixin"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin">[docs]</a><span class="k">class</span> <span class="nc">GeometryMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Methods to perform geometry transformation of pose-estimation data. This includes creating bounding boxes,</span>
<span class="sd">    line objects, circles etc. from pose-estimated body-parts and computing metric representations</span>
<span class="sd">    of the relationships between created shapes or their attributes (sizes, distances etc.).</span>

<span class="sd">    As of 01/24, very much wip and relies heavily on `shapley &lt;https://shapely.readthedocs.io/en/stable/manual.html&gt;`_.</span>

<span class="sd">    .. note::</span>
<span class="sd">       These methods generally do not create visualizations - they mainly generate geometry data-objects or metrics.</span>
<span class="sd">       To create visualizations with geometries overlay on videos, pass returned shapes to `simba.plotting.geometry_plotter.GeometryPlotter`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Darwin&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">get_start_method</span><span class="p">(</span><span class="n">allow_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="n">multiprocessing</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="s2">&quot;fork&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="GeometryMixin.bodyparts_to_polygon"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bodyparts_to_polygon">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bodyparts_to_polygon</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                             <span class="n">cap_style</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;round&quot;</span><span class="p">,</span>
                             <span class="n">parallel_offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                             <span class="n">simplify_tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">preserve_topology</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>


<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. note::</span>
<span class="sd">           To convert multiple frame body-part coordinates to polygon, use ``simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodyparts_to_polygon``</span>

<span class="sd">        .. image:: _static/img/bodyparts_to_polygon.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: 3D array with body-part coordinates where rows are frames and columns are x and y coordinates.</span>
<span class="sd">        :param Literal[&quot;round&quot;, &quot;square&quot;, &quot;flat&quot;] cap_style: How intersections between lines are handled in the polygon. Default: round.</span>
<span class="sd">        :param int parallel_offset: How much to &quot;buffer&quot; the polygon from the original size in millimeters. Default: 1.</span>
<span class="sd">        :param int pixels_per_mm: The pixels per millimeter conversion factor used for buffering. Default: 1.</span>
<span class="sd">        :param float simplify_tolerance: The higher this value, the smaller the number of vertices in the resulting polygon. Default 2.</span>
<span class="sd">        :param bool preserve_topology: If True, operation will avoid creating invalid geometries (checking for collapses, ring-intersections, etc). Deafult True.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = [[[364, 308],[383, 323],[403, 335], [423, 351]]]</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().bodyparts_to_polygon(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cap style&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">cap_style</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">GeometryEnum</span><span class="o">.</span><span class="n">CAP_STYLE_MAP</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> parallel_offset&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> pixels_per_mm&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> simplify_tolerance&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">simplify_tolerance</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">parallel_offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parallel_offset</span> <span class="o">/</span> <span class="n">pixels_per_mm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_if_2d_array_has_min_unique_values</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">min</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Polygon</span><span class="p">(</span>
                        <span class="n">LineString</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                        <span class="o">.</span><span class="n">buffer</span><span class="p">(</span>
                            <span class="n">distance</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                            <span class="n">cap_style</span><span class="o">=</span><span class="n">GeometryEnum</span><span class="o">.</span><span class="n">CAP_STYLE_MAP</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">cap_style</span><span class="p">],</span>
                        <span class="p">)</span>
                        <span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
                            <span class="n">tolerance</span><span class="o">=</span><span class="n">simplify_tolerance</span><span class="p">,</span>
                            <span class="n">preserve_topology</span><span class="o">=</span><span class="n">preserve_topology</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="o">.</span><span class="n">convex_hull</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.bodyparts_to_points"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bodyparts_to_points">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bodyparts_to_points</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">px_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert body-parts coordinate to Point geometries.</span>

<span class="sd">        :param np.ndarray data: 2D array with body-part coordinates where rows are frames and columns are x and y coordinates.</span>
<span class="sd">        :param Optional[int] buffer: If not None, then the area of the Point. Thus, if not None, then returns Polygons representing the Points.</span>
<span class="sd">        :param Optional[int] px_per_mm: Pixels to millimeter convertion factor. Required if buffer is not None.</span>

<span class="sd">        .. note:</span>
<span class="sd">           If buffer and px_per_mm is not None, then the points will be *buffered* and a 2D share polygon created with the specified buffered area.</span>
<span class="sd">           If buffer is provided, then also provide px_per_mm for accurate convesion factor between pixels and millimeters.</span>

<span class="sd">           If having a large number of body-parts, consider using ``simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodypart_to_point``</span>
<span class="sd">           which uses CPU multiprocessing.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (1, 2))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().bodyparts_to_points(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_points</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="n">area</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_points</span><span class="si">}</span><span class="s2"> buffer&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_points</span><span class="si">}</span><span class="s2"> px_per_mm&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">/</span> <span class="n">px_per_mm</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">area</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">area</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.to_linestring"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.to_linestring">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">to_linestring</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LineString</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a 2D array of x and y coordinates to a shapely linestring.</span>

<span class="sd">        Linestrings are useful for representing an animal path, and to answer questions like (i)</span>
<span class="sd">        &quot;How far along the animals paths was the animal most proximal to geometry X&quot;?</span>
<span class="sd">        &quot;How far had the animal travelled at time T?&quot;</span>
<span class="sd">        &quot;When does the animal path intersect geometry X?&quot;</span>

<span class="sd">        :param np.ndarray data: 2D array with floats or ints of size Nx2 representing body-part coordinates.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.load(&#39;/Users/simon/Desktop/envs/simba/simba/simba/sandbox/data.npy&#39;)</span>
<span class="sd">        &gt;&gt;&gt; linestring = GeometryMixin.to_linestring(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">to_linestring</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">LineString</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.bodyparts_to_circle"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bodyparts_to_circle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bodyparts_to_circle</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">parallel_offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a circle geometry from a single body-part (x,y) coordinate.</span>

<span class="sd">        .. note::</span>
<span class="sd">           For multiple frames, call this method using :func:`~simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodyparts_to_circle`</span>

<span class="sd">        .. image:: _static/img/bodyparts_to_circle.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/bodyparts_to_circle.gif</span>
<span class="sd">           :width: 450</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: The body-part coordinate xy as a 1d array. E.g., np.array([364, 308])</span>
<span class="sd">        :param float parallel_offset: The radius of the resultant circle in millimeters.</span>
<span class="sd">        :param int pixels_per_mm: The pixels per millimeter of the video. If not passed, 1 will be used meaning revert to radius in pixels rather than millimeters.</span>
<span class="sd">        :returns Polygon: Shapely Polygon of curcular shape.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([364, 308])</span>
<span class="sd">        &gt;&gt;&gt; polygon = GeometryMixin().bodyparts_to_circle(data=data, parallel_offset=10, pixels_per_mm=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">]),</span> <span class="n">accepted_dtypes</span><span class="o">=</span><span class="n">Formats</span><span class="o">.</span><span class="n">NUMERIC_DTYPES</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">max_axis_1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_circle</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> parallel_offset&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_circle</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> pixels_per_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">parallel_offset</span> <span class="o">/</span> <span class="n">pixels_per_mm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">parallel_offset</span> <span class="o">/</span> <span class="n">pixels_per_mm</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.bodyparts_to_multistring_skeleton"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bodyparts_to_multistring_skeleton">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bodyparts_to_multistring_skeleton</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MultiLineString</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a multistring skeleton from a 3d array where each 2d array represents start and end coordinates of a line</span>
<span class="sd">        within the skeleton.</span>

<span class="sd">        :param np.ndarray data: A 3D numpy array where each 2D array represents the start position and end position of each LineString.</span>
<span class="sd">        :returns MultiLineString: Shapely MultiLineString representing animal skeleton.</span>

<span class="sd">        .. image:: _static/img/bodyparts_to_multistring_skeleton.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/bodyparts_to_multistring_skeleton.gif</span>
<span class="sd">           :width: 450</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; skeleton = np.array([[[5, 5], [1, 10]], [[5, 5], [9, 10]], [[9, 10], [1, 10]], [[9, 10], [9, 25]], [[1, 10], [1, 25]], [[9, 25], [5, 50]], [[1, 25], [5, 50]]])</span>
<span class="sd">        &gt;&gt;&gt; shape_multistring = GeometryMixin().bodyparts_to_multistring_skeleton(data=skeleton)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Body-parts to skeleton expects a 3D array, got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                    <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">shape_skeleton</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">shape_skeleton</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
        <span class="n">shape_skeleton</span> <span class="o">=</span> <span class="n">linemerge</span><span class="p">(</span><span class="n">MultiLineString</span><span class="p">(</span><span class="n">shape_skeleton</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">shape_skeleton</span></div>

<div class="viewcode-block" id="GeometryMixin.buffer_shape"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.buffer_shape">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">buffer_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">],</span>
                     <span class="n">size_mm</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">cap_style</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;round&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a buffered shape by applying a buffer operation to the input polygon or linestring.</span>

<span class="sd">        .. image:: _static/img/buffer_shape.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param Union[Polygon, LineString] shape: The input Polygon or LineString to be buffered.</span>
<span class="sd">        :param int size_mm: The size of the buffer in millimeters. Use a negative value for an inward buffer.</span>
<span class="sd">        :param float pixels_per_mm: The conversion factor from millimeters to pixels.</span>
<span class="sd">        :param Literal[&#39;round&#39;, &#39;square&#39;, &#39;flat&#39;] cap_style: The cap style for the buffer. Valid values are &#39;round&#39;, &#39;square&#39;, or &#39;flat&#39;. Defaults to &#39;round&#39;.</span>
<span class="sd">        :return Polygon: The buffered shape.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon = GeometryMixin().bodyparts_to_polygon(np.array([[100, 110],[100, 100],[110, 100],[110, 110]]))</span>
<span class="sd">        &gt;&gt;&gt; buffered_polygon = GeometryMixin().buffer_shape(shape=polygon, size_mm=-1, pixels_per_mm=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">buffer_shape</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;BUFFER SHAPE size_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">size_mm</span><span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;BUFFER SHAPE pixels_per_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">size_mm</span> <span class="o">/</span> <span class="n">pixels_per_mm</span><span class="p">),</span> <span class="n">cap_style</span><span class="o">=</span><span class="n">GeometryEnum</span><span class="o">.</span><span class="n">CAP_STYLE_MAP</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">cap_style</span><span class="p">])</span></div>

<div class="viewcode-block" id="GeometryMixin.compute_pct_shape_overlap"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.compute_pct_shape_overlap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_pct_shape_overlap</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">denominator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">,</span> <span class="s2">&quot;shape_1&quot;</span><span class="p">,</span> <span class="s2">&quot;shape_2&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;difference&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the percentage of overlap between two shapes.</span>

<span class="sd">        .. image:: _static/img/compute_pct_shape_overlap.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[Union[LineString, Polygon]] shapes: A 2D array, where each sub-array has two Polygon or LineString shapes.</span>
<span class="sd">        :param Optional[Literal[&#39;union&#39;, &#39;shape_1&#39;, &#39;shape_2&#39;]] denominator: If ``difference``, then percent overlap is calculated using non-intersection area as denominator. If ``shape_1``, percent overlap is calculated using the area of the first shape as denominator. If ``shape_2``, percent overlap is calculated using the area of the second shape as denominator. Default: ``difference``.</span>
<span class="sd">        :return float: The percentage of overlap between the two shapes as integer.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[364, 308],[383, 323],[403, 335],[423, 351]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[356, 307],[376, 319],[396, 331],[419, 347]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = [polygon_1 for x in range(100)]</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = [polygon_2 for x in range(100)]</span>
<span class="sd">        &gt;&gt;&gt; data = np.column_stack((polygon_1, polygon_2))</span>
<span class="sd">        &gt;&gt;&gt; results = GeometryMixin.compute_pct_shape_overlap(shapes=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">compute_pct_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
            <span class="n">max_axis_1</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">min_axis_0</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">shapes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">intersection</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="s2">&quot;difference&quot;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">intersection</span><span class="o">.</span><span class="n">area</span>
                            <span class="o">/</span> <span class="p">(</span>
                                <span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">+</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
                                <span class="o">-</span> <span class="n">intersection</span><span class="o">.</span><span class="n">area</span>
                            <span class="p">)</span>
                            <span class="o">*</span> <span class="mi">100</span>
                        <span class="p">),</span>
                        <span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">denominator</span> <span class="o">==</span> <span class="s2">&quot;shape_1&quot;</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">intersection</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">2</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.compute_shape_overlap"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.compute_shape_overlap">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_shape_overlap</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes if two geometrical shapes (Polygon or LineString) overlaps or are disjoint.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Only returns if two shapes are overlapping or not overlapping. If the amount of overlap is required, use</span>
<span class="sd">           ``GeometryMixin().compute_shape_overlap()``.</span>

<span class="sd">        .. image:: _static/img/compute_overlap.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[Union[LineString, Polygon]] shapes: A list of two input Polygon or LineString shapes.</span>
<span class="sd">        :return float: Returns 1 if the two shapes overlap, otherwise returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">compute_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">compute_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span>
            <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="GeometryMixin.crosses"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.crosses">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">crosses</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">LineString</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if two LineString objects cross each other.</span>

<span class="sd">        .. image:: _static/img/are_lines_crossing.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[LineString] shapes: A list containing two LineString objects.</span>
<span class="sd">        :return bool: True if the LineStrings cross each other, False otherwise.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; line_1 = GeometryMixin().bodyparts_to_line(np.array([[10, 10],[20, 10],[30, 10],[40, 10]]))</span>
<span class="sd">        &gt;&gt;&gt; line_2 = GeometryMixin().bodyparts_to_line(np.array([[25, 5],[25, 20],[25, 30],[25, 40]]))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().crosses(shapes=[line_1, line_2])</span>
<span class="sd">        &gt;&gt;&gt; True</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">crosses</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span>
            <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">crosses</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="n">LineString</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">crosses</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="GeometryMixin.is_shape_covered"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.is_shape_covered">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_shape_covered</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if one geometry fully covers another.</span>

<span class="sd">        .. image:: _static/img/is_line_covered.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param Union[LineString, Polygon, MultiPolygon, MultiPoint] shapes: List of 2 geometries, checks if the second geometry fully covers the first geometry.</span>
<span class="sd">        :return bool: True if the second geometry fully covers the first geometry, otherwise False.</span>

<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[10, 10], [10, 100], [100, 10], [100, 100]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[25, 25], [25, 75], [90, 25], [90, 75]]))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().is_shape_covered(shapes=[polygon_2, polygon_1])</span>
<span class="sd">        &gt;&gt;&gt; True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_lst</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">is_shape_covered</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">),</span>
            <span class="n">exact_len</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">covers</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="GeometryMixin.area"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.area">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">],</span> <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the area of a geometry in square millimeters.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If certain that the input data is a valid Polygon, consider using :func:`simba.feature_extractors.perimeter_jit.jitted_hull`</span>

<span class="sd">        :param Union[MultiPolygon, Polygon] shape: The geometry (MultiPolygon or Polygon) for which to calculate the area.</span>
<span class="sd">        :param float pixels_per_mm: The pixel-to-millimeter conversion factor.</span>
<span class="sd">        :return float: The area of the geometry in square millimeters.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon = GeometryMixin().bodyparts_to_polygon(np.array([[10, 10], [10, 100], [100, 10], [100, 100]]))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().area(shape=polygon, pixels_per_mm=4.9)</span>
<span class="sd">        &gt;&gt;&gt; 1701.556313816644</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shape&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">area</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shape&quot;</span><span class="p">,</span><span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span><span class="n">min_value</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">shape</span><span class="o">.</span><span class="n">area</span> <span class="o">/</span> <span class="n">pixels_per_mm</span></div>

<div class="viewcode-block" id="GeometryMixin.shape_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.shape_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">shape_distance</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">]],</span> <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">unit</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the distance between two geometries in specified units.</span>

<span class="sd">        :param List[Union[LineString, Polygon]] shapes: A list containing two LineString or Polygon geometries.</span>
<span class="sd">        :param float pixels_per_mm: The conversion factor from pixels to millimeters.</span>
<span class="sd">        :param Literal[&#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;] unit: The desired unit for the distance calculation. Options: &#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;. Defaults to &#39;mm&#39;.</span>
<span class="sd">        :return float: The distance between the two geometries in the specified unit.</span>

<span class="sd">        .. image:: _static/img/shape_distance.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        &gt;&gt;&gt; shape_1 = Polygon([(0, 0), 10, 10), 0, 10), 10, 0)])</span>
<span class="sd">        &gt;&gt;&gt; shape_2 = Polygon([(0, 0), 10, 10), 0, 10), 10, 0)])</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin.shape_distance(shapes=[shape_1, shape_2], pixels_per_mm=1)</span>
<span class="sd">        &gt;&gt;&gt; 0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_if_valid_input</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;UNIT&quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">shape_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">shape_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span>
            <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">D</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">pixels_per_mm</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;cm&quot;</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;dm&quot;</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="mi">100</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="k">return</span> <span class="n">D</span></div>

<div class="viewcode-block" id="GeometryMixin.bodyparts_to_line"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bodyparts_to_line">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bodyparts_to_line</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">px_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert body-part coordinates to a Linestring.</span>

<span class="sd">        .. note::</span>
<span class="sd">          If buffer and px_per_mm is provided, then the returned object will be linestring buffered to a 2D object rectangle</span>
<span class="sd">          with specificed area.</span>

<span class="sd">        .. image:: _static/img/bodyparts_to_line.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([[364, 308],[383, 323], [403, 335],[423, 351]])</span>
<span class="sd">        &gt;&gt;&gt; line = GeometryMixin().bodyparts_to_line(data=data)</span>
<span class="sd">        &gt;&gt;&gt; line = GeometryMixin().bodyparts_to_line(data=data, buffer=10, px_per_mm=4)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_int</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="si">}</span><span class="s2"> buffer&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="si">}</span><span class="s2"> px_per_mm&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">*</span> <span class="n">px_per_mm</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Body-parts to linestring expects a 2D array, got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LineString</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LineString</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.get_center"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.get_center">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_center</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the center coordinate of a shape or a list of shapes.</span>


<span class="sd">        .. image:: _static/img/get_center.png</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; multipolygon = MultiPolygon([Polygon([[200, 110],[200, 100],[200, 100],[200, 110]]), Polygon([[70, 70],[70, 60],[10, 50],[1, 70]])])</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().get_center(shape=multipolygon)</span>
<span class="sd">        &gt;&gt;&gt; [33.96969697, 62.32323232]</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">get_center</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">check_valid_lst</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">get_center</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,),</span> <span class="n">min_len</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">results</span>



        <span class="k">return</span></div>

<div class="viewcode-block" id="GeometryMixin.is_touching"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.is_touching">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_touching</span><span class="p">(</span><span class="n">shapes</span><span class="o">=</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if two geometries touch each other.</span>

<span class="sd">        .. image:: _static/img/touches.png</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. note::</span>
<span class="sd">           Different from GeometryMixin().crosses: Touches requires a common boundary, and does not require the sharing of interior space.</span>

<span class="sd">        :param List[Union[LineString, Polygon]] shapes: A list containing two LineString or Polygon geometries.</span>
<span class="sd">        :return bool: True if the geometries touch each other, False otherwise.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; rectangle_1 = Polygon(np.array([[0, 0], [10, 10], [0, 10], [10, 0]]))</span>
<span class="sd">        &gt;&gt;&gt; rectangle_2 = Polygon(np.array([[20, 20], [30, 30], [20, 30], [30, 20]]))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().is_touching(shapes=[rectangle_1, rectangle_2])</span>
<span class="sd">        &gt;&gt;&gt; False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">is_touching</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">is_touching</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span>
            <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">touches</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="GeometryMixin.is_containing"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.is_containing">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_containing</span><span class="p">(</span><span class="n">shapes</span><span class="o">=</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the first shape in a list contains a second shape in a list.</span>

<span class="sd">        .. image:: _static/img/is_containing.png</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">is_containing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">is_containing</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span>
            <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="GeometryMixin.difference"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.difference">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="n">shapes</span><span class="o">=</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the difference between a shape and one or more potentially overlapping shapes.</span>

<span class="sd">        .. image:: _static/img/difference.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/difference_1.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[Union[LineString, Polygon, MultiPolygon]] shapes: A list of geometries.</span>
<span class="sd">        :return: The first geometry in ``shapes`` is returned where all parts that overlap with the other geometries in ``shapes have been removed.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[10, 10], [10, 100], [100, 10], [100, 100]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[25, 25],[25, 75],[90, 25],[90, 75]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_3 = GeometryMixin().bodyparts_to_polygon(np.array([[1, 25],[1, 75],[110, 25],[110, 75]]))</span>
<span class="sd">        &gt;&gt;&gt; difference = GeometryMixin().difference(shapes = [polygon_1, polygon_2, polygon_3])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">difference</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">difference</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">overlap_shap</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">overlap_shap</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">overlap_shap</span><span class="o">.</span><span class="n">geoms</span><span class="p">:</span>
                    <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">geo</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">overlap_shap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.union"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.union">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the union of multiple geometries.</span>

<span class="sd">        .. image:: _static/img/union.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[Union[LineString, Polygon, MultiPolygon]] shapes: A list of LineString, Polygon, or MultiPolygon geometries to be unioned.</span>
<span class="sd">        :return Union[MultiPolygon, Polygon]: The resulting geometry after performing the union operation.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[10, 10], [10, 100], [100, 10], [100, 100]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[1, 25],[1, 75],[110, 25],[110, 75]]))</span>
<span class="sd">        &gt;&gt;&gt; union = GeometryMixin().union(shape = polygon_1, overlap_shapes=[polygon_2, polygon_2])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">union</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">union</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">unary_union</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.symmetric_difference"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.symmetric_difference">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a new geometry consisting of the parts that are exclusive to each input geometry.</span>

<span class="sd">        In other words, it includes the parts that are unique to each geometry while excluding the parts that are common to both.</span>

<span class="sd">        .. image:: _static/img/symmetric_difference.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[Union[LineString, Polygon, MultiPolygon]] shapes: A list of LineString, Polygon, or MultiPolygon geometries to find the symmetric difference.</span>
<span class="sd">        :return List[Union[Polygon, MultiPolygon]]: A list containing the resulting geometries after performing symmetric difference operations.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[10, 10], [10, 100], [100, 10], [100, 100]]))</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[1, 25], [1, 75], [110, 25], [110, 75]]))</span>
<span class="sd">        &gt;&gt;&gt; symmetric_difference = symmetric_difference(shapes=[polygon_1, polygon_2])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_iterable_length</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">union</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">))),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometry</span> <span class="k">for</span> <span class="n">geometry</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">geometry</span><span class="o">.</span><span class="n">is_empty</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.view_shapes"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.view_shapes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">view_shapes</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]],</span>
                    <span class="n">bg_img</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">bg_clr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">color_palette</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Set1&#39;</span><span class="p">,</span>
                    <span class="n">thickness</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">pixel_buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to draw shapes on white canvas or specified background image. Useful for quick troubleshooting.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; multipolygon_1 = MultiPolygon([Polygon([[200, 110],[200, 100],[200, 100],[200, 110]]), Polygon([[70, 70],[70, 60],[10, 50],[1, 70]])])</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[100, 110],[100, 100],[110, 100],[110, 110]]))</span>
<span class="sd">        &gt;&gt;&gt; line_1 = GeometryMixin().bodyparts_to_line(np.array([[10, 70],[20, 60],[30, 50],[40, 70]]))</span>
<span class="sd">        &gt;&gt;&gt; img = GeometryMixin.view_shapes(shapes=[line_1, polygon_1, multipolygon_1])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_lst</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">view_shapes</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                        <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">,</span> <span class="n">Point</span><span class="p">),</span> <span class="n">min_len</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;pixel_buffer&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixel_buffer</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">max_vertices</span> <span class="o">=</span> <span class="n">find_max_vertices_coordinates</span><span class="p">(</span><span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">pixel_buffer</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bg_img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bg_clr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">max_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">check_if_valid_rgb_tuple</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">bg_clr</span><span class="p">)</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">max_vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">bg_clr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">bg_img</span>

        <span class="k">if</span> <span class="n">color_palette</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_str</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;color_palette&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span>
                      <span class="n">options</span><span class="o">=</span><span class="n">Options</span><span class="o">.</span><span class="n">PALETTE_OPTIONS_CATEGORICAL</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">Options</span><span class="o">.</span><span class="n">PALETTE_OPTIONS</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">create_color_palette</span><span class="p">(</span><span class="n">pallete_name</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span> <span class="n">increments</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">shape_cnt</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                              <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
                <span class="n">interior_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interior</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">interior</span> <span class="ow">in</span>
                                   <span class="n">shape</span><span class="o">.</span><span class="n">interiors</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">interior</span> <span class="ow">in</span> <span class="n">interior_coords</span><span class="p">:</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">[</span><span class="n">interior</span><span class="p">],</span> <span class="n">isClosed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                  <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">color_palette</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                  <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">palette</span> <span class="o">=</span> <span class="n">create_color_palette</span><span class="p">(</span><span class="n">pallete_name</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span> <span class="n">increments</span><span class="o">=</span><span class="n">lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p1</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p2</span><span class="p">),</span> <span class="n">palette</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">thickness</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                <span class="n">multi_polygon_clrs</span> <span class="o">=</span> <span class="n">create_color_palette</span><span class="p">(</span><span class="n">pallete_name</span><span class="o">=</span><span class="n">color_palette</span><span class="p">,</span> <span class="n">increments</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">geoms</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">polygon_cnt</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">geoms</span><span class="p">):</span>
                    <span class="n">polygon_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">polygon</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">[</span><span class="n">polygon_np</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="n">multi_polygon_clrs</span><span class="p">[</span><span class="n">polygon_cnt</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">line_cnt</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">geoms</span><span class="p">):</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">line_cnt</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span>
                                  <span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">shape</span><span class="o">.</span><span class="n">coords</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">colors</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">thickness</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">imutils</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">img</span></div>

<div class="viewcode-block" id="GeometryMixin.geometry_video"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.geometry_video">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">geometry_video</span><span class="p">(</span><span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">]]],</span>
                       <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
                       <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">fps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                       <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">bg_img</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">bg_clr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">thickness</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper to create a geometry video from a list of shapes.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If more aesthetic videos are needed, overlaid on video, then use ``simba.plotting.geometry_plotter.GeometryPlotter``</span>
<span class="sd">           If single images of geometries are needed, then use ``simba.mixins.geometry_mixin.view_shapes``</span>

<span class="sd">        .. image:: _static/img/geometry_video.gif</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[List[Union[LineString, Polygon, MultiPolygon, MultiPoint, MultiLineString]]] shapes: List of lists containing geometric shapes to be included in the video. Each sublist represents a frame, and each element within the sublist represents a shape for that frame.</span>
<span class="sd">        :param Union[str, os.PathLike] save_path: Path where the resulting video will be saved.</span>
<span class="sd">        :param Optional[Tuple[int]] size: Tuple specifying the size of the output video in pixels (width, height).</span>
<span class="sd">        :param Optional[int] fps: Frames per second of the output video. Defaults to 10.</span>
<span class="sd">        :param Optional[bool] verbose: If True, then prints progress frmae-by-frame. Default: False.</span>
<span class="sd">        :param Optional[np.ndarray] bg_img: Background image to be used as the canvas for drawing shapes. Defaults to None. Could be e.g., a low opacity image of the arena.</span>
<span class="sd">        :param Optional[Tuple[int]] bg_clr: Background color specified as a tuple of RGB values. Defaults to white.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">geometry_video</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">,</span> <span class="n">Point</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_if_dir_exists</span><span class="p">(</span><span class="n">in_dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">save_path</span><span class="p">))</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;fps&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bg_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_if_valid_img</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">bg_img</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">geometry_video</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bg_clr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_if_valid_rgb_tuple</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">bg_clr</span><span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">geometry_video</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Size has to be 2 values, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">geometry_video</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">size</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">geometry_video</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">bg_img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bg_clr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">bg_clr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">bg_img</span>
        <span class="n">clrs</span> <span class="o">=</span> <span class="n">create_color_palettes</span><span class="p">(</span><span class="n">no_animals</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span> <span class="n">map_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fourcc</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoWriter_fourcc</span><span class="p">(</span><span class="o">*</span><span class="n">Formats</span><span class="o">.</span><span class="n">MP4_CODEC</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">video_writer</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoWriter</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">fourcc</span><span class="p">,</span> <span class="n">fps</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">frm_cnt</span><span class="p">,</span> <span class="n">frm_shapes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)):</span>
            <span class="n">frm_img</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">shape_cnt</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frm_shapes</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">):</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)],</span> <span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
                    <span class="n">interior_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interior</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">interior</span> <span class="ow">in</span> <span class="n">shape</span><span class="o">.</span><span class="n">interiors</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">interior</span> <span class="ow">in</span> <span class="n">interior_coords</span><span class="p">:</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">[</span><span class="n">interior</span><span class="p">],</span> <span class="n">isClosed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">,)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">LineString</span><span class="p">):</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">polygon_cnt</span><span class="p">,</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">geoms</span><span class="p">):</span>
                        <span class="n">polygon_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">polygon</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">[</span><span class="n">polygon_np</span><span class="p">],</span> <span class="kc">True</span><span class="p">,</span> <span class="p">(</span><span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span> <span class="o">+</span> <span class="n">polygon_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">line_cnt</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">geoms</span><span class="p">):</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="n">line_cnt</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)],</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">thickness</span><span class="o">=</span><span class="n">thickness</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">MultiPoint</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
                        <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">centroid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="o">.</span><span class="n">centroid</span><span class="p">)[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">thickness</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
                    <span class="n">cv2</span><span class="o">.</span><span class="n">circle</span><span class="p">(</span><span class="n">frm_img</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">centroid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">centroid</span><span class="p">)[</span><span class="mi">1</span><span class="p">])),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">clrs</span><span class="p">[</span><span class="n">shape_cnt</span><span class="p">][</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">thickness</span><span class="p">)</span>
            <span class="n">video_writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">frm_img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Geometry frame complete (</span><span class="si">{</span><span class="n">frm_cnt</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">video_writer</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Video complete and saved at </span><span class="si">{</span><span class="n">save_path</span><span class="si">}</span><span class="s2">!&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Video complete!&quot;</span>
        <span class="n">stdout_success</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="n">msg</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">geometry_video</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.minimum_rotated_rectangle"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.minimum_rotated_rectangle">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">minimum_rotated_rectangle</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">Polygon</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Polygon</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the minimum rotated rectangle that bounds a given polygon.</span>

<span class="sd">        The minimum rotated rectangle, also known as the minimum bounding rectangle (MBR) or oriented bounding box (OBB), is the smallest rectangle that can fully contain a given polygon or set of points while allowing rotation. It is defined by its center, dimensions (length and width), and rotation angle.</span>

<span class="sd">        .. image:: _static/img/minimum_rotated_rectangle.png</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param Polygon shape: The Polygon for which the minimum rotated rectangle is to be calculated.</span>
<span class="sd">        :return Polygon: The minimum rotated rectangle geometry that bounds the input polygon.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygon = GeometryMixin().bodyparts_to_polygon(np.array([[364, 308],[383, 323],[403, 335],[423, 351]]))</span>
<span class="sd">        &gt;&gt;&gt; rectangle = GeometryMixin().minimum_rotated_rectangle(shape=polygon)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">minimum_rotated_rectangle</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="n">Polygon</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">rotated_rectangle</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">minimum_rotated_rectangle</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotated_rectangle</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Polygon</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rotated_rectangle</span></div>

<div class="viewcode-block" id="GeometryMixin.length"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.length">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">],</span>
               <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
               <span class="n">unit</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the length of a LineString geometry.</span>

<span class="sd">        .. image:: _static/img/length.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param LineString shape: The LineString geometry for which the length is to be calculated.</span>
<span class="sd">        :param Literal[&#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;] unit: The desired unit for the length measurement (&#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;).</span>
<span class="sd">        :return float: The length of the LineString geometry in the specified unit.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; line_1 = GeometryMixin().bodyparts_to_line(np.array([[10, 70],[20, 60],[30, 50],[40, 70]]))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().length(shape=line_1, pixels_per_mm=1.0)</span>
<span class="sd">        &gt;&gt;&gt; 50.6449510224598</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;line_length pixels_per_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="n">LineString</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="n">pixels_per_mm</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;cm&quot;</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">10</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;dm&quot;</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">100</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span> <span class="o">/</span> <span class="mi">1000</span>

        <span class="k">return</span> <span class="n">L</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_bodyparts_to_polygon"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodyparts_to_polygon">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_bodyparts_to_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                        <span class="n">video_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">animal_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                        <span class="n">cap_style</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="s2">&quot;square&quot;</span><span class="p">,</span> <span class="s2">&quot;flat&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;round&quot;</span><span class="p">,</span>
                                        <span class="n">parallel_offset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                        <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">simplify_tolerance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                                        <span class="n">preserve_topology</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                        <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert multidimensional NumPy array representing body part coordinates to a list of Polygons.</span>

<span class="sd">        .. note::</span>
<span class="sd">           To convert single frame animal body-part coordinates to polygon, use ``simba.mixins.geometry_mixin.GeometryMixin.bodyparts_to_polygon``</span>

<span class="sd">        :param np.ndarray data: NumPy array of body part coordinates. Each subarray represents the coordinates of a body part.</span>
<span class="sd">        :param Literal[&#39;round&#39;, &#39;square&#39;, &#39;flat&#39;] cap_style: Style of line cap for parallel offset. Options: &#39;round&#39;, &#39;square&#39;, &#39;flat&#39;.</span>
<span class="sd">        :param int parallel_offset: Offset distance for parallel lines. Default is 1.</span>
<span class="sd">        :param float simplify_tolerance: Tolerance parameter for simplifying geometries. Default is 2.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([[[364, 308], [383, 323], [403, 335], [423, 351]],[[356, 307], [376, 319], [396, 331], [419, 347]]])</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().multiframe_bodyparts_to_polygon(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_bodyparts_to_polygon</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">pixels_per_mm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;PIXELS PER MM&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
                <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">parallel_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">parallel_offset</span> <span class="o">*</span> <span class="n">pixels_per_mm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parallel_offset</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">parallel_offset</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span><span class="p">,</span> <span class="n">timer</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">core_cnt</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">MAXIMUM_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="p">,</span>
                <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
                <span class="n">cap_style</span><span class="o">=</span><span class="n">cap_style</span><span class="p">,</span>
                <span class="n">simplify_tolerance</span><span class="o">=</span><span class="n">simplify_tolerance</span><span class="p">,</span>
                <span class="n">preserve_topology</span><span class="o">=</span><span class="n">preserve_topology</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">mp_return</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_name</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing polygon batch </span><span class="si">{</span><span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="n">animal_name</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing polygon batch </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Animal: </span><span class="si">{</span><span class="n">animal_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_name</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing polygon batch </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing polygon batch </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">, Animal: </span><span class="si">{</span><span class="n">animal_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mp_return</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Polygons complete.&quot;</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">ll</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">ll</span><span class="p">]</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_bodypart_to_point"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodypart_to_point">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">multiframe_bodypart_to_point</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                     <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">px_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Point</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Point</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process multiple frames of body part data in parallel and convert them to shapely Points.</span>

<span class="sd">        This function takes a multi-frame body part data represented as an array and</span>
<span class="sd">        converts it into points. It utilizes multiprocessing for parallel processing.</span>

<span class="sd">        :param np.ndarray data: 2D or 3D array with body-part coordinates where rows are frames and columns are x and y coordinates.</span>
<span class="sd">        :param Optional[int] core_cnt: The number of cores to use. If -1, then all available cores.</span>
<span class="sd">        :param Optional[int] px_per_mm: Pixels ro millimeter convertion factor. Required if buffer is not None.</span>
<span class="sd">        :param Optional[int] buffer: If not None, then the area of the Point. Thus, if not None, then returns Polygons representing the Points.</span>
<span class="sd">        :param Optional[int] px_per_mm: Pixels to millimeter convertion factor. Required if buffer is not None.</span>
<span class="sd">        :returns Union[List[Point], List[List[Point]]]: If input is a 2D array, then list of Points. If 3D array, then list of list of Points.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If buffer and px_per_mm is not None, then the points will be *buffered* and a 2D share polygon created with the specified buffered area.</span>
<span class="sd">           If buffer is provided, then also provide px_per_mm for accurate conversion factor between pixels and millimeters.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; points_lst = GeometryMixin().multiframe_bodypart_to_point(data=data, buffer=10, px_per_mm=4)</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (10, 10, 2))</span>
<span class="sd">        &gt;&gt;&gt; point_lst_of_lst = GeometryMixin().multiframe_bodypart_to_point(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">),</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_bodypart_to_point</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">data_ndim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">data_ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">core_cnt</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_points</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span> <span class="n">px_per_mm</span><span class="o">=</span><span class="n">px_per_mm</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data_ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_bodyparts_to_circle"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodyparts_to_circle">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_bodyparts_to_circle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">parallel_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a set of pose-estimated key-points to circles with specified radius using multiprocessing.</span>

<span class="sd">        :param np.ndarray data: The body-part coordinates xy as a 2d array where rows are frames and columns represent x and y coordinates . E.g., np.array([[364, 308], [369, 309]])</span>
<span class="sd">        :param int data: The radius of the resultant circle in millimeters.</span>
<span class="sd">        :param int core_cnt: Number of CPU cores to use. Defaults to -1 meaning all available cores will be used.</span>
<span class="sd">        :param int pixels_per_mm: The pixels per millimeter of the video. If not passed, 1 will be used meaning revert to radius in pixels rather than millimeters.</span>
<span class="sd">        :returns Polygon: List of shapely Polygons of circular shape of size data.shape[0].</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; circles = GeometryMixin().multiframe_bodyparts_to_circle(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_circle</span><span class="p">,</span>
                <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
                <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">mp_return</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mp_return</span><span class="p">)</span>

        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Multiframe body-parts to circle complete&quot;</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_bodyparts_to_circle</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.delaunay_triangulate_keypoints"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.delaunay_triangulate_keypoints">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">delaunay_triangulate_keypoints</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Triangulates a set of 2D keypoints. E.g., use to polygonize animal hull, or triangulate a gridpoint areana.</span>

<span class="sd">        This method takes a 2D numpy array representing a set of keypoints and</span>
<span class="sd">        triangulates them using the Delaunay triangulation algorithm. The input</span>
<span class="sd">        array should have two columns corresponding to the x and y coordinates of</span>
<span class="sd">        the keypoints.</span>

<span class="sd">        .. image:: _static/img/delaunay_triangulate_keypoints.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/delaunay_triangulate_keypoints.gif</span>
<span class="sd">           :width: 450</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/delaunay_triangulate_keypoints_2.png</span>
<span class="sd">           :width: 450</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: NumPy array of body part coordinates. Each subarray represents the coordinates of a body part.</span>
<span class="sd">        :returns  List[Polygon]: A list of `Polygon` objects representing the triangles formed by the Delaunay triangulation.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([[126, 122],[152, 116],[136,  85],[167, 172],[161, 206],[197, 193],[191, 237]])</span>
<span class="sd">        &gt;&gt;&gt; triangulated_hull = GeometryMixin().delaunay_triangulate_keypoints(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">delaunay_triangulate_keypoints</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Triangulate requires 2D array, got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">delaunay_triangulate_keypoints</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">triangulate</span><span class="p">(</span><span class="n">MultiPoint</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)))</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_bodyparts_to_line"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodyparts_to_line">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_bodyparts_to_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                     <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                     <span class="n">buffer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">px_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                     <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">LineString</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert multiframe body-parts data to a list of LineString objects using multiprocessing.</span>

<span class="sd">        :param np.ndarray data: Input array representing multiframe body-parts data. It should be a 3D array with dimensions (frames, points, coordinates).</span>
<span class="sd">        :param Optional[int] buffer: If not None, then the linestring will be expanded into a 2D geometry polygon with area ``buffer``.</span>
<span class="sd">        :param Optional[int] px_per_mm: If ``buffer`` if not None, then provide the pixels to millimeter</span>
<span class="sd">        :param Optional[int] core_cnt: Number of CPU cores to use for parallel processing. If set to -1, the function will automatically determine the available core count.</span>
<span class="sd">        :return List[LineString]: A list of LineString objects representing the body-parts trajectories.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; data = data.reshape(50,-1, data.shape[1])</span>
<span class="sd">        &gt;&gt;&gt; lines = GeometryMixin().multiframe_bodyparts_to_line(data=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Multiframe body-parts to linestring expects a 3D array, got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_points</span><span class="si">}</span><span class="s2"> buffer&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_points</span><span class="si">}</span><span class="s2"> px_per_mm&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span> <span class="n">px_per_mm</span><span class="o">=</span><span class="n">px_per_mm</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_compute_pct_shape_overlap"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_compute_pct_shape_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_compute_pct_shape_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                             <span class="n">shape_1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
                                             <span class="n">shape_2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
                                             <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="n">video_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                             <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                             <span class="n">animal_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                             <span class="n">denominator</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;difference&quot;</span><span class="p">,</span> <span class="s2">&quot;shape_1&quot;</span><span class="p">,</span> <span class="s2">&quot;shape_2&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;difference&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the percentage overlap between corresponding Polygons in two lists.</span>

<span class="sd">        .. image:: _static/img/multiframe_compute_pct_shape_overlap.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param List[Polygon] shape_1: List of Polygons.</span>
<span class="sd">        :param List[Polygon] shape_2: List of Polygons with the same length as shape_1.</span>
<span class="sd">        :param int core_cnt: Number of CPU cores to use for parallel processing. Default is -1, which uses all available cores.</span>
<span class="sd">        :param Optional[str] video_name: If not None, then the name of the video being processed for interpretable progress msgs.</span>
<span class="sd">        :param Optional[bool] video_name: If True, then prints interpretable progress msgs.</span>
<span class="sd">        :param Optional[Tuple[str]] animal_names: If not None, then a two-tuple of animal names (or alternative shape names) interpretable progress msgs.</span>

<span class="sd">        :return List[float]: List of percentage overlap between corresponding Polygons.</span>

<span class="sd">        :example:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;shape_1 and shape_2 are unequal sizes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_compute_pct_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">input_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape_1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape_2</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_dtypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;shape_1 and shape_2 contains more than 1 dtype </span><span class="si">{</span><span class="n">input_dtypes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_compute_pct_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_compute_pct_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shape_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">timer</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">shape_1</span><span class="p">,</span> <span class="n">shape_2</span><span class="p">)),</span>
            <span class="p">[],</span>
            <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">core_cnt</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">processes</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">MAXIMUM_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">compute_pct_shape_overlap</span><span class="p">,</span> <span class="n">denominator</span><span class="o">=</span><span class="n">denominator</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing % overlap batch </span><span class="si">{</span><span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="n">animal_names</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Computing % overlap batch </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Animals/Shapes: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Computing % overlap batch </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Computing % overlap batch </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">, Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                    <span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Compute overlap complete.&quot;</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span>
        <span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_compute_shape_overlap"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_compute_shape_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_compute_shape_overlap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape_1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">shape_2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiprocess compute overlap between corresponding Polygons in two lists.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Only returns if two shapes are overlapping or not overlapping. If the amount of overlap is required, use</span>
<span class="sd">           ``GeometryMixin().multifrm_compute_pct_shape_overlap()``.</span>

<span class="sd">        :param List[Polygon] shape_1: List of Polygons.</span>
<span class="sd">        :param List[Polygon] shape_2: List of Polygons with the same length as shape_1.</span>
<span class="sd">        :param int core_cnt: Number of CPU cores to use for parallel processing. Default is -1, which uses all available cores.</span>
<span class="sd">        :return List[float]: List of overlap between corresponding Polygons. If overlap 1, else 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;shape_1 and shape_2 are unequal sizes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_compute_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">input_dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape_1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape_2</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_dtypes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;shape_1 and shape_2 contains more than 1 dtype </span><span class="si">{</span><span class="n">input_dtypes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_compute_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_compute_shape_overlap</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shape_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">shape_1</span><span class="p">,</span> <span class="n">shape_2</span><span class="p">)),</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">compute_shape_overlap</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing overlap </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing overlap </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> (Shape 1: </span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, Shape 2: </span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, Video: </span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">...)&quot;</span>
                        <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_shape_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_shape_distance">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_shape_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">shape_1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]],</span>
                                  <span class="n">shape_2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]],</span>
                                  <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                  <span class="n">unit</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span>
                                  <span class="n">core_cnt</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute shape distances between corresponding shapes in two lists of LineString or Polygon geometries for multiple frames.</span>

<span class="sd">        :param List[Union[LineString, Polygon]] shape_1: List of LineString or Polygon geometries.</span>
<span class="sd">        :param List[Union[LineString, Polygon]] shape_2: List of LineString or Polygon geometries with the same length as shape_1.</span>
<span class="sd">        :param float pixels_per_mm: Conversion factor from pixels to millimeters.</span>
<span class="sd">        :param Literal[&#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;] unit: Unit of measurement for the result. Options: &#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;. Default: &#39;mm&#39;.</span>
<span class="sd">        :param core_cnt: Number of CPU cores to use for parallel processing. Default is -1, which uses all available cores.</span>
<span class="sd">        :return List[float]: List of shape distances between corresponding shapes in passed unit.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;PIXELS PER MM&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">check_if_valid_input</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;UNIT&quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;shape_1 and shape_2 are unequal sizes: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_shape_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;pixels_per_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape_1</span><span class="p">,</span> <span class="n">shape_2</span><span class="p">)]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">shape_distance</span><span class="p">,</span> <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_minimum_rotated_rectangle"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_minimum_rotated_rectangle">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_minimum_rotated_rectangle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">video_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">animal_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the minimum rotated rectangle for each Polygon in a list using mutiprocessing.</span>

<span class="sd">        :param List[Polygon] shapes: List of Polygons.</span>
<span class="sd">        :param core_cnt: Number of CPU cores to use for parallel processing. Default is -1, which uses all available cores.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span><span class="p">,</span> <span class="n">timer</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">minimum_rotated_rectangle</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_name</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Rotating polygon </span><span class="si">{</span><span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="n">animal_name</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Rotating polygon </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Animal: </span><span class="si">{</span><span class="n">animal_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_name</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Rotating polygon </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Rotating polygon </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">, Animal: </span><span class="si">{</span><span class="n">animal_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Rotated rectangles complete.&quot;</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span>
        <span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.static_point_lineside"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.static_point_lineside">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:,:,:], float64[:])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">static_point_lineside</span><span class="p">(</span><span class="n">lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the relative position (left vs right) of a static point with respect to multiple lines.</span>

<span class="sd">        .. image:: _static/img/static_point_lineside.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `rayryeng &lt;https://stackoverflow.com/a/62886424&gt;`__.</span>

<span class="sd">        :param numpy.ndarray lines: An array of shape (N, 2, 2) representing N lines, where each line is defined by two points. The first point that denotes the beginning of the line, the second point denotes the end of the line.</span>
<span class="sd">        :param numpy.ndarray point: A 2-element array representing the coordinates of the static point.</span>
<span class="sd">        :return np.ndarray: An array of length N containing the results for each line. 2 if the point is on the right side of the line. 1 if the point is on the left side of the line. 0 if the point is on the line.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; line = np.array([[[25, 25], [25, 20]], [[15, 25], [15, 20]], [[15, 25], [50, 20]]]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; point = np.array([20, 0]).astype(np.float64)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().static_point_lineside(lines=line, point=point)</span>
<span class="sd">        &gt;&gt;&gt; [1. 2. 1.]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">threshhold</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">threshhold</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">threshhold</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.point_lineside"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.point_lineside">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:,:,:], float32[:, :])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">point_lineside</span><span class="p">(</span><span class="n">lines</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the relative position of a point (left vs right) with respect to a lines in each frame.</span>

<span class="sd">        .. image:: _static/img/point_lineside.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param numpy.ndarray lines: An array of shape (N, 2, 2) representing N lines, where each line is defined by two points. The first point that denotes the beginning of the line, the second point denotes the end of the line.</span>
<span class="sd">        :param numpy.ndarray point: An array of shape (N, 2) representing N points.</span>
<span class="sd">        :return np.ndarray: An array of length N containing the results for each line. 2 if the point is on the right side of the line. 1 if the point is on the left side of the line. 0 if the point is on the line.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; lines = np.array([[[25, 25], [25, 20]], [[15, 25], [15, 20]], [[15, 25], [50, 20]]]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[20, 0], [15, 20], [90, 0]]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().point_lineside(lines=lines, points=points)</span>
<span class="sd">        &gt;&gt;&gt; [1., 0., 1.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">threshhold</span> <span class="o">=</span> <span class="mf">1e-9</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">lines</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">line</span><span class="p">,</span> <span class="n">point</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span>
                <span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">threshhold</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">threshhold</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.extend_line_to_bounding_box_edges"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.extend_line_to_bounding_box_edges">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(int64[:,:], int64[:])&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">extend_line_to_bounding_box_edges</span><span class="p">(</span><span class="n">line_points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted extend a line segment defined by two points to fit within a bounding box.</span>

<span class="sd">        .. image:: _static/img/extend_line_to_bounding_box_edges.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray line_points: Coordinates of the line segment&#39;s two points. Two rows and each row represents a point (x, y).</span>
<span class="sd">        :param np.ndarray bounding_box: Bounding box coordinates in the format (min_x, min_y, max_x, max_y).</span>
<span class="sd">        :returns np.ndarray: Intersection points where the extended line crosses the bounding box edges. The shape of the array is (2, 2), where each row represents a point (x, y).</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; line_points = np.array([[25, 25], [45, 25]]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; bounding_box = np.array([0, 0, 50, 50]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().extend_line_to_bounding_box_edges(line_points, bounding_box)</span>
<span class="sd">        &gt;&gt;&gt; [[ 0. 25.] [50. 25.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">line_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">line_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">bounding_box</span>

        <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">x1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_y</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)]]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">y1</span> <span class="o">==</span> <span class="n">y2</span><span class="p">:</span>
            <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">min_x</span><span class="p">,</span> <span class="n">y1</span><span class="p">],</span> <span class="p">[</span><span class="n">max_x</span><span class="p">,</span> <span class="n">y1</span><span class="p">]])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">intercept</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x1</span>

            <span class="n">x_min_intersection</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_y</span> <span class="o">-</span> <span class="n">intercept</span><span class="p">)</span> <span class="o">/</span> <span class="n">slope</span>
            <span class="n">x_max_intersection</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="n">intercept</span><span class="p">)</span> <span class="o">/</span> <span class="n">slope</span>

            <span class="c1"># x_min_intersection = np.clip(x_min_intersection, min_x, max_x)</span>
            <span class="c1"># x_max_intersection = np.clip(x_max_intersection, min_x, max_x)</span>

            <span class="n">intersection_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">x_min_intersection</span><span class="p">,</span> <span class="n">min_y</span><span class="p">],</span> <span class="p">[</span><span class="n">x_max_intersection</span><span class="p">,</span> <span class="n">max_y</span><span class="p">]]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">intersection_points</span></div>

<div class="viewcode-block" id="GeometryMixin.line_split_bounding_box"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.line_split_bounding_box">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">line_split_bounding_box</span><span class="p">(</span><span class="n">intersections</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GeometryCollection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split a bounding box into two parts using an extended line.</span>

<span class="sd">        .. note::</span>
<span class="sd">          Extended line can be found by body-parts using ``GeometryMixin().extend_line_to_bounding_box_edges``.</span>

<span class="sd">        .. image:: _static/img/line_split_bounding_box.png</span>
<span class="sd">           :width: 400</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. image:: _static/img/extend_line_to_bounding_box_edge.gif</span>
<span class="sd">           :width: 450</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray line_points: Intersection points where the extended line crosses the bounding box edges. The shape of the array is (2, 2), where each row represents a point (x, y).</span>
<span class="sd">        :param np.ndarray bounding_box: Bounding box coordinates in the format (min_x, min_y, max_x, max_y).</span>
<span class="sd">        :returns GeometryCollection: A collection of polygons resulting from splitting the bounding box with the extended line.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; line_points = np.array([[25, 25], [45, 25]]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; bounding_box = np.array([0, 0, 50, 50]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; intersection_points = GeometryMixin().extend_line_to_bounding_box_edges(line_points, bounding_box)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().line_split_bounding_box(intersections=intersection_points, bounding_box=bounding_box)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">extended_line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">intersections</span><span class="p">)</span>
        <span class="n">original_polygon</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounding_box</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                <span class="p">(</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounding_box</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">original_polygon</span><span class="p">,</span> <span class="n">extended_line</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_length"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_length">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_length</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]],</span>
        <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">unit</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.random.randint(0, 100, (5000, 2))</span>
<span class="sd">        &gt;&gt;&gt; data = data.reshape(2500,-1, data.shape[1])</span>
<span class="sd">        &gt;&gt;&gt; lines = GeometryMixin().multiframe_bodyparts_to_line(data=data)</span>
<span class="sd">        &gt;&gt;&gt; lengths = GeometryMixin().multiframe_length(shapes=lines, pixels_per_mm=1.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;PIXELS PER MM&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">check_if_valid_input</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;UNIT&quot;</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">])</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_union"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_union">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_union</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]],</span> <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data_1 = np.random.randint(0, 100, (5000, 2)).reshape(1000,-1, 2)</span>
<span class="sd">        &gt;&gt;&gt; data_2 = np.random.randint(0, 100, (5000, 2)).reshape(1000,-1, 2)</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().multiframe_bodyparts_to_polygon(data=data_1)</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().multiframe_bodyparts_to_polygon(data=data_2)</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([polygon_1, polygon_2]).T</span>
<span class="sd">        &gt;&gt;&gt; unions = GeometryMixin().multiframe_union(shapes=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_symmetric_difference"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_symmetric_difference">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_symmetric_difference</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]],</span> <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symmetric differences between corresponding LineString or MultiLineString geometries usng multiprocessing.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data_1 = np.random.randint(0, 100, (5000, 2)).reshape(1000,-1, 2)</span>
<span class="sd">        &gt;&gt;&gt; data_2 = np.random.randint(0, 100, (5000, 2)).reshape(1000,-1, 2)</span>
<span class="sd">        &gt;&gt;&gt; polygon_1 = GeometryMixin().multiframe_bodyparts_to_polygon(data=data_1)</span>
<span class="sd">        &gt;&gt;&gt; polygon_2 = GeometryMixin().multiframe_bodyparts_to_polygon(data=data_2)</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([polygon_1, polygon_2]).T</span>
<span class="sd">        &gt;&gt;&gt; symmetric_differences = GeometryMixin().multiframe_symmetric_difference(shapes=data)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_delaunay_triangulate_keypoints"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_delaunay_triangulate_keypoints">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_delaunay_triangulate_keypoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">core_cnt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &gt;&gt;&gt; data_path = &#39;/Users/simon/Desktop/envs/troubleshooting/Rat_NOR/project_folder/csv/machine_results/08102021_DOT_Rat7_8(2).csv&#39;</span>
<span class="sd">        &gt;&gt;&gt; data = pd.read_csv(data_path, index_col=0).head(1000).iloc[:, 0:21]</span>
<span class="sd">        &gt;&gt;&gt; data = data[data.columns.drop(list(data.filter(regex=&#39;_p&#39;)))]</span>
<span class="sd">        &gt;&gt;&gt; animal_data = data.values.reshape(len(data), -1, 2).astype(int)</span>
<span class="sd">        &gt;&gt;&gt; tri = GeometryMixin().multiframe_delaunay_triangulate_keypoints(data=animal_data)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_delaunay_triangulate_keypoints</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Multiframe delaunay triangulate keypointstriangulate keypoints expects a 3D array, got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_delaunay_triangulate_keypoints</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span>
                    <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">delaunay_triangulate_keypoints</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_difference"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_difference">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_difference</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]],</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">animal_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">video_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the multi-frame difference for a collection of shapes using parallel processing.</span>

<span class="sd">        :param Iterable[Union[LineString, Polygon, MultiPolygon]] shapes: A collection of shapes, where each shape is a list containing two geometries.</span>
<span class="sd">        :param int core_cnt: The number of CPU cores to use for parallel processing. Default is -1, which automatically detects the available cores.</span>
<span class="sd">        :param Optional[bool] verbose: If True, print progress messages during computation. Default is False.</span>
<span class="sd">        :param Optional[str] animal_names: Optional string representing the names of animals for informative messages.</span>
<span class="sd">        :param Optional[str]video_name: Optional string representing the name of the video for informative messages.</span>
<span class="sd">        :return List[Union[Polygon, MultiPolygon]]: A list of geometries representing the multi-frame difference.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_difference</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shapes&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_difference</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shapes </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_iterable_length</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_difference</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shapes </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">check_instance</span><span class="p">(</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_difference</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shapes&quot;</span><span class="p">,</span>
                    <span class="n">instance</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                    <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">MultiPolygon</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span><span class="p">,</span> <span class="n">timer</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">difference</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing geometry difference </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing geometry difference </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing geometry difference </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing geometry difference </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">, Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Multi-frame difference compute complete&quot;</span><span class="p">,</span>
            <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

    <span class="k">def</span> <span class="nf">multiframe_area</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]],</span>
        <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">video_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">animal_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_area</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shapes&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_difference</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shapes </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">MultiPolygon</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> pixels_per_mm&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span><span class="p">,</span> <span class="n">timer</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing area </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing % area </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing % area </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing % area </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">, Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Multi-frame area compute complete&quot;</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span>
        <span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="GeometryMixin.multiframe_bodyparts_to_multistring_skeleton"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_bodyparts_to_multistring_skeleton">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_bodyparts_to_multistring_skeleton</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">skeleton</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">video_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">animal_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">MultiLineString</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert body parts to LineString skeleton representations in a videos using multiprocessing.</span>

<span class="sd">        :param pd.DataFrame data_df: Pose-estimation data.</span>
<span class="sd">        :param Iterable[str] skeleton: Iterable of body part pairs defining the skeleton structure. Eg., [[&#39;Center&#39;, &#39;Lat_left&#39;], [&#39;Center&#39;, &#39;Lat_right&#39;], [&#39;Center&#39;, &#39;Nose&#39;], [&#39;Center&#39;, &#39;Tail_base&#39;]]</span>
<span class="sd">        :param Optional[int] core_cnt: Number of CPU cores to use for parallel processing. Default is -1, which uses all available cores.</span>
<span class="sd">        :param Optional[bool] verbose: If True, print progress information during computation. Default is False.</span>
<span class="sd">        :param Optional[bool] video_name: If True, include video name in progress information. Default is False.</span>
<span class="sd">        :param Optional[bool] animal_names: If True, include animal names in progress information. Default is False.</span>
<span class="sd">        :return List[Union[LineString, MultiLineString]]: List of LineString or MultiLineString objects representing the computed skeletons.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; df = pd.read_csv(&#39;/Users/simon/Desktop/envs/troubleshooting/Rat_NOR/project_folder/csv/machine_results/08102021_DOT_Rat7_8(2).csv&#39;, nrows=500).fillna(0).astype(int)</span>
<span class="sd">        &gt;&gt;&gt; skeleton = [[&#39;Center&#39;, &#39;Lat_left&#39;], [&#39;Center&#39;, &#39;Lat_right&#39;], [&#39;Center&#39;, &#39;Nose&#39;], [&#39;Center&#39;, &#39;Tail_base&#39;], [&#39;Lat_left&#39;, &#39;Tail_base&#39;], [&#39;Lat_right&#39;, &#39;Tail_base&#39;], [&#39;Nose&#39;, &#39;Ear_left&#39;], [&#39;Nose&#39;, &#39;Ear_right&#39;], [&#39;Ear_left&#39;, &#39;Lat_left&#39;], [&#39;Ear_right&#39;, &#39;Lat_right&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; geometries = GeometryMixin().multiframe_bodyparts_to_multistring_skeleton(data_df=df, skeleton=skeleton, core_cnt=2, verbose=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_bodyparts_to_multistring_skeleton</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">data_df</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">skeleton</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_bodyparts_to_multistring_skeleton</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> skeleton </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">,</span>
                    <span class="nb">tuple</span><span class="p">,</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="n">check_iterable_length</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_bodyparts_to_multistring_skeleton</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> skeleton&quot;</span><span class="p">,</span>
                <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">skeleton_data</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node_cnt</span><span class="p">,</span> <span class="n">nodes</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">skeleton</span><span class="p">):</span>
            <span class="n">bp_1</span><span class="p">,</span> <span class="n">bp_2</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_x&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">_y&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
                <span class="n">data_df</span><span class="p">[[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">_x&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">_y&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">bp_1</span><span class="p">,</span> <span class="n">bp_2</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">skeleton_data</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">skeleton_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">skeleton_data</span><span class="p">,</span> <span class="n">line</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">skeleton_data</span> <span class="o">=</span> <span class="n">skeleton_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_df</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">skeleton</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span>
                    <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_multistring_skeleton</span><span class="p">,</span>
                    <span class="n">skeleton_data</span><span class="p">,</span>
                    <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing skeleton </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_df</span><span class="p">)</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing skeleton </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_df</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">video_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">animal_names</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing skeleton </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_df</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Computing skeleton </span><span class="si">{</span><span class="n">cnt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data_df</span><span class="p">)</span><span class="si">}</span><span class="s2"> (Video: </span><span class="si">{</span><span class="n">video_name</span><span class="si">}</span><span class="s2">, Animals: </span><span class="si">{</span><span class="n">animal_names</span><span class="si">}</span><span class="s2">)...&quot;</span>
                        <span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Multistring skeleton complete.&quot;</span><span class="p">,</span>
            <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.get_geometry_brightness_intensity"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.get_geometry_brightness_intensity">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_geometry_brightness_intensity</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
                                          <span class="n">geometries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">]],</span>
                                          <span class="n">ignore_black</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the average brightness intensity within a geometry region-of-interest of an image.</span>

<span class="sd">        E.g., can be used with hardcoded thresholds or model kmeans in `simba.mixins.statistics_mixin.Statistics.kmeans_1d` to detect if a light source is ON or OFF state.</span>

<span class="sd">        .. image:: _static/img/get_geometry_brightness_intensity.png</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray img: Either an image in numpy array format OR a tuple with cv2.VideoCapture object and the frame index.</span>
<span class="sd">        :param List[Union[Polygon, np.ndarray]] geometries: A list of shapes either as vertices in a numpy array, or as shapely Polygons.</span>
<span class="sd">        :param Optional[bool] ignore_black: If non-rectangular geometries, then pixels that don&#39;t belong to the geometry are masked in black. If True, then these pixels will be ignored when computing averages.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; img = cv2.imread(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1_frames/1.png&#39;).astype(np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; data_path = &#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/csv/outlier_corrected_movement_location/Example_1.csv&#39;</span>
<span class="sd">        &gt;&gt;&gt; data = pd.read_csv(data_path, usecols=[&#39;Nose_x&#39;, &#39;Nose_y&#39;]).sample(n=3).fillna(1).values.astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; geometries = []</span>
<span class="sd">        &gt;&gt;&gt; for frm_data in data: geometries.append(GeometryMixin().bodyparts_to_circle(frm_data, 100))</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().get_geometry_brightness_intensity(img=img, geometries=geometries, ignore_black=False)</span>
<span class="sd">        &gt;&gt;&gt; [125.0, 113.0, 118.0]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">get_geometry_brightness_intensity</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> img&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">img</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">get_geometry_brightness_intensity</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> geometries&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">geom_cnt</span><span class="p">,</span> <span class="n">geometry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geometries</span><span class="p">):</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">get_geometry_brightness_intensity</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> geometry </span><span class="si">{</span><span class="n">geom_cnt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="n">sliced_imgs</span> <span class="o">=</span> <span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">slice_shapes_in_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="n">geometries</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">brightness_intensity</span><span class="p">(</span><span class="n">imgs</span><span class="o">=</span><span class="n">sliced_imgs</span><span class="p">,</span> <span class="n">ignore_black</span><span class="o">=</span><span class="n">ignore_black</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.geometry_histocomparison"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.geometry_histocomparison">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">geometry_histocomparison</span><span class="p">(</span>
        <span class="n">imgs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
        <span class="n">geometry</span><span class="p">:</span> <span class="n">Polygon</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span>
                <span class="s2">&quot;chi_square&quot;</span><span class="p">,</span>
                <span class="s2">&quot;correlation&quot;</span><span class="p">,</span>
                <span class="s2">&quot;intersection&quot;</span><span class="p">,</span>
                <span class="s2">&quot;bhattacharyya&quot;</span><span class="p">,</span>
                <span class="s2">&quot;hellinger&quot;</span><span class="p">,</span>
                <span class="s2">&quot;chi_square_alternative&quot;</span><span class="p">,</span>
                <span class="s2">&quot;kl_divergence&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;correlation&quot;</span><span class="p">,</span>
        <span class="n">absolute</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve histogram similarities within a geometry inside two images.</span>

<span class="sd">        For example, the polygon may represent an area around a rodents head. While the front paws are not pose-estimated, computing the histograms of the geometry in two sequential images gives indication of non-freezing.</span>

<span class="sd">        .. note::</span>
<span class="sd">           If shapes is None, the entire two images passed as ``imgs`` will be compared.</span>

<span class="sd">           `Documentation &lt;https://docs.opencv.org/4.x/d6/dc7/group__imgproc__hist.html#gga994f53817d621e2e4228fc646342d386ad75f6e8385d2e29479cf61ba87b57450&gt;`__.</span>

<span class="sd">        .. important::</span>
<span class="sd">           If there is non-pose related noise in the environment (e.g., there are non-experiment related light sources that goes on and off, or waving window curtains causing changes in histgram values w/o affecting pose) this will negatively affect the realiability of histogram comparisons.</span>

<span class="sd">        .. image:: _static/img/geometry_histocomparison.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        :parameter List[Union[np.ndarray, Tuple[cv2.VideoCapture, int]]] imgs: List of two input images. Can be either an two image in numpy array format OR a two tuples with cv2.VideoCapture object and the frame index.</span>
<span class="sd">        :parameter Optional[Polygon] geometry: If Polygon, then the geometry in the two images that should be compared. If None, then entire images will be histocompared.</span>
<span class="sd">        :parameter Literal[&#39;correlation&#39;, &#39;chi_square&#39;] method: The method used for comparison. E.g., if `correlation`, then small output values suggest large differences between the current versus prior image. If `chi_square`, then large output values  suggest large differences between the geometries.</span>
<span class="sd">        :parameter Optional[bool] absolute: If True, the absolute difference between the two histograms. If False, then (image2 histogram) - (image1 histogram)</span>
<span class="sd">        :return float: Value representing the histogram similarities between the geometry in the two images.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; img_1 = cv2.imread(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1_frames/1.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; img_2 = cv2.imread(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1_frames/2.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; data_path = &#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/csv/outlier_corrected_movement_location/Example_1.csv&#39;</span>
<span class="sd">        &gt;&gt;&gt; data = pd.read_csv(data_path, nrows=1, usecols=[&#39;Nose_x&#39;, &#39;Nose_y&#39;]).fillna(-1).values.astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; polygon = GeometryMixin().bodyparts_to_circle(data[0], 100)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().geometry_histocomparison(imgs=[img_1, img_2], geometry=polygon, method=&#39;correlation&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 0.9999769684923543</span>
<span class="sd">        &gt;&gt;&gt; img_2 = cv2.imread(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1_frames/41411.png&#39;)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().geometry_histocomparison(imgs=[img_1, img_2], geometry=polygon, method=&#39;correlation&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 0.6732792208872572</span>
<span class="sd">        &gt;&gt;&gt; img_1 = (cv2.VideoCapture(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1.mp4&#39;), 1)</span>
<span class="sd">        &gt;&gt;&gt; img_2 = (cv2.VideoCapture(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1.mp4&#39;), 2)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().geometry_histocomparison(imgs=[img_1, img_2], geometry=polygon, method=&#39;correlation&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 0.9999769684923543</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">imgs</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs&quot;</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">),</span>
            <span class="nb">min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">GeometryEnum</span><span class="o">.</span><span class="n">HISTOGRAM_COMPARISON_MAP</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="n">corrected_imgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)):</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">check_iterable_length</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">),</span>
                    <span class="nb">min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">check_instance</span><span class="p">(</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> 0&quot;</span><span class="p">,</span>
                    <span class="n">instance</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">accepted_types</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">corrected_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">read_frm_of_video</span><span class="p">(</span><span class="n">video_path</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame_index</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">corrected_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">corrected_imgs</span>
        <span class="k">del</span> <span class="n">corrected_imgs</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sliced_imgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_histocomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> geometry&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="n">Polygon</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">:</span>
                <span class="n">sliced_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">slice_shapes_in_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="p">[</span><span class="n">geometry</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">sliced_imgs</span>
            <span class="k">del</span> <span class="n">sliced_imgs</span>
        <span class="k">return</span> <span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">get_histocomparison</span><span class="p">(</span>
            <span class="n">img_1</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_2</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="n">absolute</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_is_shape_covered"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_is_shape_covered">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_is_shape_covered</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape_1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">shape_2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each shape in time-series of shapes, check if another shape in the same time-series fully covers the</span>
<span class="sd">        first shape.</span>

<span class="sd">        .. image:: _static/img/multiframe_is_shape_covered.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>


<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; shape_1 = GeometryMixin().multiframe_bodyparts_to_polygon(data=np.random.randint(0, 200, (100, 6, 2)))</span>
<span class="sd">        &gt;&gt;&gt; shape_2 = [Polygon([[0, 0], [20, 20], [20, 10], [10, 20]]) for x in range(len(shape_1))]</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin.multiframe_is_shape_covered(shape_1=shape_1, shape_2=shape_2, core_cnt=3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_valid_lst</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">shape_1</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_is_shape_covered</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span>
                <span class="n">LineString</span><span class="p">,</span>
                <span class="n">Polygon</span><span class="p">,</span>
                <span class="n">MultiPolygon</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_valid_lst</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">shape_2</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_is_shape_covered</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span>
                <span class="n">LineString</span><span class="p">,</span>
                <span class="n">Polygon</span><span class="p">,</span>
                <span class="n">MultiPolygon</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;shape_1 (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_1</span><span class="p">)</span><span class="si">}</span><span class="s2">) and shape_2 (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">shape_2</span><span class="p">)</span><span class="si">}</span><span class="s2">) are unequal length&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_is_shape_covered</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shape_1</span><span class="p">,</span> <span class="n">shape_2</span><span class="p">)]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">mp_return</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">is_shape_covered</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mp_return</span><span class="p">)</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.geometry_contourcomparison"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.geometry_contourcomparison">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">geometry_contourcomparison</span><span class="p">(</span>
        <span class="n">imgs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
        <span class="n">geometry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;exterior&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">canny</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare contours between a geometry in two images using shape matching.</span>

<span class="sd">        .. image:: _static/img/geometry_contourcomparison.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. important::</span>
<span class="sd">           If there is non-pose related noise in the environment (e.g., there are non-experiment related intermittant light or shade sources that goes on and off, this will negatively affect the reliability of contour comparisons.</span>

<span class="sd">           Used to pick up very subtle changes around pose-estimated body-part locations.</span>

<span class="sd">        :parameter List[Union[np.ndarray, Tuple[cv2.VideoCapture, int]]] imgs: List of two input images. Can be either be two images in numpy array format OR a two tuples with cv2.VideoCapture object and the frame index.</span>
<span class="sd">        :parameter Optional[Polygon] geometry: If Polygon, then the geometry in the two images that should be compared. If None, then entire images will be contourcompared.</span>
<span class="sd">        :parameter Literal[&#39;all&#39;, &#39;exterior&#39;] method: The method used for contour comparison.</span>
<span class="sd">        :parameter Optional[bool] canny: If True, applies Canny edge detection before contour comparison. Helps reduce noise and enhance contours.  Default is True.</span>
<span class="sd">        :returns float: Contour matching score between the two images. Lower scores indicate higher similarity.</span>


<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; img_1 = cv2.imread(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1_frames/1978.png&#39;).astype(np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; img_2 = cv2.imread(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1_frames/1977.png&#39;).astype(np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; data = pd.read_csv(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/csv/outlier_corrected_movement_location/Example_1.csv&#39;, nrows=1, usecols=[&#39;Nose_x&#39;, &#39;Nose_y&#39;]).fillna(-1).values.astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; geometry = GeometryMixin().bodyparts_to_circle(data[0, :], 100)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin().geometry_contourcomparison(imgs=[img_1, img_2], geometry=geometry, canny=True, method=&#39;exterior&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 22.54</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">imgs</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs&quot;</span><span class="p">,</span>
            <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">),</span>
            <span class="nb">min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">GeometryEnum</span><span class="o">.</span><span class="n">CONTOURS_MAP</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="p">)</span>
        <span class="n">corrected_imgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)):</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">check_iterable_length</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">),</span>
                    <span class="nb">min</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="nb">max</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">check_instance</span><span class="p">(</span>
                    <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> imgs </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> 0&quot;</span><span class="p">,</span>
                    <span class="n">instance</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">accepted_types</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">corrected_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">read_frm_of_video</span><span class="p">(</span><span class="n">video_path</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame_index</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">corrected_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">imgs</span> <span class="o">=</span> <span class="n">corrected_imgs</span>
        <span class="k">del</span> <span class="n">corrected_imgs</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sliced_imgs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">geometry_contourcomparison</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> geometry&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="n">Polygon</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">imgs</span><span class="p">:</span>
                <span class="n">sliced_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">slice_shapes_in_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="p">[</span><span class="n">geometry</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="n">imgs</span> <span class="o">=</span> <span class="n">sliced_imgs</span>
            <span class="k">del</span> <span class="n">sliced_imgs</span>

        <span class="k">return</span> <span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">get_contourmatch</span><span class="p">(</span>
            <span class="n">img_1</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_2</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">canny</span><span class="o">=</span><span class="n">canny</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_multifrm_geometry_histocomparison_helper</span><span class="p">(</span><span class="n">frm_index</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                  <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                  <span class="n">video_path</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">,</span>
                                                  <span class="n">shape_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;rectangle&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">],</span>
                                                  <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                                  <span class="n">parallel_offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Multi-proessing helper for ``multifrm_geometry_histocomparison``&quot;&quot;&quot;</span>

        <span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="n">video_path</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">frm_range_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frm_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">frm_range</span> <span class="o">=</span> <span class="n">frm_index</span><span class="p">[</span><span class="n">frm_range_idx</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Analyzing frame </span><span class="si">{</span><span class="n">frm_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="n">img_1</span> <span class="o">=</span> <span class="n">read_frm_of_video</span><span class="p">(</span><span class="n">video_path</span><span class="o">=</span><span class="n">cap</span><span class="p">,</span> <span class="n">frame_index</span><span class="o">=</span><span class="n">frm_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">img_2</span> <span class="o">=</span> <span class="n">read_frm_of_video</span><span class="p">(</span><span class="n">video_path</span><span class="o">=</span><span class="n">cap</span><span class="p">,</span> <span class="n">frame_index</span><span class="o">=</span><span class="n">frm_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">frm_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">frm_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">shape_type</span> <span class="o">==</span> <span class="s2">&quot;circle&quot;</span><span class="p">:</span>
                <span class="n">shape_1</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_circle</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
                    <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">shape_2</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_circle</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
                    <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">shape_type</span> <span class="o">==</span> <span class="s2">&quot;rectangle&quot;</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">shape_1</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
                    <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">shape_2</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
                    <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">shape_1</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span> <span class="n">px_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span>
                <span class="p">)</span>
                <span class="n">shape_2</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bodyparts_to_line</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buffer</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span> <span class="n">px_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span>
                <span class="p">)</span>
            <span class="n">intersection_shape</span> <span class="o">=</span> <span class="n">shape_1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">shape_2</span><span class="p">)</span>
            <span class="n">img_1</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ImageMixin</span><span class="p">()</span>
                <span class="o">.</span><span class="n">slice_shapes_in_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img_1</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="p">[</span><span class="n">intersection_shape</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">img_2</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ImageMixin</span><span class="p">()</span>
                <span class="o">.</span><span class="n">slice_shapes_in_img</span><span class="p">(</span><span class="n">img</span><span class="o">=</span><span class="n">img_2</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="p">[</span><span class="n">intersection_shape</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ImageMixin</span><span class="p">()</span><span class="o">.</span><span class="n">get_histocomparison</span><span class="p">(</span><span class="n">img_1</span><span class="o">=</span><span class="n">img_1</span><span class="p">,</span> <span class="n">img_2</span><span class="o">=</span><span class="n">img_2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="GeometryMixin.multifrm_geometry_histocomparison"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multifrm_geometry_histocomparison">[docs]</a>    <span class="k">def</span> <span class="nf">multifrm_geometry_histocomparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                          <span class="n">video_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">PathLike</span><span class="p">],</span>
                                          <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                          <span class="n">shape_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;rectangle&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">,</span> <span class="s2">&quot;line&quot;</span><span class="p">],</span>
                                          <span class="n">lag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                                          <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                          <span class="n">parallel_offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform geometry histocomparison on multiple video frames using multiprocessing.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Comparions are made using the intersections of the two image geometries, meaning that the same</span>
<span class="sd">           experimental area of the image and arena is used in the comparison and shifts in animal location cannot account for variability.</span>

<span class="sd">        :param Union[str, os.PathLike] video_path: Path to the video file.</span>
<span class="sd">        :param np.ndarray data: Input data, typically containing coordinates of one or several body-parts.</span>
<span class="sd">        :param Literal[&#39;rectangle&#39;, &#39;circle&#39;] shape_type: Type of shape for comparison.</span>
<span class="sd">        :param Optional[int] lag: Number of frames to lag between comparisons. Default is 2.</span>
<span class="sd">        :param Optional[int] core_cnt: Number of CPU cores to use for parallel processing. Default is -1 which is all available cores.</span>
<span class="sd">        :param Optional[int] pixels_per_mm: Pixels per millimeter for conversion. Default is 1.</span>
<span class="sd">        :param Optional[int] parallel_offset: Size of the geometry ROI in millimeters. Default 1.</span>
<span class="sd">        :returns np.ndarray: The difference between the successive geometry histograms.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = pd.read_csv(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/csv/outlier_corrected_movement_location/Example_1.csv&#39;, nrows=2100, usecols=[&#39;Nose_x&#39;, &#39;Nose_y&#39;]).fillna(-1).values.astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; results = GeometryMixin().multifrm_geometry_histocomparison(video_path=&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1.mp4&#39;, data= data, shape_type=&#39;circle&#39;, pixels_per_mm=1, parallel_offset=100)</span>
<span class="sd">        &gt;&gt;&gt; data = pd.read_csv(&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/csv/outlier_corrected_movement_location/Example_2.csv&#39;, nrows=2100, usecols=[&#39;Nose_x&#39;, &#39;Nose_y&#39;, &#39;Tail_base_x&#39; , &#39;Tail_base_y&#39;, &#39;Center_x&#39; , &#39;Center_y&#39;]).fillna(-1).values.astype(np.int64)</span>
<span class="sd">        &gt;&gt;&gt; results = GeometryMixin().multifrm_geometry_histocomparison(video_path=&#39;/Users/simon/Desktop/envs/troubleshooting/Emergence/project_folder/videos/Example_1.mp4&#39;, data= data, shape_type=&#39;rectangle&#39;, pixels_per_mm=1, parallel_offset=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;Darwin&quot;</span><span class="p">:</span>
            <span class="n">multiprocessing</span><span class="o">.</span><span class="n">set_start_method</span><span class="p">(</span><span class="s2">&quot;spawn&quot;</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">split_frm_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">lag</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">split_frm_idx</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_frm_idx</span><span class="p">)</span> <span class="o">//</span> <span class="n">core_cnt</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_frm_idx</span><span class="p">)</span> <span class="o">%</span> <span class="n">core_cnt</span>
        <span class="n">split_frm_idx</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">split_frm_idx</span><span class="p">[</span>
                <span class="n">i</span> <span class="o">*</span> <span class="n">chunk_size</span>
                <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size</span>
                <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">core_cnt</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">lag</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">_multifrm_geometry_histocomparison_helper</span><span class="p">,</span>
                <span class="n">video_path</span><span class="o">=</span><span class="n">video_path</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">shape_type</span><span class="o">=</span><span class="n">shape_type</span><span class="p">,</span>
                <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span>
                <span class="n">parallel_offset</span><span class="o">=</span><span class="n">parallel_offset</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">split_frm_idx</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span></div>

<div class="viewcode-block" id="GeometryMixin.rank_shapes"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.rank_shapes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">rank_shapes</span><span class="p">(</span>
        <span class="n">shapes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;area&quot;</span><span class="p">,</span>
            <span class="s2">&quot;min_distance&quot;</span><span class="p">,</span>
            <span class="s2">&quot;max_distance&quot;</span><span class="p">,</span>
            <span class="s2">&quot;mean_distance&quot;</span><span class="p">,</span>
            <span class="s2">&quot;left_to_right&quot;</span><span class="p">,</span>
            <span class="s2">&quot;top_to_bottom&quot;</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">deviation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">descending</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rank a list of polygon geometries based on a specified method. E.g., order the list of geometries according to sizes or distances to each other or from left to right etc.</span>

<span class="sd">        :param List[Polygon] shapes: List of Shapely polygons to be ranked. List has to contain two or more shapes.</span>
<span class="sd">        :param Literal[&#39;area&#39;, &#39;min_center_distance&#39;, &#39;max_center_distance&#39;, &#39;mean_shape_distance&#39;] method: The ranking method to use.</span>
<span class="sd">        :param Optional[bool] deviation: If True, rank based on absolute deviation from the mean. Default: False.</span>
<span class="sd">        :param Optional[bool] descending: If True, rank in descending order; otherwise, rank in ascending order. Default: False.</span>
<span class="sd">        :return: A input list of Shapely polygons sorted according to the specified ranking method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">rank_shapes</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">shapes</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">rank_shapes</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">),</span> <span class="nb">min</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">rank_shapes</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="n">Polygon</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_if_valid_input</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">rank_shapes</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method&quot;</span><span class="p">,</span>
            <span class="nb">input</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">GeometryEnum</span><span class="o">.</span><span class="n">RANKING_METHODS</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ranking_vals</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;area&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shp_cnt</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">ranking_vals</span><span class="p">[</span><span class="n">shp_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;min_center_distance&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shp_cnt_1</span><span class="p">,</span> <span class="n">shape_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">shape_1_loc</span><span class="p">,</span> <span class="n">shape_min_distance</span> <span class="o">=</span> <span class="n">shape_1</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">shp_cnt_2</span><span class="p">,</span> <span class="n">shape_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape_2</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">shape_1</span><span class="p">):</span>
                        <span class="n">shape_min_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                            <span class="n">shape_1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">shape_2</span><span class="o">.</span><span class="n">centroid</span><span class="p">),</span>
                            <span class="n">shape_min_distance</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="n">ranking_vals</span><span class="p">[</span><span class="n">shp_cnt_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape_min_distance</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;max_distance&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shp_cnt_1</span><span class="p">,</span> <span class="n">shape_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">shape_1_loc</span><span class="p">,</span> <span class="n">shape_min_distance</span> <span class="o">=</span> <span class="n">shape_1</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">for</span> <span class="n">shp_cnt_2</span><span class="p">,</span> <span class="n">shape_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape_2</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">shape_1</span><span class="p">):</span>
                        <span class="n">shape_min_distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                            <span class="n">shape_1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">shape_2</span><span class="o">.</span><span class="n">centroid</span><span class="p">),</span>
                            <span class="n">shape_min_distance</span><span class="p">,</span>
                        <span class="p">)</span>
                <span class="n">ranking_vals</span><span class="p">[</span><span class="n">shp_cnt_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape_min_distance</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mean_distance&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shp_cnt_1</span><span class="p">,</span> <span class="n">shape_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">shape_1_loc</span><span class="p">,</span> <span class="n">shape_distances</span> <span class="o">=</span> <span class="n">shape_1</span><span class="o">.</span><span class="n">centroid</span><span class="p">,</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">shp_cnt_2</span><span class="p">,</span> <span class="n">shape_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">shape_2</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">shape_1</span><span class="p">):</span>
                        <span class="n">shape_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">shape_1</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">shape_2</span><span class="o">.</span><span class="n">centroid</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">ranking_vals</span><span class="p">[</span><span class="n">shp_cnt_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">shape_distances</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;left_to_right&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shp_cnt</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">ranking_vals</span><span class="p">[</span><span class="n">shp_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">centroid</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;top_to_bottom&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shp_cnt</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
                <span class="n">ranking_vals</span><span class="p">[</span><span class="n">shp_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">centroid</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">deviation</span><span class="p">:</span>
            <span class="n">new_ranking_vals</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{},</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ranking_vals</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">ranking_vals</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ranking_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_ranking_vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="n">ranking_vals</span> <span class="o">=</span> <span class="n">new_ranking_vals</span>

        <span class="n">ranked</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ranking_vals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">ranking_vals</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">descending</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">shapes</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ranked</span><span class="p">]</span></div>

<div class="viewcode-block" id="GeometryMixin.contours_to_geometries"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.contours_to_geometries">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">contours_to_geometries</span><span class="p">(</span><span class="n">contours</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">force_rectangles</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of contours to a list of geometries.</span>

<span class="sd">        E.g., convert a list of contours detected with ``ImageMixin.find_contours`` to a list of Shapely geometries</span>
<span class="sd">        that can be used within the ``GeometryMixin``.</span>

<span class="sd">        :param List[np.ndarray] contours: List of contours represented as 2D arrays.</span>
<span class="sd">        :param force_rectangles: If True, then force the resulting geometries to be rectangular.</span>
<span class="sd">        :return List[Polygon]: List of Shapley Polygons.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; video_frm = read_frm_of_video(video_path=&#39;/Users/simon/Desktop/envs/platea_featurizer/data/video/3D_Mouse_5-choice_MouseTouchBasic_s9_a4_grayscale.mp4&#39;)</span>
<span class="sd">        &gt;&gt;&gt; contours = ImageMixin.find_contours(img=video_frm)</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin.contours_to_geometries(contours=contours)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">contours_to_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">contours</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">contours_to_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,),</span>
            <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">contour</span> <span class="ow">in</span> <span class="n">contours</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">contour</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">contour</span> <span class="o">=</span> <span class="n">contour</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">contour</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bodyparts_to_polygon</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">contour</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">force_rectangles</span><span class="p">:</span>
                <span class="n">polygon</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">minimum_rotated_rectangle</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">polygon</span><span class="p">)</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.adjust_geometry_locations"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.adjust_geometry_locations">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">adjust_geometry_locations</span><span class="p">(</span><span class="n">geometries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
                                  <span class="n">shift</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                                  <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                  <span class="n">minimum</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                  <span class="n">maximum</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift a set of geometries specified distance in the x and/or y-axis.</span>

<span class="sd">        .. image:: _static/img/adjust_geometry_locations.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param  List[Polygon] geometries: List of input polygons to be adjusted.</span>
<span class="sd">        :param Tuple[int, int] shift: Tuple specifying the shift distances in the x and y-axis. Interpreted as pixels if ``pixels_per_mm`` is None. Else interpreted as millimeter.</span>
<span class="sd">        :param float pixels_per_mm: Pixel per millimeter conversion factor.</span>
<span class="sd">        :param Optional[Tuple[int, int]] minimum: Minimim allowed coordinates of Polygon points on x and y axes. Default: (0,0).</span>
<span class="sd">        :param Optional[Tuple[int, int]] maximum: Maximum allowed coordinates of Polygon points on x and y axes. Default: (np.inf, np.inf).</span>
<span class="sd">        :return List[Polygon]: List of adjusted polygons.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; shapes = GeometryMixin().adjust_geometry_locations(geometries=shapes, shift=(0, 333))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_tuple</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">adjust_geometry_locations</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shift&quot;</span><span class="p">,</span> <span class="n">accepted_lengths</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,))</span>
        <span class="n">check_valid_tuple</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">adjust_geometry_locations</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> minimum&quot;</span><span class="p">,</span> <span class="n">accepted_lengths</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,))</span>
        <span class="n">check_valid_tuple</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">adjust_geometry_locations</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> maximum&quot;</span><span class="p">,</span> <span class="n">accepted_lengths</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">,))</span>
        <span class="n">check_valid_lst</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">adjust_geometry_locations</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> geometries&quot;</span><span class="p">,</span> <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">Polygon</span><span class="p">,),</span> <span class="n">min_len</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pixels_per_mm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;pixels_per_mm&#39;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">pixels_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mf">10e-6</span><span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">pixels_per_mm</span><span class="p">)),</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">pixels_per_mm</span><span class="p">))))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">shape_cnt</span><span class="p">,</span> <span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">geometries</span><span class="p">):</span>
            <span class="n">shape_results</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">):</span>
                <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">minimum</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_shift</span><span class="p">)</span>
                <span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maximum</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_shift</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">maximum</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_shift</span><span class="p">)</span>
                <span class="n">shape_results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">y_shift</span><span class="p">,</span> <span class="n">x_shift</span><span class="p">])</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">shape_results</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.bucket_img_into_grid_points"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bucket_img_into_grid_points">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bucket_img_into_grid_points</span><span class="p">(</span><span class="n">point_distance</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                    <span class="n">px_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                    <span class="n">img_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                                    <span class="n">border_sites</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Point</span><span class="p">]:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a grid of evenly spaced points within an image. Use for creating spatial markers within an arena.</span>

<span class="sd">        .. image:: _static/img/bucket_img_into_grid_points.png</span>
<span class="sd">           :width: 800</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param int point_distance: Distance between adjacent points in millimeters.</span>
<span class="sd">        :param float px_per_mm: Pixels per millimeter conversion factor.</span>
<span class="sd">        :param Tuple[int, int] img_size: Size of the image in pixels (width, height).</span>
<span class="sd">        :param Optional[bool] border_sites: If True, includes points on the border of the image. Default is True.</span>
<span class="sd">        :returns Dict[Tuple[int, int], Point]: Dictionary where keys are (row, column) indices of the point, and values are Shapely Point objects.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin.bucket_img_into_grid_points(point_distance=20, px_per_mm=4, img_size=img.shape, border_sites=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">point_distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">point_distance</span> <span class="o">*</span> <span class="n">px_per_mm</span><span class="p">)</span>
        <span class="n">v_bin_cnt</span><span class="p">,</span> <span class="n">h_bin_cnt</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point_distance</span><span class="p">),</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">point_distance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h_bin_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v_bin_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">points</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">h_cnt</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">v_cnt</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">point_distance</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">point_distance</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">border_sites</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">point</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">points</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="n">points</span><span class="p">[(</span><span class="n">h_cnt</span><span class="p">,</span> <span class="n">v_cnt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points</span></div>

<div class="viewcode-block" id="GeometryMixin.bucket_img_into_grid_square"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bucket_img_into_grid_square">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bucket_img_into_grid_square</span><span class="p">(</span><span class="n">img_size</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                    <span class="n">bucket_grid_size_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">bucket_grid_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">px_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                    <span class="n">add_correction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bucketize an image into squares and return a dictionary of polygons representing the bucket locations.</span>

<span class="sd">        .. image:: _static/img/bucket_img_into_grid_square_3.png</span>
<span class="sd">           :width: 800</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param Iterable[int] img_size: 2-value tuple, list or array representing the width and height of the image in pixels.</span>
<span class="sd">        :param Optional[float] bucket_grid_size_mm: The width/height of each square bucket in millimeters. E.g., 50 will create 5cm by 5cm squares. If None, then buckets will by defined by ``bucket_grid_size`` argument.</span>
<span class="sd">        :param Optional[Iterable[int]] bucket_grid_size: 2-value tuple, list or array representing the grid square in number of horizontal squares x number of vertical squares. If None, then buckets will be defined by the ``bucket_size_mm`` argument.</span>
<span class="sd">        :param Optional[float] px_per_mm: Pixels per millimeter conversion factor. Necessery if buckets are defined by ``bucket_size_mm`` argument.</span>
<span class="sd">        :param Optional[bool] add_correction: If True, performs correction by adding extra columns or rows to cover any remaining space if using ``bucket_size_mm``. Default True.</span>
<span class="sd">        :param Optional[bool] verbose: If True, prints progress / completion information. Default True.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; img = cv2.imread(&#39;/Users/simon/Desktop/Screenshot 2024-01-21 at 10.15.55 AM.png&#39;, 1)</span>
<span class="sd">        &gt;&gt;&gt; polygons = GeometryMixin().bucket_img_into_grid_square(bucket_grid_size=(10, 5), bucket_grid_size_mm=None, img_size=(img.shape[1], img.shape[0]), px_per_mm=5.0)</span>
<span class="sd">        &gt;&gt;&gt; for k, v in polygons[0].items(): cv2.polylines(img, [np.array(v.exterior.coords).astype(int)], True, (255, 0, 133), 2)</span>
<span class="sd">        &gt;&gt;&gt; cv2.imshow(&#39;img&#39;, img)</span>
<span class="sd">        &gt;&gt;&gt; cv2.waitKey()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bucket_grid_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bucket_grid_size_mm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s2">&quot;bucket_size_mm and bucket_grid_size are both not None. Either provide bucket size in millimeters, OR provide the grid size&quot;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> img_size&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">img_size</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),)</span>
        <span class="n">check_iterable_length</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> img_size&quot;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">img_size</span><span class="p">),</span><span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> img_size height&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> img_size width&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],)</span>
        <span class="n">check_valid_boolean</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> verbose&quot;</span><span class="p">)</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">bucket_grid_size_mm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_size_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">bucket_grid_size_mm</span><span class="p">,)</span>
            <span class="n">bin_size_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">px_per_mm</span> <span class="o">*</span> <span class="n">bucket_grid_size_mm</span><span class="p">)</span>
            <span class="n">h_bin_cnt</span><span class="p">,</span> <span class="n">v_bin_cnt</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bin_size_px</span><span class="p">),</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_size_px</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bin_size_px</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bin_size_px</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;The bucket square size </span><span class="si">{</span><span class="n">bin_size_px</span><span class="si">}</span><span class="s2"> is larger than the video size in pixels </span><span class="si">{</span><span class="n">img_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">add_correction</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">h_bin_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v_bin_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">bin_size_px</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">bin_size_px</span>
                    <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">bin_size_px</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">bin_size_px</span>
                    <span class="n">polygons</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)])</span>
            <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">stdout_success</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Bucket image into grid squares complete&quot;</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,)</span>
            <span class="k">return</span> <span class="n">polygons</span><span class="p">,</span> <span class="nb">round</span><span class="p">((</span><span class="n">v_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">h_bin_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bucket_grid_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span> <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_grid_size&quot;</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">bucket_grid_size</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">),)</span>
            <span class="n">check_iterable_length</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_grid_size&quot;</span><span class="p">,</span>
                <span class="n">val</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bucket_grid_size</span><span class="p">),</span>
                <span class="n">exact_accepted_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">check_int</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_grid_size&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">check_int</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">bucket_img_into_grid_square</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bucket_grid_size&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">bucket_width</span><span class="p">,</span> <span class="n">bucket_height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span>
                <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bucket_width</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bucket_height</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                    <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;The bucket square size (</span><span class="si">{</span><span class="n">bucket_width</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">bucket_height</span><span class="si">}</span><span class="s2">) is larger than the video size in pixels </span><span class="si">{</span><span class="n">img_size</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">h_cnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">w_cnt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">top_left</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_cnt</span> <span class="o">*</span> <span class="n">bucket_width</span><span class="p">),</span> <span class="p">(</span><span class="n">w_cnt</span> <span class="o">*</span> <span class="n">bucket_height</span><span class="p">))</span>
                    <span class="n">top_right</span> <span class="o">=</span> <span class="p">((</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bucket_width</span><span class="p">),</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">bottom_left</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bucket_height</span><span class="p">)</span>
                    <span class="n">bottom_right</span> <span class="o">=</span> <span class="p">(</span><span class="n">top_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_right</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bucket_height</span><span class="p">)</span>
                    <span class="n">polygons</span><span class="p">[(</span><span class="n">h_cnt</span><span class="p">,</span> <span class="n">w_cnt</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">top_left</span><span class="p">,</span> <span class="n">bottom_left</span><span class="p">,</span> <span class="n">bottom_right</span><span class="p">,</span> <span class="n">top_right</span><span class="p">]</span>
                    <span class="p">)</span>
            <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">stdout_success</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Bucket image into grid squares complete&quot;</span><span class="p">,</span> <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">polygons</span><span class="p">,</span> <span class="nb">round</span><span class="p">((</span><span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">bucket_grid_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span></div>

<div class="viewcode-block" id="GeometryMixin.bucket_img_into_grid_hexagon"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.bucket_img_into_grid_hexagon">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">bucket_img_into_grid_hexagon</span><span class="p">(</span>
        <span class="n">bucket_size_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">img_size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">px_per_mm</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bucketize an image into hexagons and return a dictionary of polygons representing the hexagon locations.</span>

<span class="sd">        .. image:: _static/img/bucket_img_into_grid_hexagon.png</span>
<span class="sd">           :width: 500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param float bucket_size_mm: The width/height of each hexagon bucket in millimeters.</span>
<span class="sd">        :param Tuple[int, int] img_size: Tuple representing the width and height of the image in pixels.</span>
<span class="sd">        :param float px_per_mm: Pixels per millimeter conversion factor.</span>
<span class="sd">        :return Tuple[Dict[Tuple[int, int], Polygon], float]: First value is a dictionary where keys are (row, column) indices of the bucket, and values are Shapely Polygon objects representing the corresponding hexagon buckets. Second value is the aspect ratio of the hexagonal grid.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; polygons, aspect_ratio = GeometryMixin().bucket_img_into_grid_hexagon(bucket_size_mm=10, img_size=(800, 600), px_per_mm=5.0, add_correction=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bucket_img_into_grid_hexagon bucket_size_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">bucket_size_mm</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bucket_img_into_grid_hexagon img_size height&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bucket_img_into_grid_hexagon img_size width&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;bucket_img_into_grid_hexagon px_per_mm&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">)</span>

        <span class="n">sqrt_3</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">hex_width</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bucket_size_mm</span> <span class="o">*</span> <span class="n">px_per_mm</span>
        <span class="n">hex_height</span> <span class="o">=</span> <span class="n">sqrt_3</span> <span class="o">*</span> <span class="n">bucket_size_mm</span> <span class="o">*</span> <span class="n">px_per_mm</span>

        <span class="n">h_hex_cnt</span><span class="p">,</span> <span class="n">v_hex_cnt</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">hex_height</span><span class="p">)),</span> <span class="nb">divmod</span><span class="p">(</span>
            <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">hex_width</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">h_hex_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">h_hex_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_hex_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h_hex_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">v_hex_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">v_hex_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_hex_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v_hex_cnt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">polygons</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h_hex_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v_hex_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">hex_width</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">sqrt_3</span> <span class="o">*</span> <span class="n">hex_height</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">sqrt_3</span> <span class="o">*</span> <span class="n">hex_height</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span>
                    <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">x</span> <span class="o">+</span> <span class="n">hex_width</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
                            <span class="n">y</span> <span class="o">+</span> <span class="n">hex_height</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="n">polygons</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Bucket image into hexagon grid complete&quot;</span><span class="p">,</span>
            <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">polygons</span><span class="p">,</span> <span class="nb">round</span><span class="p">((</span><span class="n">v_hex_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">h_hex_cnt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">3</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cumsum_coord_geometries_helper</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">geometries</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">):</span>
        <span class="n">data_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing animal grid square location in frame </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">geometries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">data_point</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="GeometryMixin.cumsum_coord_geometries"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.cumsum_coord_geometries">[docs]</a>    <span class="k">def</span> <span class="nf">cumsum_coord_geometries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                <span class="n">geometries</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span>
                                <span class="n">fps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the cumulative time a body-part has spent inside a grid of geometries using multiprocessing.</span>

<span class="sd">        :param np.ndarray data: Input data array where rows represent frames and columns represent body-part x and y coordinates.</span>
<span class="sd">        :param Dict[Tuple[int, int], Polygon] geometries: Dictionary of polygons representing spatial regions. Created by ``GeometryMixin.bucket_img_into_squares``.</span>
<span class="sd">        :param Optional[int] fps: Frames per second (fps) for time normalization. If None, cumulative sum of frame count is returned.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; img_geometries = GeometryMixin.bucket_img_into_grid_square(img_size=(640, 640), bucket_grid_size=(10, 10), px_per_mm=1)</span>
<span class="sd">        &gt;&gt;&gt; bp_arr = np.random.randint(0, 640, (5000, 2))</span>
<span class="sd">        &gt;&gt;&gt; geo_data = GeometryMixin().cumsum_coord_geometries(data=bp_arr, geometries=img_geometries[0], verbose=False, fps=1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CountError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;A N x 2 array is required (got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;fps&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;core_cnt&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">geometries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">frm_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">frm_id</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
        <span class="n">img_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">MAXIMUM_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_coord_geometries_helper</span><span class="p">,</span>
                <span class="n">geometries</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">img_arr</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Cumulative coordinates in geometries complete&quot;</span><span class="p">,</span>
            <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">fps</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cumsum_bool_helper</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">geometries</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">]</span>
    <span class="p">):</span>
        <span class="n">data_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Processing animal grid square location for boolean in frame </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">geometries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">data_point</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="GeometryMixin.cumsum_bool_geometries"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.cumsum_bool_geometries">[docs]</a>    <span class="k">def</span> <span class="nf">cumsum_bool_geometries</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">geometries</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span>
        <span class="n">bool_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the cumulative sums of boolean events within polygon geometries over time using multiprocessing.</span>

<span class="sd">        E.g., compute the cumulative time of classified events within spatial locations at all time-points of the video.</span>

<span class="sd">        :param np.ndarray data: Array containing spatial data with shape (n, 2). E.g., 2D-array with body-part coordinates.</span>
<span class="sd">        :param Dict[Tuple[int, int], Polygon] geometries: Dictionary of polygons representing spatial regions. Created by ``GeometryMixin.bucket_img_into_squares``.</span>
<span class="sd">        :param np.ndarray bool_data: Boolean array with shape (data.shape[0],) or (data.shape[0], 1) indicating the presence or absence in each frame.</span>
<span class="sd">        :param Optional[float] fps: Frames per second. If provided, the result is normalized by the frame rate.</span>
<span class="sd">        :param Optional[float] core_cnt: Number of CPU cores to use for parallel processing. Default is -1, which means using all available cores.</span>
<span class="sd">        :returns np.ndarray: Array of size (frames x horizontal bins x verical bins) with times in seconds (if fps passed) or frames (if fps not passed)</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; geometries = GeometryMixin.bucket_img_into_grid_square(bucket_size_mm=50, img_size=(800, 800) , px_per_mm=5.0)[0]</span>
<span class="sd">        &gt;&gt;&gt; coord_data = np.random.randint(0, 800, (500, 2))</span>
<span class="sd">        &gt;&gt;&gt; bool_data = np.random.randint(0, 2, (500,))</span>
<span class="sd">        &gt;&gt;&gt; x = GeometryMixin().cumsum_bool_geometries(data=coord_data, geometries=geometries, bool_data=bool_data, fps=15)</span>
<span class="sd">        &gt;&gt;&gt; x.shape</span>
<span class="sd">        &gt;&gt;&gt; (500, 4, 4)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_sizes</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_bool_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> data&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_bool_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> geometries&quot;</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">bool_data</span><span class="p">,</span>
            <span class="n">accepted_shapes</span><span class="o">=</span><span class="p">[(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],)],</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_bool_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> bool_data&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_float</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_bool_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fps&quot;</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span>
                <span class="n">min_value</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_bool_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> core_cnt&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bool_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Invalid boolean data. Expected </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2"> but found </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">bool_data</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_bool_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">geometries</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">frm_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bool_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bool_data</span> <span class="o">=</span> <span class="n">bool_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">bool_data</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">frm_id</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
        <span class="n">img_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_bool_helper</span><span class="p">,</span> <span class="n">geometries</span><span class="o">=</span><span class="n">geometries</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">img_arr</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">pool</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">fps</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_cumsum_animal_geometries_grid_helper</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span>
        <span class="n">size</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">shape</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing animal grid square location in frame </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">cumsum_animal_geometries_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Polygon</span><span class="p">],</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Polygon</span><span class="p">],</span>
        <span class="n">fps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">timer</span> <span class="o">=</span> <span class="n">SimbaTimer</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">check_valid_lst</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_animal_geometries_grid</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">Polygon</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">cumsum_animal_geometries_grid</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">dict</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;fps&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;core_cnt&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">grid</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">frm_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">frm_id</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">img_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">constants</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cumsum_animal_geometries_grid_helper</span><span class="p">,</span>
                <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">constants</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)):</span>
                <span class="n">img_arr</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

        <span class="n">timer</span><span class="o">.</span><span class="n">stop_timer</span><span class="p">()</span>
        <span class="n">stdout_success</span><span class="p">(</span>
            <span class="n">msg</span><span class="o">=</span><span class="s2">&quot;Cumulative animal geometries in grid complete&quot;</span><span class="p">,</span>
            <span class="n">elapsed_time</span><span class="o">=</span><span class="n">timer</span><span class="o">.</span><span class="n">elapsed_time_str</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">img_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">fps</span>

<div class="viewcode-block" id="GeometryMixin.hausdorff_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.hausdorff_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">hausdorff_distance</span><span class="p">(</span><span class="n">geometries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Hausdorff distance measure of the similarity between time-series sequential geometries. It is defined as the maximum of the distances</span>
<span class="sd">        from each point in one set to the nearest point in the other set.</span>

<span class="sd">        Hausdorff distance can be used to measure the similarity of the geometry in one frame relative to the geometry in the next frame.</span>
<span class="sd">        Larger values indicate that the animal has a different shape than in the preceding shape.</span>

<span class="sd">        :param List[List[Union[Polygon, LineString]]] geometries: List of list where each list has two geometries.</span>
<span class="sd">        :return np.ndarray: 1D array of hausdorff distances of geometries in each list.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = Polygon([[0,1], [0, 2], [1,1]])</span>
<span class="sd">        &gt;&gt;&gt; y = Polygon([[0,1], [0, 2], [0,1]])</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin.hausdorff_distance(geometries=[[x, y]])</span>
<span class="sd">        &gt;&gt;&gt; [1.]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">geometries</span><span class="p">:</span>
            <span class="n">check_valid_lst</span><span class="p">(</span>
                <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">Polygon</span><span class="p">,</span>
                    <span class="n">LineString</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">exact_len</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">)):</span>
            <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="p">(</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.multiframe_hausdorff_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.multiframe_hausdorff_distance">[docs]</a>    <span class="k">def</span> <span class="nf">multiframe_hausdorff_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geometries</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Polygon</span><span class="p">,</span> <span class="n">LineString</span><span class="p">]],</span>
        <span class="n">lag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Hausdorff distance measure of the similarity between sequential time-series  geometries.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; df = read_df(file_path=&#39;/Users/simon/Desktop/envs/simba/troubleshooting/mouse_open_field/project_folder/csv/outlier_corrected_movement_location/SI_DAY3_308_CD1_PRESENT.csv&#39;, file_type=&#39;csv&#39;)</span>
<span class="sd">        &gt;&gt;&gt; cols = [x for x in df.columns if not x.endswith(&#39;_p&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; data = df[cols].values.reshape(len(df), -1 , 2).astype(np.int)</span>
<span class="sd">        &gt;&gt;&gt; geometries = GeometryMixin().multiframe_bodyparts_to_polygon(data=data, pixels_per_mm=1, parallel_offset=1, verbose=False, core_cnt=-1)</span>
<span class="sd">        &gt;&gt;&gt; hausdorff_distances = GeometryMixin.multiframe_hausdorff_distance(geometries=geometries)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_lst</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_hausdorff_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">geometries</span><span class="p">,</span>
            <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span>
                <span class="n">Polygon</span><span class="p">,</span>
                <span class="n">LineString</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">min_len</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_hausdorff_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">multiframe_hausdorff_distance</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> LAG&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">reshaped_geometries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lag</span><span class="p">):</span>
            <span class="n">reshaped_geometries</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lag</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometries</span><span class="p">)):</span>
            <span class="n">reshaped_geometries</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">geometries</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">lag</span><span class="p">],</span> <span class="n">geometries</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span>
            <span class="n">core_cnt</span><span class="p">,</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="n">Defaults</span><span class="o">.</span><span class="n">LARGE_MAX_TASK_PER_CHILD</span><span class="o">.</span><span class="n">value</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">mp_return</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span>
                    <span class="n">GeometryMixin</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="p">,</span> <span class="n">reshaped_geometries</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span>
                <span class="p">)</span>
            <span class="p">):</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mp_return</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="GeometryMixin.locate_line_point"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.locate_line_point">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">locate_line_point</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                          <span class="n">geometry</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">],</span>
                          <span class="n">px_per_mm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="n">fps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="n">core_cnt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">distance_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                          <span class="n">time_prior</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the time and distance travelled along a path to reach the most proximal point in reference to a second geometry.</span>

<span class="sd">        .. note::</span>
<span class="sd">           (i) To compute the time and distance travelled to along a path to reach the most distal point to a second geometry, pass ``distance_min = False``.</span>

<span class="sd">           (ii) To compute the time and distance travelled along a path **after** reaching the most distal or proximal point to a second geometry, pass ``time_prior = False``.</span>

<span class="sd">        .. image:: _static/img/locate_line_point.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; line = LineString([[10, 10], [7.5, 7.5], [15, 15], [7.5, 7.5]])</span>
<span class="sd">        &gt;&gt;&gt; polygon = Polygon([[0, 5], [0, 0], [5, 0], [5, 5]])</span>
<span class="sd">        &gt;&gt;&gt; GeometryMixin.locate_line_point(path=line, geometry=polygon)</span>
<span class="sd">        &gt;&gt;&gt; {&#39;distance_value&#39;: 3.5355339059327378, &#39;distance_travelled&#39;: 3.5355339059327378, &#39;time_travelled&#39;: 1.0, &#39;distance_index&#39;: 1}</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">locate_line_point</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">locate_line_point</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">Point</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CORE COUNT&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">max_value</span><span class="o">=</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;PIXELS PER MM&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;FPS&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">raise_error</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">core_cnt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">core_cnt</span> <span class="o">=</span> <span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">check_valid_array</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                <span class="n">accepted_axis_1_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
                <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">Point</span><span class="p">):</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">FeatureExtractionMixin</span><span class="o">.</span><span class="n">framewise_euclidean_distance_roi</span><span class="p">(</span>
                <span class="n">location_1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">coords</span><span class="p">),</span>
                <span class="n">location_2</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                <span class="n">px_per_mm</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">coords</span><span class="p">)]</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span><span class="n">geometry</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))]</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">GeometryMixin</span><span class="p">()</span><span class="o">.</span><span class="n">multiframe_shape_distance</span><span class="p">(</span>
                <span class="n">shape_1</span><span class="o">=</span><span class="n">points</span><span class="p">,</span>
                <span class="n">shape_2</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span>
                <span class="n">pixels_per_mm</span><span class="o">=</span><span class="n">px_per_mm</span><span class="p">,</span>
                <span class="n">core_cnt</span><span class="o">=</span><span class="n">core_cnt</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">distance_min</span><span class="p">:</span>
            <span class="n">distance_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distance_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time_prior</span><span class="p">:</span>
            <span class="n">dist_travelled</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">distances</span><span class="p">[:</span> <span class="n">distance_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])))</span> <span class="o">/</span> <span class="n">px_per_mm</span>
            <span class="p">)</span>
            <span class="n">time_travelled</span> <span class="o">=</span> <span class="n">distance_idx</span> <span class="o">/</span> <span class="n">fps</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dist_travelled</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">distance_idx</span><span class="p">:])))</span> <span class="o">/</span> <span class="n">px_per_mm</span>
            <span class="p">)</span>
            <span class="n">time_travelled</span> <span class="o">=</span> <span class="p">(</span><span class="n">distances</span> <span class="o">-</span> <span class="n">distance_idx</span><span class="p">)</span> <span class="o">/</span> <span class="n">fps</span>
        <span class="n">dist_val</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">distance_idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">px_per_mm</span>
        <span class="n">raw_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="o">/</span> <span class="n">px_per_mm</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;distance_value&quot;</span><span class="p">:</span> <span class="n">dist_val</span><span class="p">,</span>
            <span class="s2">&quot;distance_travelled&quot;</span><span class="p">:</span> <span class="n">dist_travelled</span><span class="p">,</span>
            <span class="s2">&quot;time_travelled&quot;</span><span class="p">:</span> <span class="n">time_travelled</span><span class="p">,</span>
            <span class="s2">&quot;distance_index&quot;</span><span class="p">:</span> <span class="n">distance_idx</span><span class="p">,</span>
            <span class="s2">&quot;raw_distances&quot;</span><span class="p">:</span> <span class="n">raw_distances</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="GeometryMixin.linear_frechet_distance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.linear_frechet_distance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:,:], float32[:,:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">linear_frechet_distance</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the Linear Fréchet Distance between two trajectories.</span>

<span class="sd">        The Fréchet Distance measures the dissimilarity between two continuous</span>
<span class="sd">        curves or trajectories represented as sequences of points in a 2-dimensional</span>
<span class="sd">        space.</span>

<span class="sd">        :param ndarray data: First 2D array of size len(frames) representing body-part coordinates x and y.</span>
<span class="sd">        :param ndarray data: Second 2D array of size len(frames) representing body-part coordinates x and y.</span>
<span class="sd">        :param int sample: The downsampling factor for the trajectories (default is 100If sample &gt; 1, the trajectories are downsampled by selecting every sample-th point.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Slightly modified from `João Paulo Figueira &lt;https://github.com/joaofig/discrete-frechet/blob/ff5629e5a43cfad44d5e962f4105dd25c90b9289/distances/discrete.py#L67&gt;`_</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 100, (10000, 2)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 100, (10000, 2)).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; distance = GeometryMixin.linear_frechet_distance(x=x, y=y, sample=100)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[::</span><span class="n">sample</span><span class="p">],</span> <span class="n">y</span><span class="p">[::</span><span class="n">sample</span><span class="p">]</span>
        <span class="n">n_p</span><span class="p">,</span> <span class="n">n_q</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_p</span><span class="p">,</span> <span class="n">n_q</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">n_p</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ca</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ca</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ca</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">ca</span><span class="p">[</span><span class="n">n_p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="GeometryMixin.simba_roi_to_geometries"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.simba_roi_to_geometries">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">simba_roi_to_geometries</span><span class="p">(</span><span class="n">rectangles_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">circles_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">polygons_df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert SimBA dataframes holding ROI geometries to nested dictionary holding Shapley polygons.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; #config_path = &#39;/Users/simon/Desktop/envs/simba/troubleshooting/spontenous_alternation/project_folder/project_config.ini&#39;</span>
<span class="sd">        &gt;&gt;&gt; #config = ConfigReader(config_path=config_path)</span>
<span class="sd">        &gt;&gt;&gt; #config.read_roi_data()</span>
<span class="sd">        &gt;&gt;&gt; #GeometryMixin.simba_roi_to_geometries(rectangles_df=config.rectangles_df, circles_df=config.circles_df, polygons_df=config.polygon_df)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results_roi</span><span class="p">,</span> <span class="n">results_clr</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">rectangles_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">simba_roi_to_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">rectangles_df</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">video_name</span> <span class="ow">in</span> <span class="n">rectangles_df</span><span class="p">[</span><span class="s2">&quot;Video&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">video_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">results_roi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">results_roi</span><span class="p">[</span><span class="n">video_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">results_clr</span><span class="p">[</span><span class="n">video_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">video_shapes</span> <span class="o">=</span> <span class="n">rectangles_df</span><span class="p">[[</span><span class="s2">&quot;Tags&quot;</span><span class="p">,</span> <span class="s2">&quot;Name&quot;</span><span class="p">,</span> <span class="s2">&quot;Color BGR&quot;</span><span class="p">]][</span><span class="n">rectangles_df</span><span class="p">[</span><span class="s2">&quot;Video&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">video_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">shape_name</span> <span class="ow">in</span> <span class="n">video_shapes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                    <span class="n">shape_data</span> <span class="o">=</span> <span class="n">video_shapes</span><span class="p">[</span><span class="n">video_shapes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">shape_name</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">tags</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Tags&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">results_roi</span><span class="p">[</span><span class="n">video_name</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">results_clr</span><span class="p">[</span><span class="n">video_name</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Color BGR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">polygons_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">simba_roi_to_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">polygons_df</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">video_name</span> <span class="ow">in</span> <span class="n">polygons_df</span><span class="p">[</span><span class="s2">&quot;Video&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">video_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">results_roi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">results_roi</span><span class="p">[</span><span class="n">video_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">results_clr</span><span class="p">[</span><span class="n">video_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">video_shapes</span> <span class="o">=</span> <span class="n">polygons_df</span><span class="p">[[</span><span class="s2">&quot;Tags&quot;</span><span class="p">,</span> <span class="s2">&quot;Name&quot;</span><span class="p">,</span> <span class="s2">&quot;Color BGR&quot;</span><span class="p">]][</span> <span class="n">polygons_df</span><span class="p">[</span><span class="s2">&quot;Video&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">video_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">shape_name</span> <span class="ow">in</span> <span class="n">video_shapes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                    <span class="n">shape_data</span> <span class="o">=</span> <span class="n">video_shapes</span><span class="p">[</span><span class="n">video_shapes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">shape_name</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">tags</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Tags&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">results_roi</span><span class="p">[</span><span class="n">video_name</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">tags</span><span class="p">)</span><span class="o">.</span><span class="n">convex_hull</span><span class="o">.</span><span class="n">exterior</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">results_clr</span><span class="p">[</span><span class="n">video_name</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Color BGR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">circles_df</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_instance</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="n">GeometryMixin</span><span class="o">.</span><span class="n">simba_roi_to_geometries</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">circles_df</span><span class="p">,</span> <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,))</span>
            <span class="k">for</span> <span class="n">video_name</span> <span class="ow">in</span> <span class="n">circles_df</span><span class="p">[</span><span class="s2">&quot;Video&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">video_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">results_roi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">results_roi</span><span class="p">[</span><span class="n">video_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">results_clr</span><span class="p">[</span><span class="n">video_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">video_shapes</span> <span class="o">=</span> <span class="n">circles_df</span><span class="p">[[</span><span class="s2">&quot;Tags&quot;</span><span class="p">,</span> <span class="s2">&quot;Name&quot;</span><span class="p">,</span> <span class="s2">&quot;Color BGR&quot;</span><span class="p">,</span> <span class="s1">&#39;radius&#39;</span><span class="p">]][</span><span class="n">circles_df</span><span class="p">[</span><span class="s2">&quot;Video&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">video_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">shape_name</span> <span class="ow">in</span> <span class="n">video_shapes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                    <span class="n">shape_data</span> <span class="o">=</span> <span class="n">video_shapes</span><span class="p">[</span><span class="n">video_shapes</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">shape_name</span><span class="p">]</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">tags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Tags&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">results_roi</span><span class="p">[</span><span class="n">video_name</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;Center tag&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">distance</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
                    <span class="n">results_clr</span><span class="p">[</span><span class="n">video_name</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="s2">&quot;Color BGR&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">color</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results_roi</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">results_roi</span><span class="p">,</span> <span class="n">results_clr</span></div>

<div class="viewcode-block" id="GeometryMixin.filter_low_p_bps_for_shapes"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.geometry_mixin.GeometryMixin.filter_low_p_bps_for_shapes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">filter_low_p_bps_for_shapes</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter body-part data for geometry construction while maintaining valid geometry arrays.</span>

<span class="sd">        Having a 3D array representing body-parts across time, and a second 3D array representing probabilities of those</span>
<span class="sd">        body-parts across time, we want to &quot;remove&quot; body-parts with low detection probabilities whilst also keeping the array sizes</span>
<span class="sd">        intact and suitable for geometry construction. To do this, we find body-parts with detection probabilities below the threshold, and replace these with a body-part</span>
<span class="sd">        that doesn&#39;t fall below the detection probability threshold within the same frame. However, to construct a geometry, we need &gt;= 3 unique key-point locations.</span>
<span class="sd">        Thus, no substitution can be made to when there are less than three unique body-part locations within a frame that falls above the threshold.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 500, (18000, 7, 2))</span>
<span class="sd">        &gt;&gt;&gt; p = np.random.random(size=(18000, 7, 1))</span>
<span class="sd">        &gt;&gt;&gt; x = GeometryMixin.filter_low_p_bps_for_shapes(x=x, p=p, threshold=0.1)</span>
<span class="sd">        &gt;&gt;&gt; x = x.reshape(x.shape[0], int(x.shape[1] * 2))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">below_p_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">above_p_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">below_p_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">above_p_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">below_p_idx</span><span class="p">:</span>
                    <span class="n">new_val</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">above_p_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_val</span>
        <span class="k">return</span> <span class="n">results</span></div></div>








<span class="c1"># data = np.array([[[364, 308], [383, 323], [403, 335], [423, 351]],</span>
<span class="c1">#                  [[356, 307], [376, 319], [396, 331], [419, 347]],</span>
<span class="c1">#                  [[364, 308], [383, 323], [403, 335], [423, 351]],</span>
<span class="c1">#                  [[364, 308], [3, 323], [403, 335], [423, 351]],</span>
<span class="c1">#                  [[364, 308], [383, 323], [54, 335], [423, 351]],</span>
<span class="c1">#                  [[12, 308], [383, 34], [403, 335], [423, 351]],</span>
<span class="c1">#                  [[364, 308], [383, 323], [403, 335], [100, 351]]])</span>
<span class="c1"># GeometryMixin().multiframe_bodyparts_to_polygon(data=data)</span>

<span class="c1">#</span>
<span class="c1"># polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[364, 308],[383, 323],[403, 335],[423, 351]]))</span>
<span class="c1"># polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[356, 307],[376, 319],[396, 331],[419, 347]]))</span>
<span class="c1"># polygon_1 = [polygon_1 for x in range(100)]</span>
<span class="c1"># polygon_2 = [polygon_2 for x in range(100)]</span>
<span class="c1"># data = np.column_stack((polygon_1, polygon_2))</span>
<span class="c1"># GeometryMixin.compute_pct_shape_overlap(shapes=data)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># data = np.array_split(data, 8)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># results = GeometryMixin().multiframe_compute_pct_shape_overlap(shape_1=polygon_1, shape_2=polygon_2,)</span>
<span class="c1">#</span>
<span class="c1"># np.</span>

<span class="c1"># polygon_1 = GeometryMixin().bodyparts_to_polygon(np.array([[0, 100],[100, 100],[0, 0],[100, 0]]))</span>
<span class="c1"># polygon_2 = GeometryMixin().bodyparts_to_polygon(np.array([[25, 75],[75, 75],[25, 25],[75, 25]]))</span>
<span class="c1"># y = GeometryMixin().compute_pct_shape_overlap(shapes=[polygon_1, polygon_2], denominator=&#39;shape_2&#39;)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, sronilsson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
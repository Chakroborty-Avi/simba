<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>simba.mixins.timeseries_features_mixin &mdash; SimBA 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/simba_theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />

  
    <link rel="shortcut icon" href="../../../_static/readthedocs_logo.png"/>
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SimBA
              <img src="../../../_static/readthedocs_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API REFERENCE:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">NOTEBOOKS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks.html">Notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">USER GUIDE / TUTORIALS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">WALKTHROUGHS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../walkthroughs.html">Walkthroughs</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">LABELLING TUTORIALS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../labelling.html">Labelling</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">FAQ:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials_rst/FAQ.html">Friendly Asked Questions (FAQ)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DOCS:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../docs/workflow.html">SimBA basic workflow</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">ABOUT:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../credits.html#who-writes-this-stuff">Who writes this stuff??</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../links.html">Links</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SimBA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">simba.mixins.timeseries_features_mixin</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for simba.mixins.timeseries_features_mixin</h1><div class="highlight"><pre>
<span></span><span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Simon Nilsson&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="p">(</span><span class="n">boolean</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">jit</span><span class="p">,</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span><span class="p">,</span> <span class="n">typed</span><span class="p">,</span>
                   <span class="n">types</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numba.typed</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="kn">import</span> <span class="n">as_strided</span>
<span class="kn">from</span> <span class="nn">statsmodels.tsa.stattools</span> <span class="kn">import</span> <span class="p">(</span><span class="n">adfuller</span><span class="p">,</span> <span class="n">grangercausalitytests</span><span class="p">,</span> <span class="n">kpss</span><span class="p">,</span>
                                       <span class="n">zivot_andrews</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">simba.utils.errors</span> <span class="kn">import</span> <span class="n">InvalidInputError</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">get_type_hints</span>

<span class="kn">from</span> <span class="nn">simba.utils.checks</span> <span class="kn">import</span> <span class="p">(</span><span class="n">check_float</span><span class="p">,</span> <span class="n">check_instance</span><span class="p">,</span> <span class="n">check_int</span><span class="p">,</span>
                                <span class="n">check_str</span><span class="p">,</span> <span class="n">check_that_column_exist</span><span class="p">,</span>
                                <span class="n">check_valid_array</span><span class="p">,</span> <span class="n">check_valid_lst</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">simba.utils.read_write</span> <span class="kn">import</span> <span class="n">find_core_cnt</span>


<div class="viewcode-block" id="TimeseriesFeatureMixin"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin">[docs]</a><span class="k">class</span> <span class="nc">TimeseriesFeatureMixin</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Time-series methods focused on signal complexity in sliding windows. Mainly in time-domain - fft methods (through e.g. scipy)</span>
<span class="sd">    I&#39;ve found so far has not been fast enough for rolling windows in large datasets.</span>

<span class="sd">    .. image:: _static/img/ts_runtimes.png</span>
<span class="sd">       :width: 1200</span>
<span class="sd">       :align: center</span>

<span class="sd">    .. note::</span>
<span class="sd">       Many method has numba typed `signatures &lt;https://numba.pydata.org/numba-doc/latest/reference/types.html&gt;`_ to decrease</span>
<span class="sd">       compilation time through reduced type inference. Make sure to pass the correct dtypes as indicated by signature decorators.</span>

<span class="sd">    .. important::</span>
<span class="sd">       See references for mature packages computing more extensive timeseries measurements</span>

<span class="sd">       .. [1] `cesium &lt;https://github.com/cesium-ml/cesium&gt;`_.</span>
<span class="sd">       .. [2] `eeglib &lt;https://github.com/Xiul109/eeglib&gt;`_.</span>
<span class="sd">       .. [3] `antropy &lt;https://github.com/raphaelvallat/antropy&gt;`_.</span>
<span class="sd">       .. [4] `tsfresh &lt;https://tsfresh.readthedocs.io&gt;`_.</span>
<span class="sd">       .. [5] `pycaret &lt;https://github.com/pycaret/pycaret&gt;`_.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="TimeseriesFeatureMixin.hjort_parameters"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.hjort_parameters">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:],)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hjort_parameters</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Hjorth parameters for a given time series data. Hjorth parameters describe</span>
<span class="sd">        mobility, complexity, and activity of a time series.</span>

<span class="sd">        :param numpy.ndarray data: A 1-dimensional numpy array containing the time series data.</span>
<span class="sd">        :return: tuple</span>
<span class="sd">            A tuple containing the following Hjorth parameters:</span>
<span class="sd">            - activity (float): The activity of the time series, which is the variance of the input data.</span>
<span class="sd">            - mobility (float): The mobility of the time series, calculated as the square root of the variance</span>
<span class="sd">              of the first derivative of the input data divided by the variance of the input data.</span>
<span class="sd">            - complexity (float): The complexity of the time series, calculated as the square root of the variance</span>
<span class="sd">              of the second derivative of the input data divided by the variance of the first derivative, and then</span>
<span class="sd">              divided by the mobility.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1.0, 2.0, 3.0, 4.0, 5.0], dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().hjort_parameters(data)</span>
<span class="sd">        &gt;&gt;&gt; (2.5, 0.5, 0.4082482904638631)</span>

<span class="sd">        :math:`mobility = \sqrt{\\frac{dx_{var}}{x_{var}}}`</span>

<span class="sd">        :math:`complexity = \sqrt{\\frac{ddx_{var}}{dx_{var}} / mobility}`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">ddx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">x_var</span><span class="p">,</span> <span class="n">dx_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x_var</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dx_var</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">ddx_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ddx</span><span class="p">)</span>
        <span class="n">mobility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx_var</span> <span class="o">/</span> <span class="n">x_var</span><span class="p">)</span>
        <span class="n">complexity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ddx_var</span> <span class="o">/</span> <span class="n">dx_var</span><span class="p">)</span> <span class="o">/</span> <span class="n">mobility</span>
        <span class="n">activity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">activity</span><span class="p">,</span> <span class="n">mobility</span><span class="p">,</span> <span class="n">complexity</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_hjort_parameters"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_hjort_parameters">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_hjort_parameters</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Hjorth parameters, including mobility, complexity, and activity, for</span>
<span class="sd">        sliding windows of varying sizes applied to the input data array.</span>

<span class="sd">        :param np.ndarray data: Input data array.</span>
<span class="sd">        :param np.ndarray window_sizes: Array of window sizes (in seconds).</span>
<span class="sd">        :param int sample_rate: Sampling rate of the data in samples per second.</span>
<span class="sd">        :return np.ndarray: An array containing Hjorth parameters for each window size and data point.</span>
<span class="sd">                   The shape of the result array is (3, data.shape[0], window_sizes.shape[0]).</span>
<span class="sd">                   The three parameters are stored in the first dimension (0 - mobility, 1 - complexity,</span>
<span class="sd">                   2 - activity), and the remaining dimensions correspond to data points and window sizes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">sample</span><span class="p">))</span>
                <span class="n">ddx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">dx</span><span class="p">))</span>
                <span class="n">x_var</span><span class="p">,</span> <span class="n">dx_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">sample</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x_var</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dx_var</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ddx_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">ddx</span><span class="p">)</span>
                    <span class="n">mobility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx_var</span> <span class="o">/</span> <span class="n">x_var</span><span class="p">)</span>
                    <span class="n">complexity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ddx_var</span> <span class="o">/</span> <span class="n">dx_var</span><span class="p">)</span> <span class="o">/</span> <span class="n">mobility</span>
                    <span class="n">activity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mobility</span>
                    <span class="n">results</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">complexity</span>
                    <span class="n">results</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">activity</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.local_maxima_minima"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.local_maxima_minima">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">([(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">boolean</span><span class="p">),</span> <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">True</span><span class="p">))])</span>
    <span class="k">def</span> <span class="nf">local_maxima_minima</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">maxima</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the local maxima or minima defined as values which are higher or lower than immediately preceding and proceeding time-series neighbors, repectively.</span>
<span class="sd">        Returns 2D np.ndarray with columns representing idx and values of local maxima.</span>

<span class="sd">        .. image:: _static/img/local_maxima_minima.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>


<span class="sd">        :param np.ndarray data: Time-series data.</span>
<span class="sd">        :param bool maxima: If True, returns maxima. Else, minima.</span>
<span class="sd">        :return np.ndarray: 2D np.ndarray with columns representing idx in input data in first column and values of local maxima in second column</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([3.9, 7.5,  4.2, 6.2, 7.5, 3.9, 6.2, 6.5, 7.2, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().local_maxima_minima(data=data, maxima=True)</span>
<span class="sd">        &gt;&gt;&gt; [[1, 7.5], [4, 7.5], [9, 9.5]]</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().local_maxima_minima(data=data, maxima=False)</span>
<span class="sd">        &gt;&gt;&gt; [[0, 3.9], [2, 4.2], [5, 3.9]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">maxima</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="o">-</span><span class="n">data</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">maxima</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">maxima</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">maxima</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">results</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">results</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.crossings"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.crossings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">crossings</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the count in time-series where sequential values crosses a defined value.</span>

<span class="sd">        .. image:: _static/img/crossings.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: Time-series data.</span>
<span class="sd">        :param float val: Cross value. E.g., to count the number of zero-crossings, pass `0`.</span>
<span class="sd">        :return int: Count of events where sequential values crosses ``val``.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([3.9, 7.5,  4.2, 6.2, 7.5, 3.9, 6.2, 6.5, 7.2, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().crossings(data=data, val=7)</span>
<span class="sd">        &gt;&gt;&gt; 5</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cnt</span><span class="p">,</span> <span class="n">last_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">last_val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">current_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="n">current_val</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">last_val</span> <span class="o">!=</span> <span class="n">current_val</span><span class="p">:</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">last_val</span> <span class="o">=</span> <span class="n">current_val</span>

        <span class="k">return</span> <span class="n">cnt</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_crossings"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_crossings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64,  float64[:], int64,)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_crossings</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the number of crossings over sliding windows in a data array.</span>

<span class="sd">        Computes the number of times a value in the data array crosses a given threshold</span>
<span class="sd">        value within sliding windows of varying sizes. The number of crossings is computed for each</span>
<span class="sd">        window size and stored in the result array where columns represents time windows.</span>

<span class="sd">        .. note::</span>
<span class="sd">           For frames occurring before a complete time window, -1.0 is returned.</span>

<span class="sd">        .. image:: _static/img/sliding_crossings.png</span>
<span class="sd">           :width: 1500</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: Input data array.</span>
<span class="sd">        :param float val: Threshold value for crossings.</span>
<span class="sd">        :param np.ndarray time_windows: Array of window sizes (in seconds).</span>
<span class="sd">        :param int sample_rate: Sampling rate of the data in samples per second.</span>
<span class="sd">        :return np.ndarray: An array containing the number of crossings for each window size and data point. The shape of the result array is (data.shape[0], window_sizes.shape[0]).</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([3.9, 7.5,  4.2, 6.2, 7.5, 3.9, 6.2, 6.5, 7.2, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; results = TimeseriesFeatureMixin().sliding_crossings(data=data, time_windows=np.array([1.0]), fps=2.0, val=7.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">cnt</span><span class="p">,</span> <span class="n">last_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                    <span class="n">last_val</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">current_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
                        <span class="n">current_val</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">last_val</span> <span class="o">!=</span> <span class="n">current_val</span><span class="p">:</span>
                        <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">last_val</span> <span class="o">=</span> <span class="n">current_val</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.percentile_difference"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.percentile_difference">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64, int64, )&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">percentile_difference</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">upper_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lower_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the difference between the ``upper`` and ``lower`` percentiles of the data as</span>
<span class="sd">        a percentage of the median value. Helps understanding the spread or variability of the data within specified percentiles.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `cesium &lt;https://github.com/cesium-ml/cesium&gt;`_.</span>

<span class="sd">        .. image:: _static/img/percentile_difference.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :parameter np.ndarray data: 1D array of representing time-series.</span>
<span class="sd">        :parameter int upper_pct: Upper-boundary percentile.</span>
<span class="sd">        :parameter int lower_pct: Lower-boundary percentile.</span>
<span class="sd">        :returns float: The difference between the ``upper`` and ``lower`` percentiles of the data as a percentage of the median value.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([3.9, 7.5,  4.2, 6.2, 7.5, 3.9, 6.2, 6.5, 7.2, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().percentile_difference(data=data, upper_pct=95, lower_pct=5)</span>
<span class="sd">        &gt;&gt;&gt; 0.7401574764125177</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">upper_val</span><span class="p">,</span> <span class="n">lower_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">upper_pct</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">lower_pct</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper_val</span> <span class="o">-</span> <span class="n">lower_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_percentile_difference"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_percentile_difference">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64, int64, float64[:], int64, )&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_percentile_difference</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">upper_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">lower_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted computes the difference between the upper and lower percentiles within a sliding window for each position</span>
<span class="sd">        in the time series using various window sizes. It returns a 2D array where each row corresponds to a position in the time series,</span>
<span class="sd">        and each column corresponds to a different window size. The results are calculated as the absolute difference between</span>
<span class="sd">        upper and lower percentiles divided by the median of the window.</span>

<span class="sd">        :param np.ndarray data: The input time series data.</span>
<span class="sd">        :param int upper_pct: The upper percentile value for the window (e.g., 95 for the 95th percentile).</span>
<span class="sd">        :param int lower_pct: The lower percentile value for the window (e.g., 5 for the 5th percentile).</span>
<span class="sd">        :param np.ndarray window_sizes: An array of window sizes (in seconds) to use for the sliding calculation.</span>
<span class="sd">        :param int sample_rate: The sampling rate (samples per second) of the time series data.</span>
<span class="sd">        :return np.ndarray: A 2D array containing the difference between upper and lower percentiles for each window size.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">upper_val</span><span class="p">,</span> <span class="n">lower_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">upper_pct</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
                    <span class="n">sample</span><span class="p">,</span> <span class="n">lower_pct</span>
                <span class="p">)</span>
                <span class="n">median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">median</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">upper_val</span> <span class="o">-</span> <span class="n">lower_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">median</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.percent_beyond_n_std"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.percent_beyond_n_std">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64,)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">percent_beyond_n_std</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the ratio of values in time-series more than N standard deviations from the mean of the time-series.</span>

<span class="sd">        :parameter np.ndarray data: 1D array representing time-series.</span>
<span class="sd">        :parameter float n: Standard deviation cut-off.</span>
<span class="sd">        :returns float: Ratio of values in ``data`` that fall more than ``n`` standard deviations from mean of ``data``.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `cesium &lt;https://github.com/cesium-ml/cesium&gt;`_.</span>

<span class="sd">           Oddetity: mean calculation is incorrect if passing float32 data but correct if passing float64.</span>

<span class="sd">        .. image:: _static/img/percent_beyond_n_std.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([3.9, 7.5,  4.2, 6.2, 7.5, 3.9, 6.2, 6.5, 7.2, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().percent_beyond_n_std(data=data, n=1)</span>
<span class="sd">        &gt;&gt;&gt; 0.1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="p">(</span><span class="n">std</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_percent_beyond_n_std"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_percent_beyond_n_std">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64, float64[:], int64,)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_percent_beyond_n_std</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computed the percentage of data points that exceed &#39;n&#39; standard deviations from the mean for each position in</span>
<span class="sd">        the time series using various window sizes. It returns a 2D array where each row corresponds to a position in the time series,</span>
<span class="sd">        and each column corresponds to a different window size. The results are given as a percentage of data points beyond the threshold.</span>

<span class="sd">        :param np.ndarray data: The input time series data.</span>
<span class="sd">        :param float n: The number of standard deviations to determine the threshold.</span>
<span class="sd">        :param np.ndarray window_sizes: An array of window sizes (in seconds) to use for the sliding calculation.</span>
<span class="sd">        :param int sample_rate: The sampling rate (samples per second) of the time series data.</span>
<span class="sd">        :return np.ndarray: A 2D array containing the percentage of data points beyond the specified &#39;n&#39; standard deviations for each window size.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">[:],</span> <span class="n">int64</span><span class="p">),</span>
            <span class="p">(</span><span class="n">int64</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">[:],</span> <span class="n">int64</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_unique</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">unique_cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_cnt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="TimeseriesFeatureMixin.percent_in_percentile_window"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.percent_in_percentile_window">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64, int64, )&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">percent_in_percentile_window</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">upper_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">lower_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the ratio of values in time-series that fall between the ``upper`` and ``lower`` percentile.</span>

<span class="sd">        :parameter np.ndarray data: 1D array of representing time-series.</span>
<span class="sd">        :parameter int upper_pct: Upper-boundary percentile.</span>
<span class="sd">        :parameter int lower_pct: Lower-boundary percentile.</span>
<span class="sd">        :returns float: Ratio of values in ``data`` that fall within ``upper_pct`` and ``lower_pct`` percentiles.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `cesium &lt;https://github.com/cesium-ml/cesium&gt;`_.</span>

<span class="sd">        .. image:: _static/img/percent_in_percentile_window.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([3.9, 7.5,  4.2, 6.2, 7.5, 3.9, 6.2, 6.5, 7.2, 9.5]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().percent_in_percentile_window(data, upper_pct=70, lower_pct=30)</span>
<span class="sd">        &gt;&gt;&gt; 0.4</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">upper_val</span><span class="p">,</span> <span class="n">lower_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">upper_pct</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">lower_pct</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="n">upper_val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">lower_val</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_percent_in_percentile_window"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_percent_in_percentile_window">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64, int64, float64[:], int64)&quot;</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_percent_in_percentile_window</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">upper_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">lower_pct</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the percentage of data points falling within a percentile window in a sliding manner.</span>

<span class="sd">        The function computes the percentage of data points within the specified percentile window for each position in the time series</span>
<span class="sd">        using various window sizes. It returns a 2D array where each row corresponds to a position in the time series, and each column</span>
<span class="sd">        corresponds to a different window size. The results are given as a percentage of data points within the percentile window.</span>

<span class="sd">        :param np.ndarray data: The input time series data.</span>
<span class="sd">        :param int upper_pct: The upper percentile value for the window (e.g., 95 for the 95th percentile).</span>
<span class="sd">        :param int lower_pct: The lower percentile value for the window (e.g., 5 for the 5th percentile).</span>
<span class="sd">        :param np.ndarray window_sizes: An array of window sizes (in seconds) to use for the sliding calculation.</span>
<span class="sd">        :param int sample_rate: The sampling rate (samples per second) of the time series data.</span>
<span class="sd">        :return np.ndarray: A 2D array containing the percentage of data points within the percentile window for each window size.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">upper_val</span><span class="p">,</span> <span class="n">lower_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">upper_pct</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">lower_pct</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">((</span><span class="n">sample</span> <span class="o">&lt;=</span> <span class="n">upper_val</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample</span> <span class="o">&gt;=</span> <span class="n">lower_val</span><span class="p">))</span>
                    <span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">/</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.petrosian_fractal_dimension"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.petrosian_fractal_dimension">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:],)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">petrosian_fractal_dimension</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the Petrosian Fractal Dimension (PFD) of a given time series data. The PFD is a measure of the</span>
<span class="sd">        irregularity or self-similarity of a time series. Larger values indicate higher complexity. Lower values indicate lower complexity.</span>

<span class="sd">        .. note::</span>
<span class="sd">           The PFD is computed based on the number of sign changes in the first derivative of the time series. If the input data is empty or no sign changes are found, the PFD is returned as -1.0. Adapted from `eeglib &lt;https://github.com/Xiul109/eeglib/&gt;`_.</span>

<span class="sd">        .. math::</span>
<span class="sd">           PFD = \\frac{\\log_{10}(N)}{\\log_{10}(N) + \\log_{10}\\left(\\frac{N}{N + 0.4 \\cdot zC}\\right)}</span>

<span class="sd">        :parameter np.ndarray data: A 1-dimensional numpy array containing the time series data.</span>
<span class="sd">        :returns float: The Petrosian Fractal Dimension of the input time series.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 50, int(44100 * 2.0), endpoint=False)</span>
<span class="sd">        &gt;&gt;&gt; sine_wave = 1.0 * np.sin(2 * np.pi * 1.0 * t).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().petrosian_fractal_dimension(data=sine_wave)</span>
<span class="sd">        &gt;&gt;&gt; 1.0000398187022719</span>
<span class="sd">        &gt;&gt;&gt; np.random.shuffle(sine_wave)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().petrosian_fractal_dimension(data=sine_wave)</span>
<span class="sd">        &gt;&gt;&gt; 1.0211625348743218</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">derivative</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">derivative</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">zC</span><span class="p">,</span> <span class="n">last_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">derivative</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">last_val</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">derivative</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">current_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">derivative</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">current_val</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">last_val</span> <span class="o">!=</span> <span class="n">current_val</span><span class="p">:</span>
                <span class="n">zC</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">last_val</span> <span class="o">=</span> <span class="n">current_val</span>
        <span class="k">if</span> <span class="n">zC</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">zC</span><span class="p">))</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_petrosian_fractal_dimension"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_petrosian_fractal_dimension">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_petrosian_fractal_dimension</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of Petrosian Fractal Dimension over sliding windows in a data array.</span>

<span class="sd">        This method computes the Petrosian Fractal Dimension for sliding windows of varying sizes applied</span>
<span class="sd">        to the input data array. The Petrosian Fractal Dimension is a measure of signal complexity.</span>

<span class="sd">        :param np.ndarray data: Input data array.</span>
<span class="sd">        :param np.ndarray window_sizes: Array of window sizes (in seconds).</span>
<span class="sd">        :param int sample_rate: Sampling rate of the data in samples per second.</span>
<span class="sd">        :return np.ndarray: An array containing Petrosian Fractal Dimension values for each window size and data</span>
<span class="sd">                            point. The shape of the result array is (data.shape[0], window_sizes.shape[0]).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">derivative</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">sample</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">derivative</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zC</span><span class="p">,</span> <span class="n">last_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">derivative</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">last_val</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">derivative</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">current_val</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">derivative</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">current_val</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">last_val</span> <span class="o">!=</span> <span class="n">current_val</span><span class="p">:</span>
                            <span class="n">zC</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">last_val</span> <span class="o">=</span> <span class="n">current_val</span>
                    <span class="k">if</span> <span class="n">zC</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">zC</span><span class="p">))</span>
                        <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.higuchi_fractal_dimension"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.higuchi_fractal_dimension">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">higuchi_fractal_dimension</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">kmax</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the Higuchi Fractal Dimension of a given time series data. The Higuchi Fractal Dimension provides a measure of the fractal</span>
<span class="sd">        complexity of a time series.</span>

<span class="sd">        The maximum value of k used in the calculation. Increasing kmax considers longer sequences</span>
<span class="sd">            of data, providing a more detailed analysis of fractal complexity. Default is 10.</span>

<span class="sd">        :parameter np.ndarray data: A 1-dimensional numpy array containing the time series data.</span>
<span class="sd">        :parameter int kmax: The maximum value of k used in the calculation. Increasing kmax considers longer sequences of data, providing a more detailed analysis of fractal complexity. Default is 10.</span>
<span class="sd">        :returns float: The Higuchi Fractal Dimension of the input time series.</span>

<span class="sd">        .. note::</span>
<span class="sd">           - Adapted from `eeglib &lt;https://github.com/Xiul109/eeglib/&gt;`_.</span>

<span class="sd">        .. math::</span>
<span class="sd">           HFD = \\frac{\\log(N)}{\\log(N) + \\log\\left(\\frac{N}{N + 0.4 \\cdot zC}\\right)}</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 50, int(44100 * 2.0), endpoint=False)</span>
<span class="sd">        &gt;&gt;&gt; sine_wave = 1.0 * np.sin(2 * np.pi * 1.0 * t).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; sine_wave = (sine_wave - np.min(sine_wave)) / (np.max(sine_wave) - np.min(sine_wave))</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().higuchi_fractal_dimension(data=data, kmax=10)</span>
<span class="sd">        &gt;&gt;&gt; 1.0001506805419922</span>
<span class="sd">        &gt;&gt;&gt; np.random.shuffle(sine_wave)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().higuchi_fractal_dimension(data=data, kmax=10)</span>
<span class="sd">        &gt;&gt;&gt; 1.9996402263641357</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">L</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">kmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kmax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">kmax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">Lk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="n">Lmk</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">//</span> <span class="n">k</span><span class="p">):</span>
                    <span class="n">Lmk</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">m</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="n">k</span><span class="p">])</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">//</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span>
                <span class="k">if</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">Lk</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">Lmk</span> <span class="o">*</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(((</span><span class="n">N</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">//</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">Laux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Lk</span><span class="p">)</span>
            <span class="n">Laux</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="o">/</span> <span class="n">k</span> <span class="k">if</span> <span class="n">Laux</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">Laux</span>
            <span class="n">L</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Laux</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.permutation_entropy"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.permutation_entropy">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], int64, int64,)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">permutation_entropy</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the permutation entropy of a time series.</span>

<span class="sd">        Permutation entropy is a measure of the complexity of a time series data by quantifying</span>
<span class="sd">        the irregularity and unpredictability of its order patterns. It is computed based on the</span>
<span class="sd">        frequency of unique order patterns of a given dimension in the time series data.</span>

<span class="sd">        The permutation entropy (PE) is calculated using the following formula:</span>

<span class="sd">        .. math::</span>
<span class="sd">            PE = - \\sum(p_i \\log(p_i))</span>

<span class="sd">        where:</span>
<span class="sd">        - PE is the permutation entropy.</span>
<span class="sd">        - p_i is the probability of each unique order pattern.</span>

<span class="sd">        :param numpy.ndarray data: The time series data for which permutation entropy is calculated.</span>
<span class="sd">        :param int dimension: It specifies the length of the order patterns to be considered.</span>
<span class="sd">        :param int delay: Time delay between elements in an order pattern.</span>
<span class="sd">        :return float: The permutation entropy of the time series, indicating its complexity and predictability. A higher permutation entropy value indicates higher complexity and unpredictability in the time series.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; t = np.linspace(0, 50, int(44100 * 2.0), endpoint=False)</span>
<span class="sd">        &gt;&gt;&gt; sine_wave = 1.0 * np.sin(2 * np.pi * 1.0 * t).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().permutation_entropy(data=sine_wave, dimension=3, delay=1)</span>
<span class="sd">        &gt;&gt;&gt; 0.701970058666407</span>
<span class="sd">        &gt;&gt;&gt; np.random.shuffle(sine_wave)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().permutation_entropy(data=sine_wave, dimension=3, delay=1)</span>
<span class="sd">        &gt;&gt;&gt; 1.79172449934604</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">List</span><span class="p">(),</span> <span class="n">List</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">delay</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dimension</span> <span class="o">*</span> <span class="n">delay</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
            <span class="n">permutation</span> <span class="o">=</span> <span class="n">List</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]))</span>
            <span class="n">is_unique</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">permutations</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutation</span><span class="p">):</span>
                    <span class="n">is_equal</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">permutation</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                            <span class="n">is_equal</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="n">is_equal</span><span class="p">:</span>
                        <span class="n">is_unique</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">counts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">is_unique</span><span class="p">:</span>
                <span class="n">permutations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
                <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">total_permutations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">permutations</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">total_permutations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">total_permutations</span><span class="p">):</span>
            <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">dimension</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">delay</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.line_length"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.line_length">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:],)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">line_length</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the line length of a 1D array.</span>

<span class="sd">        Line length is a measure of signal complexity and is computed by summing the absolute</span>
<span class="sd">        differences between consecutive elements of the input array. Used in EEG</span>
<span class="sd">        analysis and other signal processing applications to quantify variations in the signal.</span>

<span class="sd">        :param numpy.ndarray data: The 1D array for which the line length is to be calculated.</span>
<span class="sd">        :return float: The line length of the input array, indicating its complexity.</span>

<span class="sd">        .. math::</span>

<span class="sd">            LL = \sum_{i=1}^{N-1} |x[i] - x[i-1]|</span>

<span class="sd">        where:</span>
<span class="sd">        - LL is the line length.</span>
<span class="sd">        - N is the number of elements in the input data array.</span>
<span class="sd">        - x[i] represents the value of the data at index i.</span>


<span class="sd">        .. image:: _static/img/line_length.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 4, 2, 3, 5, 6, 8, 7, 9, 10]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().line_length(data=data)</span>
<span class="sd">        &gt;&gt;&gt; 12.0</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_line_length"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_line_length">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_line_length</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of  sliding line length for a given time series using different window sizes.</span>

<span class="sd">        The function computes line length for the input data using various window sizes. It returns a 2D array where each row</span>
<span class="sd">        corresponds to a position in the time series, and each column corresponds to a different window size. The line length</span>
<span class="sd">        is calculated for each window, and the results are returned as a 2D array of float32 values.</span>

<span class="sd">        :param np.ndarray data: 1D array input data.</span>
<span class="sd">        :param window_sizes: An array of window sizes (in seconds) to use for line length calculation.</span>
<span class="sd">        :param sample_rate: The sampling rate (samples per second) of the time series data.</span>
<span class="sd">        :return np.ndarray: A 2D array containing line length values for each window size at each position in the time series.</span>

<span class="sd">        .. image:: _static/img/sliding_line_length.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 4, 2, 3, 5, 6, 8, 7, 9, 10]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().sliding_line_length(data=data, window_sizes=np.array([1.0]), sample_rate=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_variance"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_variance">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_variance</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the variance of data within sliding windows of varying sizes applied to</span>
<span class="sd">        the input data array. Variance is a measure of data dispersion or spread.</span>

<span class="sd">        .. image:: _static/img/sliding_variance.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param data: 1d input data array.</span>
<span class="sd">        :param window_sizes: Array of window sizes (in seconds).</span>
<span class="sd">        :param sample_rate: Sampling rate of the data in samples per second.</span>
<span class="sd">        :return: Variance values for each window size and data point. The shape of the result array is (data.shape[0], window_sizes.shape[0]).</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 2, 3, 1, 2, 9, 17, 2, 10, 4]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().sliding_variance(data=data, window_sizes=np.array([0.5]), sample_rate=10)</span>
<span class="sd">        &gt;&gt;&gt; [[-1.],[-1.],[-1.],[-1.],[ 0.56],[ 8.23],[35.84],[39.20],[34.15],[30.15]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_descriptive_statistics"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_descriptive_statistics">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="s2">&quot;(float32[:], float64[:], int64, types.ListType(types.unicode_type))&quot;</span><span class="p">,</span>
        <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_descriptive_statistics</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">window_sizes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">statistics</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;var&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;mad&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;mac&quot;</span><span class="p">,</span> <span class="s2">&quot;rms&quot;</span><span class="p">,</span> <span class="s2">&quot;absenergy&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of descriptive statistics over sliding windows in 1D data array.</span>

<span class="sd">        Computes various descriptive statistics (e.g., variance, maximum, minimum, standard deviation,</span>
<span class="sd">        median, mean, median absolute deviation) for sliding windows of varying sizes applied to the input data array.</span>

<span class="sd">        :param np.ndarray data: 1D input data array.</span>
<span class="sd">        :param np.ndarray window_sizes: Array of window sizes (in seconds).</span>
<span class="sd">        :param int sample_rate: Sampling rate of the data in samples per second.</span>
<span class="sd">        :param types.ListType(types.unicode_type) statistics: List of statistics to compute. Options: &#39;var&#39;, &#39;max&#39;, &#39;min&#39;, &#39;std&#39;, &#39;median&#39;, &#39;mean&#39;, &#39;mad&#39;, &#39;sum&#39;, &#39;mac&#39;, &#39;rms&#39;, &#39;abs_energy&#39;.</span>
<span class="sd">        :return np.ndarray: Array containing the selected descriptive statistics for each window size, data point, and statistic type. The shape of the result array is (len(statistics), data.shape[0], window_sizes.shape[0).</span>

<span class="sd">        .. note::</span>
<span class="sd">           - The `statistics` parameter should be a list containing one or more of the following statistics:</span>
<span class="sd">           &#39;var&#39; (variance), &#39;max&#39; (maximum), &#39;min&#39; (minimum), &#39;std&#39; (standard deviation), &#39;median&#39; (median),</span>
<span class="sd">           &#39;mean&#39; (mean), &#39;mad&#39; (median absolute deviation), &#39;sum&#39; (sum), &#39;mac&#39; (mean absolute change),</span>
<span class="sd">           &#39;rms&#39; (root mean square), &#39;absenergy&#39; (absolute energy).</span>
<span class="sd">           - If the statistics list is [&#39;var&#39;, &#39;max&#39;, &#39;mean&#39;], the</span>
<span class="sd">           3rd dimension order in the result array will be: [variance, maximum, mean]</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 4, 2, 3, 5, 6, 8, 7, 9, 10]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; results = TimeseriesFeatureMixin().sliding_descriptive_statistics(data=data, window_sizes=np.array([1.0, 5.0]), sample_rate=2, statistics=typed.List([&#39;var&#39;, &#39;max&#39;]))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">statistics</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">statistics</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_sizes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;var&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;std&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mad&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sample</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">sample</span><span class="p">)))</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;mac&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">sample</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;rms&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">sample</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">statistics</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;absenergy&quot;</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sample</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.dominant_frequencies"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.dominant_frequencies">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dominant_frequencies</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">window_function</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;Hann&quot;</span><span class="p">,</span> <span class="s2">&quot;Hamming&quot;</span><span class="p">,</span> <span class="s2">&quot;Blackman&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the K dominant frequencies within a feature vector&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">window_function</span> <span class="o">==</span> <span class="s2">&quot;Hann&quot;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">window_function</span> <span class="o">==</span> <span class="s2">&quot;Hamming&quot;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">window_function</span> <span class="o">==</span> <span class="s2">&quot;Blackman&quot;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="n">fft_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fps</span><span class="p">)</span>
        <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fft_result</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)[</span><span class="o">-</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.longest_strike"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.longest_strike">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">boolean</span><span class="p">),</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">True</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">longest_strike</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">above</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the length of the longest consecutive sequence of values in the input data that either exceed</span>
<span class="sd">        or fall below a specified threshold.</span>

<span class="sd">        .. image:: _static/img/longest_strike.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: The input 1D NumPy array containing the values to be analyzed.</span>
<span class="sd">        :param float threshold: The threshold value used for the comparison.</span>
<span class="sd">        :param bool above: If True, the function looks for strikes where values are above or equal to the threshold. If False, it looks for strikes where values are below or equal to the threshold.</span>
<span class="sd">        :return int: The length of the longest strike that satisfies the condition.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 8, 2, 10, 8, 6, 8, 1, 1, 1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().longest_strike(data=data, threshold=7, above=True)</span>
<span class="sd">        &gt;&gt;&gt; 2</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().longest_strike(data=data, threshold=7, above=False)</span>
<span class="sd">        &gt;&gt;&gt; 3</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">above</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">:</span>
                    <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">cnt</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_longest_strike"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_longest_strike">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">[:],</span> <span class="n">int64</span><span class="p">,</span> <span class="n">boolean</span><span class="p">),</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">float64</span><span class="p">[:],</span> <span class="n">int64</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">True</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_longest_strike</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">above</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the length of the longest strike of values within sliding time windows that satisfy a given condition.</span>

<span class="sd">        Calculates the length of the longest consecutive sequence of values in a 1D NumPy array, where each</span>
<span class="sd">        sequence is determined by a sliding time window. The condition is specified by a threshold, and</span>
<span class="sd">        you can choose whether to look for values above or below the threshold.</span>

<span class="sd">        .. image:: _static/img/sliding_longest_strike.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: The input 1D NumPy array containing the values to be analyzed.</span>
<span class="sd">        :param float threshold: The threshold value used for the comparison.</span>
<span class="sd">        :param np.ndarray time_windows: An array containing the time window sizes in seconds.</span>
<span class="sd">        :param int sample_rate: The sample rate in samples per second.</span>
<span class="sd">        :param bool above: If True, the function looks for strikes where values are above or equal to the threshold. If False, it looks for strikes where values are below or equal to the threshold.</span>
<span class="sd">        :return np.ndarray: A 2D NumPy array with dimensions (data.shape[0], time_windows.shape[0]). Each element in the array represents the length of the longest strike that satisfies the condition for the</span>
<span class="sd">        corresponding time window.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 8, 2, 10, 8, 6, 8, 1, 1, 1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().sliding_longest_strike(data=data, threshold=7, above=True, time_windows=np.array([1.0]), sample_rate=2)</span>
<span class="sd">        &gt;&gt;&gt; [[-1.][ 1.][ 1.][ 1.][ 2.][ 1.][ 1.][ 1.][ 0.][ 0.]]</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().sliding_longest_strike(data=data, threshold=7, above=True, time_windows=np.array([1.0]), sample_rate=2)</span>
<span class="sd">        &gt;&gt;&gt; [[-1.][ 1.][ 1.][ 1.][ 0.][ 1.][ 1.][ 1.][ 2.][ 2.]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l1</span><span class="p">,</span> <span class="n">r1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l1</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

                <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">above</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">:</span>
                            <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="k">while</span> <span class="n">sample</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sample</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">:</span>
                            <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
                            <span class="k">while</span> <span class="n">sample</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">threshold</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">cnt</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>

                    <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">cnt</span>
                    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
                        <span class="k">break</span>
                    <span class="n">r</span><span class="p">,</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="mi">0</span>

                <span class="n">results</span><span class="p">[</span><span class="n">r1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

            <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.time_since_previous_threshold"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.time_since_previous_threshold">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">boolean</span><span class="p">),</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">True</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">time_since_previous_threshold</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">above</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the time (in seconds) that has elapsed since the last occurrence of a value above (or below)</span>
<span class="sd">        a specified threshold in a time series. The time series is assumed to have a constant sample rate.</span>

<span class="sd">        .. image:: _static/img/time_since_previous_threshold.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: The input 1D array containing the time series data.</span>
<span class="sd">        :param int threshold: The threshold value used for the comparison.</span>
<span class="sd">        :param int fps: The sample rate of the time series in samples per second.</span>
<span class="sd">        :param bool above: If True, the function looks for values above or equal to the threshold. If False, it looks for values below or equal to the threshold.</span>
<span class="sd">        :return np.ndarray: A 1D array of the same length as the input data. Each element represents the time elapsed (in seconds) since the last occurrence of the threshold value. If no threshold value is found before the current data point, the corresponding result is set to -1.0.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 8, 2, 10, 8, 6, 8, 1, 1, 1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().time_since_previous_threshold(data=data, threshold=7.0, above=True, sample_rate=2.0)</span>
<span class="sd">        &gt;&gt;&gt; [-1. ,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  1. ,  1.5]</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().time_since_previous_threshold(data=data, threshold=7.0, above=False, sample_rate=2.0)</span>
<span class="sd">        &gt;&gt;&gt; [0. , 0.5, 0. , 0.5, 1. , 0. , 0.5, 0. , 0. , 0. ]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">above</span><span class="p">:</span>
            <span class="n">criterion_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">criterion_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">above</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">above</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">criterion_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">criterion_idx</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">fps</span>

        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.time_since_previous_target_value"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.time_since_previous_target_value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">boolean</span><span class="p">),</span>
            <span class="p">(</span><span class="n">float32</span><span class="p">[:],</span> <span class="n">float64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">Omitted</span><span class="p">(</span><span class="kc">True</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">time_since_previous_target_value</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">inverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the time duration (in seconds) since the previous occurrence of a specific value in a data array.</span>

<span class="sd">        Calculates the time duration, in seconds, between each data point and the previous occurrence</span>
<span class="sd">        of a specific value within the data array.</span>

<span class="sd">        .. image:: _static/img/time_since_previous_target_value.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: The input 1D array containing the time series data.</span>
<span class="sd">        :param float value: The specific value to search for in the data array.</span>
<span class="sd">        :param int sample_rate: The sampling rate which data points were collected. It is used to calculate the time duration in seconds.</span>
<span class="sd">        :param bool inverse: If True, the function calculates the time since the previous value that is NOT equal to the specified &#39;value&#39;. If False, it calculates the time since the previous occurrence of the specified &#39;value&#39;.</span>
<span class="sd">        :returns np.ndarray: A 1D NumPy array containing the time duration (in seconds) since the previous occurrence of the specified &#39;value&#39; for each data point.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([8, 8, 2, 10, 8, 6, 8, 1, 1, 1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().time_since_previous_target_value(data=data, value=8.0, inverse=False, sample_rate=2.0)</span>
<span class="sd">        &gt;&gt;&gt; [0. , 0. , 0.5, 1. , 0. , 0.5, 0. , 0.5, 1. , 1.5])</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().time_since_previous_target_value(data=data, value=8.0, inverse=True, sample_rate=2.0)</span>
<span class="sd">        &gt;&gt;&gt; [-1. , -1. ,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0. ,  0. ]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inverse</span><span class="p">:</span>
            <span class="n">criterion_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">criterion_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span> <span class="o">!=</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">criterion_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inverse</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">inverse</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">criterion_idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">criterion_idx</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">fps</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.benford_correlation"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.benford_correlation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:],)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">benford_correlation</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jitted compute of the correlation between the Benford&#39;s Law distribution and the first-digit distribution of given data.</span>

<span class="sd">        Benford&#39;s Law describes the expected distribution of leading (first) digits in many real-life datasets. This function</span>
<span class="sd">        calculates the correlation between the expected Benford&#39;s Law distribution and the actual distribution of the</span>
<span class="sd">        first digits in the provided data.</span>

<span class="sd">        .. image:: _static/img/benford_correlation.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `tsfresh &lt;https://tsfresh.readthedocs.io/en/latest/_modules/tsfresh/feature_extraction/feature_calculators.html#benford_correlation&gt;`_.</span>

<span class="sd">           The returned correlation values are calculated using Pearson&#39;s correlation coefficient.</span>

<span class="sd">        :param np.ndarray data: The input 1D array containing the time series data.</span>
<span class="sd">        :return float: The correlation coefficient between the Benford&#39;s Law distribution and the first-digit distribution in the input data. A higher correlation value suggests that the data follows the expected distribution more closely.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 8, 2, 10, 8, 6, 8, 1, 1, 1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().benford_correlation(data=data)</span>
<span class="sd">        &gt;&gt;&gt; 0.6797500374831786</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">benford_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>
        <span class="n">first_vals</span><span class="p">,</span> <span class="n">digit_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">first_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
            <span class="n">digit_ratio</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">first_vals</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">benford_distribution</span><span class="p">,</span> <span class="n">digit_ratio</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_benford_correlation"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_benford_correlation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64[:], int64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_benford_correlation</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the sliding Benford&#39;s Law correlation coefficient for a given dataset within</span>
<span class="sd">        specified time windows.</span>

<span class="sd">        Benford&#39;s Law is a statistical phenomenon where the leading digits of many datasets follow a</span>
<span class="sd">        specific distribution pattern. This function calculates the correlation between the observed</span>
<span class="sd">        distribution of leading digits in a dataset and the ideal Benford&#39;s Law distribution.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Adapted from `tsfresh &lt;https://tsfresh.readthedocs.io/en/latest/_modules/tsfresh/feature_extraction/feature_calculators.html#benford_correlation&gt;`_.</span>

<span class="sd">           The returned correlation values are calculated using Pearson&#39;s correlation coefficient.</span>

<span class="sd">        The correlation coefficient is calculated between the observed leading digit distribution and</span>
<span class="sd">        the ideal Benford&#39;s Law distribution.</span>

<span class="sd">        .. math::</span>

<span class="sd">            P(d) = \\log_{10}\\left(1 + \\frac{1}{d}\\right) \\quad \\text{for } d \\in \{1, 2, \\ldots, 9\}</span>

<span class="sd">        :param np.ndarray data: The input 1D array containing the time series data.</span>
<span class="sd">        :param np.ndarray time_windows: A 1D array containing the time windows (in seconds) for which the correlation will be calculated at different points in the dataset.</span>
<span class="sd">        :param int sample_rate: The sample rate, indicating how many data points are collected per second.</span>
<span class="sd">        :return np.ndarray: 2D array containing the correlation coefficient values for each time window. With time window lenths represented by different columns.</span>

<span class="sd">        :examples:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 8, 2, 10, 8, 6, 8, 1, 1, 1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin.sliding_benford_correlation(data=data, time_windows=np.array([1.0]), sample_rate=2)</span>
<span class="sd">        &gt;&gt;&gt; [[ 0.][0.447][0.017][0.877][0.447][0.358][0.358][0.447][0.864][0.864]]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">benford_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">prange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">prange</span><span class="p">(</span><span class="n">window_size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">first_vals</span><span class="p">,</span> <span class="n">digit_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="mi">9</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="p">)</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">first_vals</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">//</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
                    <span class="n">digit_ratio</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">first_vals</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="n">results</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">benford_distribution</span><span class="p">,</span> <span class="n">digit_ratio</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.spike_finder"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.spike_finder">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float32[:], float64, float64, float64, float64, float64)&quot;</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">spike_finder</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">baseline</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_spike_amplitude</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_fwhm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">min_half_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify and characterize spikes in a given time-series data sequence. This method identifies spikes in the input data based on the specified criteria and characterizes</span>
<span class="sd">        each detected spike by computing its amplitude, full-width at half maximum (FWHM), and half-width.</span>

<span class="sd">        :param np.ndarray data: A 1D array containing the input data sequence to analyze.</span>
<span class="sd">        :param int sample_rate: The sample rate, indicating how many data points are collected per second.</span>
<span class="sd">        :param float baseline: The baseline value used to identify spikes. Any data point above (baseline + min_spike_amplitude) is considered part of a spike.</span>
<span class="sd">        :param float min_spike_amplitude: The minimum amplitude (above baseline) required for a spike to be considered.</span>
<span class="sd">        :param Optional[float] min_fwhm: The minimum full-width at half maximum (FWHM) for a spike to be included. If not specified, it defaults to negative infinity, meaning it is not considered for filtering.</span>
<span class="sd">        :param Optional[float] min_half_width: The minimum half-width required for a spike to be included. If not specified, it defaults to negative infinity, meaning it is not considered for filtering.</span>
<span class="sd">        :return tuple: A tuple containing three elements:</span>
<span class="sd">            - spike_idx (List[np.ndarray]): A list of 1D arrays, each representing the indices of the data points belonging to a detected spike.</span>
<span class="sd">            - spike_vals (List[np.ndarray]): A list of 1D arrays, each containing the values of the data points within a detected spike.</span>
<span class="sd">            - spike_dict (Dict[int, Dict[str, float]]): A dictionary where the keys are spike indices, and the values are dictionaries containing spike characteristics including &#39;amplitude&#39; (spike amplitude), &#39;fwhm&#39; (FWHM), and &#39;half_width&#39; (half-width).</span>

<span class="sd">        .. note::</span>
<span class="sd">           - The function uses the Numba JIT (Just-In-Time) compilation for optimized performance. Without fastmath=True there is no runtime improvement over standard numpy.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([0.1, 0.1, 0.3, 0.1, 10, 10, 8, 0.1, 0.1, 0.1, 10, 10, 8, 99, 0.1, 99, 99, 0.1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; spike_idx, spike_vals, spike_stats = TimeseriesFeatureMixin().spike_finder(data=data, baseline=1, min_spike_amplitude=5, sample_rate=2, min_fwhm=-np.inf, min_half_width=0.0002)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spike_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="n">baseline</span> <span class="o">+</span> <span class="n">min_spike_amplitude</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">spike_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
            <span class="n">spike_idxs</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">spike_idxs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">spike_idxs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">spike_dict</span> <span class="o">=</span> <span class="n">Dict</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">key_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
            <span class="n">value_type</span><span class="o">=</span><span class="n">Dict</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">key_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">unicode_type</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="n">spike_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">)):</span>
            <span class="n">spike_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">spike_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">spike_amplitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span> <span class="o">-</span> <span class="n">baseline</span>
            <span class="n">half_width_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">spike_data</span> <span class="o">&gt;</span> <span class="n">spike_amplitude</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">spike_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;amplitude&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span> <span class="o">-</span> <span class="n">baseline</span><span class="p">,</span>
                <span class="s2">&quot;fwhm&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">half_width_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_width_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">,</span>
                <span class="s2">&quot;half_width&quot;</span><span class="p">:</span> <span class="n">half_width_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">spike_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spike_data</span><span class="p">)</span>

        <span class="n">remove_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">spike_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_fwhm</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="s2">&quot;half_width&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_half_width</span><span class="p">):</span>
                <span class="n">remove_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">remove_idx</span><span class="p">:</span>
            <span class="n">spike_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">spike_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_idx</span><span class="p">]</span>
        <span class="n">spike_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spike_vals</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">remove_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">spike_idx</span><span class="p">,</span> <span class="n">spike_vals</span><span class="p">,</span> <span class="n">spike_dict</span></div>

    <span class="c1"># @njit(&quot;(float32[:], types.List(types.Array(types.int64, 1, &#39;C&#39;)), int64, float64, float64)&quot;, fastmath=True)</span>
<div class="viewcode-block" id="TimeseriesFeatureMixin.spike_train_finder"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.spike_train_finder">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">spike_train_finder</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">spike_idx</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">min_spike_train_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="n">max_spike_train_separation</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Identify and analyze spike trains from a list of spike indices.</span>

<span class="sd">        This function takes spike indices and additional information, such as the data, sample rate,</span>
<span class="sd">        minimum spike train length, and maximum spike train separation, to identify and analyze</span>
<span class="sd">        spike trains in the data.</span>

<span class="sd">        .. note::</span>
<span class="sd">           - The function may return an empty dictionary if no spike trains meet the criteria.</span>
<span class="sd">           - A required input is ``spike_idx``, which is returned by :func:`~timeseries_features_mixin.TimeseriesFeatureMixin.spike_finder`.</span>


<span class="sd">        :param np.ndarray data: The data from which spike trains are extracted.</span>
<span class="sd">        :param types.List(types.Array(types.int64, 1, &#39;C&#39;)) data: A list of spike indices, typically as integer timestamps.</span>
<span class="sd">        :param float sample_rate: The sample rate of the data.</span>
<span class="sd">        :param Optional[float] min_spike_train_length: The minimum length a spike train must have to be considered. Default is set to positive infinity, meaning no minimum length is enforced.</span>
<span class="sd">        :param Optional[float] max_spike_train_separation: The maximum allowable separation between spikes in the same train. Default is set to positive infinity, meaning no maximum separation is enforced.</span>
<span class="sd">        :return DictType[int64,DictType[unicode_type,float64]]: A dictionary containing information about identified spike trains.</span>

<span class="sd">        Each entry in the returned dictionary is indexed by an integer, and contains the following information:</span>
<span class="sd">            - &#39;train_start_time&#39;: Start time of the spike train in seconds.</span>
<span class="sd">            - &#39;train_end_time&#39;: End time of the spike train in seconds.</span>
<span class="sd">            - &#39;train_start_obs&#39;: Start time index in observations.</span>
<span class="sd">            - &#39;train_end_obs&#39;: End time index in observations.</span>
<span class="sd">            - &#39;spike_cnt&#39;: Number of spikes in the spike train.</span>
<span class="sd">            - &#39;train_length_obs_cnt&#39;: Length of the spike train in observations.</span>
<span class="sd">            - &#39;train_length_obs_s&#39;: Length of the spike train in seconds.</span>
<span class="sd">            - &#39;train_spike_mean_lengths_s&#39;: Mean length of individual spikes in seconds.</span>
<span class="sd">            - &#39;train_spike_std_length_obs&#39;: Standard deviation of spike lengths in observations.</span>
<span class="sd">            - &#39;train_spike_std_length_s&#39;: Standard deviation of spike lengths in seconds.</span>
<span class="sd">            - &#39;train_spike_max_length_obs&#39;: Maximum spike length in observations.</span>
<span class="sd">            - &#39;train_spike_max_length_s&#39;: Maximum spike length in seconds.</span>
<span class="sd">            - &#39;train_spike_min_length_obs&#39;: Minimum spike length in observations.</span>
<span class="sd">            - &#39;train_spike_min_length_s&#39;: Minimum spike length in seconds.</span>
<span class="sd">            - &#39;train_mean_amplitude&#39;: Mean amplitude of the spike train.</span>
<span class="sd">            - &#39;train_std_amplitude&#39;: Standard deviation of spike amplitudes.</span>
<span class="sd">            - &#39;train_min_amplitude&#39;: Minimum spike amplitude.</span>
<span class="sd">            - &#39;train_max_amplitude&#39;: Maximum spike amplitude.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([0.1, 0.1, 0.3, 0.1, 10, 10, 8, 0.1, 0.1, 0.1, 10, 10, 8, 99, 0.1, 99, 99, 0.1]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; spike_idx, _, _ = TimeseriesFeatureMixin().spike_finder(data=data, baseline=0.3, min_spike_amplitude=0.2, sample_rate=2, min_fwhm=-np.inf, min_half_width=-np.inf)</span>
<span class="sd">        &gt;&gt;&gt; results = TimeseriesFeatureMixin().spike_train_finder(data=data, spike_idx=typed.List(spike_idx), sample_rate=2.0, min_spike_train_length=2.0, max_spike_train_separation=2.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="p">(</span>
            <span class="n">l</span><span class="p">,</span>
            <span class="n">r</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">train_data_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">train_spikes_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_spike_train_separation</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_spike_train_separation</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
        <span class="n">min_spike_train_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_spike_train_length</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">):</span>
            <span class="n">current_train</span><span class="p">,</span> <span class="n">current_spike_idx</span> <span class="o">=</span> <span class="n">spike_idx</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">spike_idx</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">current_train</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">max_spike_train_separation</span>
            <span class="p">):</span>
                <span class="n">current_train</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">current_train</span><span class="p">,</span> <span class="n">spike_idx</span><span class="p">[</span><span class="n">r</span><span class="p">]))</span>
                <span class="n">current_spike_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">train_data_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_train</span><span class="p">)</span>
            <span class="n">train_spikes_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_spike_idx</span><span class="p">)</span>

        <span class="n">spike_dict</span> <span class="o">=</span> <span class="n">Dict</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">key_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
            <span class="n">value_type</span><span class="o">=</span><span class="n">Dict</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="n">key_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">unicode_type</span><span class="p">,</span> <span class="n">value_type</span><span class="o">=</span><span class="n">types</span><span class="o">.</span><span class="n">float64</span>
            <span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_data_idx</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">train_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_spike_train_length</span><span class="p">:</span>
                <span class="n">spike_train_amps</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">train_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">spike_train_idx</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">k</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spike_idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">train_spikes_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">train_spike_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(([</span><span class="nb">len</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">spike_train_idx</span><span class="p">]))</span>
                <span class="n">spike_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;train_start_time&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">train_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">),</span>
                    <span class="s2">&quot;train_end_time&quot;</span><span class="p">:</span> <span class="n">train_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span>
                    <span class="s2">&quot;train_start_obs&quot;</span><span class="p">:</span> <span class="n">train_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                    <span class="s2">&quot;train_end_obs&quot;</span><span class="p">:</span> <span class="n">train_data_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="s2">&quot;spike_cnt&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_spikes_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                    <span class="s2">&quot;train_length_obs_cnt&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_train_amps</span><span class="p">),</span>
                    <span class="s2">&quot;train_length_obs_s&quot;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">spike_train_amps</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample_rate</span><span class="p">,</span>
                    <span class="s2">&quot;train_spike_mean_lengths_s&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span>
                    <span class="s2">&quot;train_spike_std_length_obs&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">),</span>
                    <span class="s2">&quot;train_spike_std_length_s&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span>
                    <span class="s2">&quot;train_spike_max_length_obs&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">),</span>
                    <span class="s2">&quot;train_spike_max_length_s&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span>
                    <span class="s2">&quot;train_spike_min_length_obs&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">),</span>
                    <span class="s2">&quot;train_spike_min_length_s&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">train_spike_lengths</span><span class="p">)</span>
                    <span class="o">*</span> <span class="n">sample_rate</span><span class="p">,</span>
                    <span class="s2">&quot;train_mean_amplitude&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spike_train_amps</span><span class="p">),</span>
                    <span class="s2">&quot;train_std_amplitude&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">spike_train_amps</span><span class="p">),</span>
                    <span class="s2">&quot;train_min_amplitude&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">spike_train_amps</span><span class="p">),</span>
                    <span class="s2">&quot;train_max_amplitude&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">spike_train_amps</span><span class="p">),</span>
                <span class="p">}</span>

        <span class="k">return</span> <span class="n">spike_dict</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_adf_executor</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to execute Augmented Dickey-Fuller (ADF) test on a data segment.</span>
<span class="sd">        Called by :meth:`timeseries_features_mixin.TimeseriesFeatureMixin.sliding_stationary_test_test`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">adfuller_results</span> <span class="o">=</span> <span class="n">adfuller</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adfuller_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">adfuller_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_kpss_executor</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to execute Kwiatkowski–Phillips–Schmidt–Shin (KPSS) test on a data segment.</span>
<span class="sd">        Called by :meth:`timeseries_features_mixin.TimeseriesFeatureMixin.sliding_stationary_test_test`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">kpss_results</span> <span class="o">=</span> <span class="n">kpss</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kpss_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kpss_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_zivotandrews_executor</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to execute Zivot-Andrews structural-break unit-root test on a data segment.</span>
<span class="sd">        Called by :meth:`timeseries_features_mixin.TimeseriesFeatureMixin.sliding_stationary_test_test`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">za_results</span> <span class="o">=</span> <span class="n">zivot_andrews</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">za_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">za_results</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_stationary"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_stationary">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sliding_stationary</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">test</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ADF&quot;</span><span class="p">,</span> <span class="s2">&quot;KPSS&quot;</span><span class="p">,</span> <span class="s2">&quot;ZA&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;adf&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform the Augmented Dickey-Fuller (ADF), Kwiatkowski-Phillips-Schmidt-Shin (KPSS), or Zivot-Andrews test on sliding windows of time series data.</span>
<span class="sd">        Parallel processing using all available cores is used to accelerate computation.</span>

<span class="sd">        .. note::</span>
<span class="sd">           - ADF: A high p-value suggests non-stationarity, while a low p-value indicates stationarity.</span>
<span class="sd">           - KPSS: A high p-value suggests stationarity, while a low p-value indicates non-stationarity.</span>
<span class="sd">           - ZA: A high p-value suggests non-stationarity, while a low p-value indicates stationarity.</span>

<span class="sd">        :param np.ndarray data: 1-D NumPy array containing the time series data to be tested.</span>
<span class="sd">        :param np.ndarray time_windows: A 1-D NumPy array containing the time window sizes in seconds.</span>
<span class="sd">        :param np.ndarray sample_rate: The sample rate of the time series data (samples per second).</span>
<span class="sd">        :param Literal test: Test to perfrom: Options: &#39;ADF&#39; (Augmented Dickey-Fuller), &#39;KPSS&#39; (Kwiatkowski-Phillips-Schmidt-Shin), &#39;ZA&#39; (Zivot-Andrews).</span>
<span class="sd">        :return (np.ndarray, np.ndarray): A tuple of two 2-D NumPy arrays containing test statistics and p-values. - The first array (stat) contains the ADF test statistics. - The second array (p_vals) contains the corresponding p-values</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().sliding_stationary(data=data, time_windows=np.array([2.0]), test=&#39;KPSS&#39;, sample_rate=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">stat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="n">p_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;ADF&quot;</span><span class="p">:</span>
            <span class="n">test_func</span> <span class="o">=</span> <span class="n">TimeseriesFeatureMixin</span><span class="p">()</span><span class="o">.</span><span class="n">_adf_executor</span>
        <span class="k">elif</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;KPSS&quot;</span><span class="p">:</span>
            <span class="n">test_func</span> <span class="o">=</span> <span class="n">TimeseriesFeatureMixin</span><span class="p">()</span><span class="o">.</span><span class="n">_kpss_executor</span>
        <span class="k">elif</span> <span class="n">test</span> <span class="o">==</span> <span class="s2">&quot;ZA&quot;</span><span class="p">:</span>
            <span class="n">test_func</span> <span class="o">=</span> <span class="n">TimeseriesFeatureMixin</span><span class="p">()</span><span class="o">.</span><span class="n">_zivotandrews_executor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">TimeseriesFeatureMixin</span><span class="p">()</span><span class="o">.</span><span class="n">sliding_stationary</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">InvalidInputError</span><span class="p">(</span>
                <span class="n">msg</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Test </span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="s1"> not recognized. Options: </span><span class="si">{</span><span class="n">type_hints</span><span class="p">[</span><span class="s2">&quot;test&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">window_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="n">strided_data</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">window_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">window_size</span><span class="p">),</span>
                <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">find_core_cnt</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">maxtasksperchild</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="n">pool</span><span class="o">.</span><span class="n">imap</span><span class="p">(</span><span class="n">test_func</span><span class="p">,</span> <span class="n">strided_data</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">stat</span><span class="p">[</span><span class="n">cnt</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">p_vals</span><span class="p">[</span><span class="n">cnt</span> <span class="o">+</span> <span class="n">window_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">stat</span><span class="p">,</span> <span class="n">p_vals</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.acceleration"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.acceleration">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="s2">&quot;(float32[:], float64, int64, float64, types.unicode_type)&quot;</span><span class="p">,</span>
            <span class="s1">&#39;(float32[:], float64, int64, float64, types.misc.Omitted(&quot;mm&quot;))&#39;</span><span class="p">,</span>
            <span class="s2">&quot;(float32[:], float64, int64, types.misc.Omitted(1), types.unicode_type)&quot;</span><span class="p">,</span>
            <span class="s1">&#39;(float32[:], float64, int64, types.misc.Omitted(1), types.misc.Omitted(&quot;mm&quot;))&#39;</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">acceleration</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">pixels_per_mm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                     <span class="n">fps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                     <span class="n">time_window</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">unit</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mm&quot;</span><span class="p">,</span> <span class="s2">&quot;cm&quot;</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute acceleration.</span>

<span class="sd">        Computes acceleration from a sequence of body-part coordinates over time. It calculates the difference in velocity between consecutive frames and provides an array of accelerations.</span>

<span class="sd">        The computation is based on the formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\text{{Acceleration}}(t) = \\frac{{\\text{{Norm}}(\\text{{Shift}}(\\text{{data}}[t], t, t-1) - \\text{{data}}[t])}}{{\\text{{pixels\\_per\\_mm}}}}</span>

<span class="sd">        where :math:`\\text{{Norm}}` calculates the Euclidean norm, :math:`\\text{{Shift}}(\\text{{array}}, t, t-1)` shifts the array by :math:`t-1` frames, and :math:`\\text{{pixels\\_per\\_mm}}` is the conversion factor from pixels to millimeters.</span>

<span class="sd">        .. note::</span>
<span class="sd">           By default, acceleration is calculated as change in velocity at millimeters/s. To change the denomitator, modify the ``time_window`` argument. To change the nominator, modify the ``unit`` argument (accepted ``mm``, cm``, ``dm``, ``mm``)</span>

<span class="sd">        .. image:: _static/img/acceleration.png</span>
<span class="sd">           :width: 700</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray data: 1D array of framewise euclidean distances.</span>
<span class="sd">        :param float pixels_per_mm: Pixels per millimeter of the recorded video.</span>
<span class="sd">        :param int fps: Frames per second (FPS) of the recorded video.</span>
<span class="sd">        :param float time_window: Rolling time window in seconds. Default is 1.0 representing 1 second.</span>
<span class="sd">        :param Literal[&#39;mm&#39;, &#39;cm&#39;, &#39;dm&#39;, &#39;m&#39;] unit:  If acceleration should be presented as millimeter, centimeters, decimeter, or meter. Default millimeters.</span>
<span class="sd">        :return: Array of accelerations corresponding to each frame.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 5, 5, 5, 5, 6]).astype(np.float32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin().acceleration(data=data, pixels_per_mm=1.0, fps=2, time_window=1.0)</span>
<span class="sd">        &gt;&gt;&gt; [ 0.,  0.,  0.,  0., -1., -1.,  0.,  0.,  1.,  1.]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span><span class="p">,</span> <span class="n">velocity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">size</span><span class="p">,</span> <span class="n">pv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_window</span> <span class="o">*</span> <span class="n">fps</span><span class="p">),</span> <span class="kc">None</span>
        <span class="n">data_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_split</span><span class="p">)):</span>
            <span class="n">wS</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">wE</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">wS</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">data_split</span><span class="p">[</span><span class="n">i</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">pixels_per_mm</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;cm&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="mi">10</span>
            <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;dm&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="mi">1000</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">wS</span><span class="p">:</span><span class="n">wE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">results</span><span class="p">[</span><span class="n">wS</span><span class="p">:</span><span class="n">wE</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="n">pv</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">results</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.granger_tests"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.granger_tests">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">granger_tests</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">variables</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">lag</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">test</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;ssr_ftest&quot;</span><span class="p">,</span> <span class="s2">&quot;ssr_chi2test&quot;</span><span class="p">,</span> <span class="s2">&quot;lrtest&quot;</span><span class="p">,</span> <span class="s2">&quot;params_ftest&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ssr_chi2test&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform Granger causality tests between pairs of variables in a DataFrame.</span>

<span class="sd">        This function computes Granger causality tests between pairs of variables in a DataFrame</span>
<span class="sd">        using the statsmodels library. The Granger causality test assesses whether one time series</span>
<span class="sd">        variable (predictor) can predict another time series variable (outcome). This test can help</span>
<span class="sd">        determine the presence of causal relationships between variables.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Modified from `Selva Prabhakaran &lt;https://www.machinelearningplus.com/time-series/granger-causality-test-in-python/&gt;`_.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 50, (100, 2))</span>
<span class="sd">        &gt;&gt;&gt; data = pd.DataFrame(x, columns=[&#39;r&#39;, &#39;k&#39;])</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin.granger_tests(data=data, variables=[&#39;r&#39;, &#39;k&#39;], lag=4, test=&#39;ssr_chi2test&#39;)</span>
<span class="sd">        &gt;&gt;&gt;     r           k</span>
<span class="sd">        &gt;&gt;&gt;     r  1.0000  0.4312</span>
<span class="sd">        &gt;&gt;&gt;     k  0.3102  1.0000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_instance</span><span class="p">(</span>
            <span class="n">source</span><span class="o">=</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">granger_tests</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">accepted_types</span><span class="o">=</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="n">check_valid_lst</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">granger_tests</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">valid_dtypes</span><span class="o">=</span><span class="p">(</span><span class="nb">str</span><span class="p">,),</span>
            <span class="n">min_len</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_that_column_exist</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">column_name</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">check_str</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">granger_tests</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">test</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;ssr_ftest&quot;</span><span class="p">,</span> <span class="s2">&quot;ssr_chi2test&quot;</span><span class="p">,</span> <span class="s2">&quot;lrtest&quot;</span><span class="p">,</span> <span class="s2">&quot;params_ftest&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">granger_tests</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">))),</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">grangercausalitytests</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]],</span> <span class="n">maxlag</span><span class="o">=</span><span class="p">[</span><span class="n">lag</span><span class="p">],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">p_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">lag</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">test</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_val</span>
        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_displacement"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_displacement">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(int32[:,:], float64[:], float64, float64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_displacement</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">px_per_mm</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sliding Euclidean displacement of a body-part point over time windows.</span>

<span class="sd">        .. image:: _static/img/sliding_displacement.png</span>
<span class="sd">           :width: 600</span>
<span class="sd">           :align: center</span>

<span class="sd">        :param np.ndarray x: An array of shape (n, 2) representing the time-series sequence of 2D points.</span>
<span class="sd">        :param np.ndarray time_windows: Array of time windows (in seconds).</span>
<span class="sd">        :param float fps: The sample rate (frames per second) of the sequence.</span>
<span class="sd">        :param float px_per_mm: Pixels per millimeter conversion factor.</span>
<span class="sd">        :return np.ndarray: 1D array containing the calculated displacements.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 50, (100, 2)).astype(np.int32)</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin.sliding_displacement(x=x, time_windows=np.array([1.0]), fps=1.0, px_per_mm=1.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">time_windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">w</span><span class="p">]</span>
                <span class="n">results</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span> <span class="o">/</span> <span class="n">px_per_mm</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_two_signal_crosscorrelation"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_two_signal_crosscorrelation">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@njit</span><span class="p">(</span><span class="s2">&quot;(float64[:], float64[:], float64[:], float64, boolean, float64)&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sliding_two_signal_crosscorrelation</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">sample_rate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">lag</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate sliding (lagged) cross-correlation between two signals, e.g., the movement and velocity of two animals.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If no lag needed, pass lag 0.0.</span>

<span class="sd">        :param np.ndarray x: The first input signal.</span>
<span class="sd">        :param np.ndarray y: The second input signal.</span>
<span class="sd">        :param np.ndarray windows: Array of window lengths in seconds.</span>
<span class="sd">        :param float sample_rate: Sampling rate of the signals (in Hz or FPS).</span>
<span class="sd">        :param bool normalize: If True, normalize the signals before computing the correlation.</span>
<span class="sd">        :param float lag: Time lag between the signals in seconds.</span>

<span class="sd">        :return: 2D array of sliding cross-correlation values. Each row corresponds to a time index, and each column corresponds to a window size specified in the `windows` parameter.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 10, size=(20,))</span>
<span class="sd">        &gt;&gt;&gt; y = np.random.randint(0, 10, size=(20,))</span>
<span class="sd">        &gt;&gt;&gt; TimeseriesFeatureMixin.sliding_two_signal_crosscorrelation(x=x, y=y, windows=np.array([1.0, 1.2]), sample_rate=10, normalize=True, lag=0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">lag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span> <span class="o">*</span> <span class="n">lag</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">W_s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sample_rate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">W_s</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l1</span> <span class="o">-</span> <span class="n">lag</span>
                <span class="k">if</span> <span class="n">l2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">l2</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">r2</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">-</span> <span class="n">lag</span>
                <span class="k">if</span> <span class="n">r2</span> <span class="o">-</span> <span class="n">l2</span> <span class="o">&lt;</span> <span class="n">W_s</span><span class="p">:</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">l2</span> <span class="o">+</span> <span class="n">W_s</span>
                <span class="n">X_w</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">l1</span><span class="p">:</span><span class="n">r1</span><span class="p">]</span>
                <span class="n">Y_w</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">l2</span><span class="p">:</span><span class="n">r2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
                    <span class="n">X_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">X_w</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_w</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_w</span><span class="p">)</span> <span class="o">*</span> <span class="n">X_w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">Y_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">Y_w</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Y_w</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Y_w</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">X_w</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">Y_w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">r1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">results</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">r1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">results</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeseriesFeatureMixin.sliding_pct_in_top_n"><a class="viewcode-back" href="../../../simba.mixins.html#simba.mixins.timeseries_features_mixin.TimeseriesFeatureMixin.sliding_pct_in_top_n">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">sliding_pct_in_top_n</span><span class="p">(</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the percentage of elements in the top &#39;n&#39; frequencies in sliding windows of the input array.</span>

<span class="sd">        .. note::</span>
<span class="sd">          To compute percentage of elements in the top &#39;n&#39; frequencies in entire array, use ``simba.mixins.statistics_mixin.Statistics.pct_in_top_n``.</span>

<span class="sd">        :param np.ndarray x: Input 1D array.</span>
<span class="sd">        :param np.ndarray windows: Array of window sizes in seconds.</span>
<span class="sd">        :param int n: Number of top frequencies.</span>
<span class="sd">        :param float fps: Sampling frequency for time convesrion.</span>
<span class="sd">        :return np.ndarray: 2D array of computed percentages of elements in the top &#39;n&#39; frequencies for each sliding window.</span>

<span class="sd">        :example:</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(0, 10, (100000,))</span>
<span class="sd">        &gt;&gt;&gt; results = TimeseriesFeatureMixin.sliding_pct_in_top_n(x=x, windows=np.array([1.0]), n=4, fps=10)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">sliding_pct_in_top_n</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> x&quot;</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_valid_array</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">sliding_pct_in_top_n</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> windows&quot;</span><span class="p">,</span>
            <span class="n">accepted_ndims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
            <span class="n">accepted_dtypes</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">check_int</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">sliding_pct_in_top_n</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> n&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">check_float</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">TimeseriesFeatureMixin</span><span class="o">.</span><span class="n">sliding_pct_in_top_n</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fps&quot;</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">n</span><span class="p">,</span>
            <span class="n">min_value</span><span class="o">=</span><span class="mf">10e-6</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">W_s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">fps</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cnt</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">W_s</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">):</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">l</span><span class="p">:</span><span class="n">r</span><span class="p">]</span>
                <span class="n">cnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span>
                <span class="n">results</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cnts</span><span class="p">)</span> <span class="o">/</span> <span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">results</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, sronilsson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>